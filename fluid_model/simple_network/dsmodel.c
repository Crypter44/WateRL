#define DYNEventSpecial
#define DYNCallStackData
/* DSblock model generated by Dymola from Modelica model simple_network
 Dymola Version 2024x, 2023-10-06 translated this at Thu Oct 24 17:17:13 2024

   */
#ifndef DYN_MULTINSTANCE
#define DYN_MULTINSTANCE 1
#endif

#include <matrixop.h>
#include "matrixop.c"
static const char* DymArrays2[1]={"SimpleLiquidWater"};
#if defined(DynSimStruct)
static double DymArrays0[3]={3.0, 3.0, 3.0};
static double DymArrays1[5]={1.0, 1.0, 1.0, 1.0, 4.0};
#endif
/* Declaration of C-structs */
/* Prototypes for functions used in model */
struct Modelica_Fluid_Pipes_BaseClasses_WallFriction_Detailed_Internal_mx_0flowx_0ofx_0dpx_0fric_struct {
  double   mx_0flow_0member;
  double   dmx_0flowx_0ddpx_0fric_0member;
};
DYMOLA_STATIC struct Modelica_Fluid_Pipes_BaseClasses_WallFriction_Detailed_Internal_mx_0flowx_0ofx_0dpx_0fric_struct
   Modelica_Fluid_Pipes_BaseClasses_WallFriction_Detailed_Internal_mx_0flowx_0ofx_0dpx_0fric
  (double  dpx_0fric, double  rhox_0a, double  rhox_0b, double  mux_0a, double  
  mux_0b, double  length0_0, double  diameter0_0, double  crossArea0_0, double  
  Re10_0, double  Re20_0, double  Delta0_0, struct DYNFunctionData_* DYNStackData_);
struct Modelica_Fluid_Pipes_BaseClasses_WallFriction_Detailed_Internal_mx_0flowx_0ofx_0dpx_0fric_interpolateInRegion2x_0withDerivative_struct {
  double   Re0_0_0member;
  double   dRex_0ddp_0member;
};
DYMOLA_STATIC struct Modelica_Fluid_Pipes_BaseClasses_WallFriction_Detailed_Internal_mx_0flowx_0ofx_0dpx_0fric_interpolateInRegion2x_0withDerivative_struct
   Modelica_Fluid_Pipes_BaseClasses_WallFriction_Detailed_Internal_mx_0flowx_0ofx_0dpx_0fric_interpolateInRegion2x_0withDerivative
  (double  lambda20_0, double  Re10_0, double  Re20_0, double  Delta0_0, double 
   dpx_0fric, struct DYNFunctionData_* DYNStackData_);
struct Modelica_Fluid_Pipes_BaseClasses_WallFriction_Detailed_Internal_mx_0flowx_0ofx_0dpx_0fric_interpolateInRegion2x_0withDerivative__der_struct {
  double   Rex_0der_0member;
  double   dRex_0ddpx_0der_0member;
};
DYMOLA_STATIC struct Modelica_Fluid_Pipes_BaseClasses_WallFriction_Detailed_Internal_mx_0flowx_0ofx_0dpx_0fric_interpolateInRegion2x_0withDerivative__der_struct
   Modelica_Fluid_Pipes_BaseClasses_WallFriction_Detailed_Internal_mx_0flowx_0ofx_0dpx_0fric_interpolateInRegion2x_0withDerivative__der
  (double  lambda20_0, double  Re10_0, double  Re20_0, double  Delta0_0, double 
   dpx_0fric, double  lambda2x_0der, double  Re1x_0der, double  Re2x_0der, 
  double  Deltax_0der, double  dpx_0fricx_0der, struct DYNFunctionData_* DYNStackData_);
struct Modelica_Fluid_Pipes_BaseClasses_WallFriction_Detailed_Internal_mx_0flowx_0ofx_0dpx_0fric__der_struct {
  double   mx_0flowx_0der_0member;
  double   dmx_0flowx_0ddpx_0fricx_0der_0member;
};
DYMOLA_STATIC struct Modelica_Fluid_Pipes_BaseClasses_WallFriction_Detailed_Internal_mx_0flowx_0ofx_0dpx_0fric__der_struct
   Modelica_Fluid_Pipes_BaseClasses_WallFriction_Detailed_Internal_mx_0flowx_0ofx_0dpx_0fric__der
  (double  dpx_0fric, double  rhox_0a, double  rhox_0b, double  mux_0a, double  
  mux_0b, double  length0_0, double  diameter0_0, double  crossArea0_0, double  
  Re10_0, double  Re20_0, double  Delta0_0, double  dpx_0fricx_0der, double  
  rhox_0ax_0der, double  rhox_0bx_0der, double  mux_0ax_0der, double  
  mux_0bx_0der, double  lengthx_0der, double  diameterx_0der, double  
  crossAreax_0der, double  Re1x_0der, double  Re2x_0der, double  Deltax_0der, 
  struct DYNFunctionData_* DYNStackData_);
DYMOLA_STATIC void Modelica_Fluid_Utilities_checkBoundary(const char*  
  mediumName0_0, StringArray   substanceNames0_0, int  singleState0_0, int  
  definex_0p, RealArray   Xx_0boundary, const char*  modelName0_0, 
  struct DYNFunctionData_* DYNStackData_);
struct Modelica_Fluid_Utilities_cubicHermitex_0withDerivative_struct {
  double   y0_0_0member;
  double   dyx_0dx_0member;
};
DYMOLA_STATIC struct Modelica_Fluid_Utilities_cubicHermitex_0withDerivative_struct
   Modelica_Fluid_Utilities_cubicHermitex_0withDerivative(double  x0_0, double  
  x10_0, double  x20_0, double  y10_0, double  y20_0, double  y1d0_0, double  
  y2d0_0, struct DYNFunctionData_* DYNStackData_);
struct Modelica_Fluid_Utilities_cubicHermitex_0withDerivative__der_struct {
  double   yx_0der_0member;
  double   dyx_0dxx_0der_0member;
};
DYMOLA_STATIC struct Modelica_Fluid_Utilities_cubicHermitex_0withDerivative__der_struct
   Modelica_Fluid_Utilities_cubicHermitex_0withDerivative__der(double  x0_0, 
  double  x10_0, double  x20_0, double  y10_0, double  y20_0, double  y1d0_0, 
  double  y2d0_0, double  xx_0der, double  x1x_0der, double  x2x_0der, double  
  y1x_0der, double  y2x_0der, double  y1dx_0der, double  y2dx_0der, 
  struct DYNFunctionData_* DYNStackData_);
struct Modelica_Fluid_Utilities_regFun3_struct {
  double   y0_0_0member;
  double   c0_0_0member;
};
DYMOLA_STATIC struct Modelica_Fluid_Utilities_regFun3_struct Modelica_Fluid_Utilities_regFun3
  (double  x0_0, double  x00_0, double  x10_0, double  y00_0, double  y10_0, 
  double  y0d0_0, double  y1d0_0, struct DYNFunctionData_* DYNStackData_);
struct Modelica_Fluid_Utilities_regFun3__der_struct {
  double   yx_0der_0member;
  double   cx_0der_0member;
};
DYMOLA_STATIC struct Modelica_Fluid_Utilities_regFun3__der_struct 
  Modelica_Fluid_Utilities_regFun3__der(double  x0_0, double  x00_0, double  
  x10_0, double  y00_0, double  y10_0, double  y0d0_0, double  y1d0_0, double  
  xx_0der, double  x0x_0der, double  x1x_0der, double  y0x_0der, double  
  y1x_0der, double  y0dx_0der, double  y1dx_0der, struct DYNFunctionData_* DYNStackData_);
DYMOLA_STATIC double   interpolateInRegion2x_0Unique15(double  Re0_0, double  
  Re10_0, double  Re20_0, double  Delta0_0, struct DYNFunctionData_* DYNStackData_);
DYMOLA_STATIC double   massFlowRatex_0dpx_0staticHeadx_0Unique18(double  dp0_0, 
  double  rhox_0a, double  rhox_0b, double  mux_0a, double  mux_0b, double  
  length0_0, double  diameter0_0, double  gx_0timesx_0heightx_0ab, double  
  crossArea0_0, double  roughness0_0, double  dpx_0small, double  Rex_0turbulent,
   struct DYNFunctionData_* DYNStackData_);
DYMOLA_STATIC double   massFlowRatex_0dpx_0staticHeadx_0Unique18__der(double  
  dp0_0, double  rhox_0a, double  rhox_0b, double  mux_0a, double  mux_0b, 
  double  length0_0, double  diameter0_0, double  gx_0timesx_0heightx_0ab, 
  double  crossArea0_0, double  roughness0_0, double  dpx_0small, double  
  Rex_0turbulent, double  dpx_0der, double  rhox_0ax_0der, double  rhox_0bx_0der,
   double  mux_0ax_0der, double  mux_0bx_0der, double  lengthx_0der, double  
  diameterx_0der, double  gx_0timesx_0heightx_0abx_0der, double  crossAreax_0der,
   double  roughnessx_0der, double  dpx_0smallx_0der, double  Rex_0turbulentx_0der,
   struct DYNFunctionData_* DYNStackData_);
DYMOLA_STATIC double   pressureLossx_0mx_0flowx_0Unique14(double  mx_0flow, 
  double  rhox_0a, double  rhox_0b, double  mux_0a, double  mux_0b, double  
  length0_0, double  diameter0_0, double  crossArea0_0, double  roughness0_0, 
  double  mx_0flowx_0small, double  Rex_0turbulent, struct DYNFunctionData_* DYNStackData_);
/* Codes used in model */

/* Flattened Modelica model:

function Modelica.Fluid.Utilities.checkBoundary
input String mediumName;
input String substanceNames[:] "Names of substances";
input Boolean singleState;
input Boolean define_p;
discrete input Real X_boundary[:];
input String modelName(start = "??? boundary ???");
protected 
Integer nX(start = size(X_boundary, 1));
String X_str;
public 
algorithm 
assert( not singleState or singleState and define_p, "
Wrong value of parameter define_p (= false) in model \""+modelName+"\":
The selected medium \""+mediumName+"\" has Medium.singleState=true.
Therefore, an boundary density cannot be defined and
define_p = true is required.
");
for i in (1:nX) loop
assert(X_boundary[i] >= 0.0, "
Wrong boundary mass fractions in medium \""+mediumName+"\" in model \""+modelName+"\":
The boundary value X_boundary("+       String(i, true, 0)+") = "+       String(X_boundary[i], true, 0)+"
is negative. It must be positive.
");
end for;
if (nX > 0 and abs(sum(X_boundary)-1.0) > 1E-10) then 
X_str := "";
for i in (1:nX) loop
X_str := X_str+"   X_boundary["+       String(i, true, 0)+"] = "+       String(X_boundary[i], true, 0)+" \""+substanceNames[i]+"\"\n";
end for;
ModelicaError("The boundary mass fractions in medium \""+mediumName+"\" in model \""+modelName+"\"\n"+"do not sum up to 1. Instead, sum(X_boundary) = "+       String(sum(X_boundary), true, 0)+":\n"+X_str);
end if;
end Modelica.Fluid.Utilities.checkBoundary;

  */
DYMOLA_STATIC void Modelica_Fluid_Utilities_checkBoundary(const char*  
  mediumName0_0, StringArray   substanceNames0_0, int  singleState0_0, int  
  definex_0p, RealArray   Xx_0boundary, const char*  modelName0_0, 
  struct DYNFunctionData_* DYNStackData_) {
  char*retSMark_=DYNJGetStringMark(DYNStackData_);
  DYNJPushContext("Modelica.Fluid.Utilities.checkBoundary", DYNStackData_)
  {
    /* Declare outputs and temporaries */
    int   nX0_0;
    const char*   Xx_0str;
    MarkObject retmark_ = DYNJPushMark(DYNStackData_);
    nX0_0 = DYNSizeSimple(Xx_0boundary, 1);
    Xx_0str="";
    /* Start of real code */
      AssertModelica( NOT singleState0_0 OR singleState0_0 AND definex_0p,
        " not singleState or singleState and define_p", StringAdd(StringAdd(
        StringAdd(StringAdd("\nWrong value of parameter define_p (= false) in model \"",
        modelName0_0),"\":\nThe selected medium \""),mediumName0_0),
        "\" has Medium.singleState=true.\nTherefore, an boundary density cannot be defined and\ndefine_p = true is required.\n"));
      {
        int end_ = nX0_0;
        int i0_0_0;
        for(i0_0_0 = 1;i0_0_0 <= end_;i0_0_0 += 1) {
          AssertModelica(RealElement( Xx_0boundary, (SizeType)(i0_0_0)) >= 0.0,
            "X_boundary[i] >= 0.0", StringAdd(StringAdd(StringAdd(StringAdd(
            StringAdd(StringAdd(StringAdd(StringAdd("\nWrong boundary mass fractions in medium \"",
            mediumName0_0),"\" in model \""),modelName0_0),"\":\nThe boundary value X_boundary("),
            Integer2String2(i0_0_0, true, 0)),") = "),Real2String2(RealElement( 
            Xx_0boundary, (SizeType)(i0_0_0)), true, 0)),"\nis negative. It must be positive.\n"));
        }
      }
      if (nX0_0 > 0 AND fabs(Realsum( Xx_0boundary)-1.0) > 1E-10) {
        Xx_0str = DYNJSqueezeString("", retSMark_, DYNStackData_);
        DYNJRelease(DYNStackData_);
        {
          int end_ = nX0_0;
          int i0_0_0;
          for(i0_0_0 = 1;i0_0_0 <= end_;i0_0_0 += 1) {
            Xx_0str = DYNJSqueezeString(StringAdd(StringAdd(StringAdd(StringAdd(
              StringAdd(StringAdd(StringAdd(Xx_0str,"   X_boundary["),
              Integer2String2(i0_0_0, true, 0)),"] = "),Real2String2(
              RealElement( Xx_0boundary, (SizeType)(i0_0_0)), true, 0))," \""),
              StringElement( substanceNames0_0, (SizeType)(i0_0_0))),"\"\n"), retSMark_,
               DYNStackData_);
          }
        }
        ModelicaError(StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(
          StringAdd(StringAdd(StringAdd("The boundary mass fractions in medium \"",
          mediumName0_0),"\" in model \""),modelName0_0),"\"\n"),
          "do not sum up to 1. Instead, sum(X_boundary) = "),Real2String2(
          Realsum( Xx_0boundary), true, 0)),":\n"),Xx_0str));
        DYNJRelease(DYNStackData_);
      }
    /* Output section */
    DYNJPopMark(retmark_, DYNStackData_);
    DYNJSetStringMark(retSMark_, DYNStackData_);
    DYNJPopContext(DYNStackData_)
    return ;
  }}

/* Flattened Modelica model:

function massFlowRate_dp_staticHead_Unique18
discrete input Real dp(unit = "Pa", displayUnit = "bar") "Pressure loss (dp = port_a.p - port_b.p)";
discrete input Real rho_a(unit = "kg/m3", displayUnit = "g/cm3", min = 0.0) "Density at port_a";
discrete input Real rho_b(unit = "kg/m3", displayUnit = "g/cm3", min = 0.0) "Density at port_b";
discrete input Real mu_a(unit = "Pa.s", min = 0.0) "Dynamic viscosity at port_a (dummy if use_mu = false)";
discrete input Real mu_b(unit = "Pa.s", min = 0.0) "Dynamic viscosity at port_b (dummy if use_mu = false)";
discrete input Real length(unit = "m") "Length of pipe";
discrete input Real diameter(unit = "m", min = 0.0) "Inner (hydraulic) diameter of pipe";
discrete input Real g_times_height_ab(unit = "m2/s2") "Gravity times (Height(port_b) - Height(port_a))";
discrete input Real crossArea(start = 0.7853981633974483*diameter^2, unit = "m2") "Inner cross section area";
discrete input Real roughness(start = 2.5E-05, unit = "m", displayUnit = "mm", min = 0.0) "Absolute roughness of pipe, with a default for a smooth steel pipe (dummy if use_roughness = false)";
discrete input Real dp_small(start = 1, nominal = 100000.0, unit = "Pa", displayUnit = "bar", min = 0.0) "Regularization of zero flow if |dp| < dp_small (dummy if use_dp_small = false)";
discrete input Real Re_turbulent(start = 4000, unit = "1") "Turbulent flow if Re >= Re_turbulent (dummy if use_Re_turbulent = false)";
discrete output Real m_flow(unit = "kg/s") "Mass flow rate from port_a to port_b";
protected 
discrete Real Delta(start = roughness/diameter, min = 0.0) "Relative roughness";
discrete Real Re(unit = "1") "Reynolds number";
discrete Real Re1(start = min((745*exp((if Delta <= 0.0065 then 1 else 0.0065/Delta)))^0.97, Re_turbulent), unit = "1") "Boundary between laminar regime and transition";
discrete Real Re2(start = Re_turbulent, unit = "1") "Boundary between transition and turbulent regime";
discrete Real dp_a(unit = "Pa", displayUnit = "bar") "Upper end of regularization domain of the m_flow(dp) relation";
discrete Real dp_b(unit = "Pa", displayUnit = "bar") "Lower end of regularization domain of the m_flow(dp) relation";
discrete Real m_flow_a(unit = "kg/s") "Value at upper end of regularization domain";
discrete Real m_flow_b(unit = "kg/s") "Value at lower end of regularization domain";
discrete Real dm_flow_ddp_fric_a(unit = "kg/s") "Derivative at upper end of regularization domain";
discrete Real dm_flow_ddp_fric_b(unit = "kg/s") "Derivative at lower end of regularization domain";
discrete Real dp_grav_a(start = g_times_height_ab*rho_a, unit = "Pa", displayUnit = "bar") "Static head if mass flows in design direction (a to b)";
discrete Real dp_grav_b(start = g_times_height_ab*rho_b, unit = "Pa", displayUnit = "bar") "Static head if mass flows against design direction (b to a)";
discrete Real m_flow_zero(start = 0, unit = "kg/s");
discrete Real dp_zero(start = 0.5*(dp_grav_a+dp_grav_b), unit = "Pa", displayUnit = "bar");
discrete Real dm_flow_ddp_fric_zero;
public 
algorithm 
dp_a := max(dp_grav_a, dp_grav_b)+dp_small;
dp_b := min(dp_grav_a, dp_grav_b)-dp_small;
if (dp >= dp_a) then 
m_flow := Modelica.Fluid.Pipes.BaseClasses.WallFriction.Detailed.Internal.m_flow_of_dp_fric(dp-dp_grav_a, rho_a, rho_b, mu_a, mu_b, length, diameter, crossArea, Re1, Re2, Delta);
elseif (dp <= dp_b) then 
m_flow := Modelica.Fluid.Pipes.BaseClasses.WallFriction.Detailed.Internal.m_flow_of_dp_fric(dp-dp_grav_b, rho_a, rho_b, mu_a, mu_b, length, diameter, crossArea, Re1, Re2, Delta);
else
(m_flow_a, dm_flow_ddp_fric_a)  := Modelica.Fluid.Pipes.BaseClasses.WallFriction.Detailed.Internal.m_flow_of_dp_fric(dp_a-dp_grav_a, rho_a, rho_b, mu_a, mu_b, length, diameter, crossArea, Re1, Re2, Delta);
(m_flow_b, dm_flow_ddp_fric_b)  := Modelica.Fluid.Pipes.BaseClasses.WallFriction.Detailed.Internal.m_flow_of_dp_fric(dp_b-dp_grav_b, rho_a, rho_b, mu_a, mu_b, length, diameter, crossArea, Re1, Re2, Delta);
(m_flow, dm_flow_ddp_fric_zero)  := Modelica.Fluid.Utilities.regFun3(dp_zero, dp_b, dp_a, m_flow_b, m_flow_a, dm_flow_ddp_fric_b, dm_flow_ddp_fric_a);
if (dp > dp_zero) then 
m_flow := Modelica.Fluid.Utilities.regFun3(dp, dp_zero, dp_a, m_flow_zero, m_flow_a, dm_flow_ddp_fric_zero, dm_flow_ddp_fric_a);
else
m_flow := Modelica.Fluid.Utilities.regFun3(dp, dp_b, dp_zero, m_flow_b, m_flow_zero, dm_flow_ddp_fric_b, dm_flow_ddp_fric_zero);
end if;
end if;
annotation(derivative=massFlowRate_dp_staticHead_Unique18:der, smoothOrder=1);
end massFlowRate_dp_staticHead_Unique18;

  */
DYMOLA_STATIC double   massFlowRatex_0dpx_0staticHeadx_0Unique18(double  dp0_0, 
  double  rhox_0a, double  rhox_0b, double  mux_0a, double  mux_0b, double  
  length0_0, double  diameter0_0, double  gx_0timesx_0heightx_0ab, double  
  crossArea0_0, double  roughness0_0, double  dpx_0small, double  Rex_0turbulent,
   struct DYNFunctionData_* DYNStackData_) {
  DYNJPushContext("massFlowRate_dp_staticHead_Unique18", DYNStackData_)
  {
    /* Declare outputs and temporaries */
    double   mx_0flow;
    double   Delta0_0;
    double   Re0_0;
    double   Re10_0;
    double   Re20_0;
    double   dpx_0a;
    double   dpx_0b;
    double   mx_0flowx_0a;
    double   mx_0flowx_0b;
    double   dmx_0flowx_0ddpx_0fricx_0a;
    double   dmx_0flowx_0ddpx_0fricx_0b;
    double   dpx_0gravx_0a;
    double   dpx_0gravx_0b;
    double   mx_0flowx_0zero;
    double   dpx_0zero;
    double   dmx_0flowx_0ddpx_0fricx_0zero;
    mx_0flow=0;
    Delta0_0 = divGuarded(roughness0_0,"roughness",diameter0_0,"diameter");
    Re0_0=0;
    Re10_0 = RealBmin(powGuarded(745*exp(IF Delta0_0 <= 0.0065 THEN 1 ELSE 
      divGuarded(0.0065,"0.0065",Delta0_0,"Delta")),"745*exp((if Delta <= 0.0065 then 1 else 0.0065/Delta))",
      0.97,"0.97"), Rex_0turbulent);
    Re20_0 = Rex_0turbulent;
    dpx_0a=0;
    dpx_0b=0;
    mx_0flowx_0a=0;
    mx_0flowx_0b=0;
    dmx_0flowx_0ddpx_0fricx_0a=0;
    dmx_0flowx_0ddpx_0fricx_0b=0;
    dpx_0gravx_0a = gx_0timesx_0heightx_0ab*rhox_0a;
    dpx_0gravx_0b = gx_0timesx_0heightx_0ab*rhox_0b;
    mx_0flowx_0zero = 0;
    dpx_0zero = 0.5*(dpx_0gravx_0a+dpx_0gravx_0b);
    dmx_0flowx_0ddpx_0fricx_0zero=0;
    /* Start of real code */
      dpx_0a = RealBmax(dpx_0gravx_0a, dpx_0gravx_0b)+dpx_0small;
      dpx_0b = RealBmin(dpx_0gravx_0a, dpx_0gravx_0b)-dpx_0small;
      if (dp0_0 >= dpx_0a) {
        mx_0flow = Modelica_Fluid_Pipes_BaseClasses_WallFriction_Detailed_Internal_mx_0flowx_0ofx_0dpx_0fric
          (dp0_0-dpx_0gravx_0a, rhox_0a, rhox_0b, mux_0a, mux_0b, length0_0, 
          diameter0_0, crossArea0_0, Re10_0, Re20_0, Delta0_0, DYNStackData_).
          mx_0flow_0member;
      }
      else if (dp0_0 <= dpx_0b) {
        mx_0flow = Modelica_Fluid_Pipes_BaseClasses_WallFriction_Detailed_Internal_mx_0flowx_0ofx_0dpx_0fric
          (dp0_0-dpx_0gravx_0b, rhox_0a, rhox_0b, mux_0a, mux_0b, length0_0, 
          diameter0_0, crossArea0_0, Re10_0, Re20_0, Delta0_0, DYNStackData_).
          mx_0flow_0member;
      }
      else{
        {
          struct Modelica_Fluid_Pipes_BaseClasses_WallFriction_Detailed_Internal_mx_0flowx_0ofx_0dpx_0fric_struct
             dummy_mult_=Modelica_Fluid_Pipes_BaseClasses_WallFriction_Detailed_Internal_mx_0flowx_0ofx_0dpx_0fric
            (dpx_0a-dpx_0gravx_0a, rhox_0a, rhox_0b, mux_0a, mux_0b, length0_0, 
            diameter0_0, crossArea0_0, Re10_0, Re20_0, Delta0_0, DYNStackData_);
          mx_0flowx_0a = dummy_mult_.mx_0flow_0member;
          dmx_0flowx_0ddpx_0fricx_0a = dummy_mult_.dmx_0flowx_0ddpx_0fric_0member;
        }
        {
          struct Modelica_Fluid_Pipes_BaseClasses_WallFriction_Detailed_Internal_mx_0flowx_0ofx_0dpx_0fric_struct
             dummy_mult_=Modelica_Fluid_Pipes_BaseClasses_WallFriction_Detailed_Internal_mx_0flowx_0ofx_0dpx_0fric
            (dpx_0b-dpx_0gravx_0b, rhox_0a, rhox_0b, mux_0a, mux_0b, length0_0, 
            diameter0_0, crossArea0_0, Re10_0, Re20_0, Delta0_0, DYNStackData_);
          mx_0flowx_0b = dummy_mult_.mx_0flow_0member;
          dmx_0flowx_0ddpx_0fricx_0b = dummy_mult_.dmx_0flowx_0ddpx_0fric_0member;
        }
        {
          struct Modelica_Fluid_Utilities_regFun3_struct dummy_mult_=
            Modelica_Fluid_Utilities_regFun3(dpx_0zero, dpx_0b, dpx_0a, 
            mx_0flowx_0b, mx_0flowx_0a, dmx_0flowx_0ddpx_0fricx_0b, 
            dmx_0flowx_0ddpx_0fricx_0a, DYNStackData_);
          mx_0flow = dummy_mult_.y0_0_0member;
          dmx_0flowx_0ddpx_0fricx_0zero = dummy_mult_.c0_0_0member;
        }
        if (dp0_0 > dpx_0zero) {
          mx_0flow = Modelica_Fluid_Utilities_regFun3(dp0_0, dpx_0zero, dpx_0a, 
            mx_0flowx_0zero, mx_0flowx_0a, dmx_0flowx_0ddpx_0fricx_0zero, 
            dmx_0flowx_0ddpx_0fricx_0a, DYNStackData_).y0_0_0member;
        }
        else{
          mx_0flow = Modelica_Fluid_Utilities_regFun3(dp0_0, dpx_0b, dpx_0zero, 
            mx_0flowx_0b, mx_0flowx_0zero, dmx_0flowx_0ddpx_0fricx_0b, 
            dmx_0flowx_0ddpx_0fricx_0zero, DYNStackData_).y0_0_0member;
        }
      }
    /* Output section */
    DYNJPopContext(DYNStackData_)
    return mx_0flow;
  }}

/* Flattened Modelica model:

function massFlowRate_dp_staticHead_Unique18:der
discrete input Real dp;
discrete input Real rho_a;
discrete input Real rho_b;
discrete input Real mu_a;
discrete input Real mu_b;
discrete input Real length;
discrete input Real diameter;
discrete input Real g_times_height_ab;
discrete input Real crossArea(start = 0.7853981633974483*diameter^2);
discrete input Real roughness(start = 2.5E-05);
discrete input Real dp_small(start = 1);
discrete input Real Re_turbulent(start = 4000);
protected 
discrete Real m_flow;
discrete Real Delta(start = roughness/diameter);
discrete Real Re;
discrete Real Re1(start = min((745*exp((if Delta <= 0.0065 then 1 else 0.0065/Delta)))^0.97, Re_turbulent));
discrete Real Re2(start = Re_turbulent);
discrete Real dp_a;
discrete Real dp_b;
discrete Real m_flow_a;
discrete Real m_flow_b;
discrete Real dm_flow_ddp_fric_a;
discrete Real dm_flow_ddp_fric_b;
discrete Real dp_grav_a(start = g_times_height_ab*rho_a);
discrete Real dp_grav_b(start = g_times_height_ab*rho_b);
discrete Real m_flow_zero(start = 0);
discrete Real dp_zero(start = 0.5*(dp_grav_a+dp_grav_b));
discrete Real dm_flow_ddp_fric_zero;
public 
discrete input Real dp_der;
discrete input Real rho_a_der;
discrete input Real rho_b_der;
discrete input Real mu_a_der;
discrete input Real mu_b_der;
discrete input Real length_der;
discrete input Real diameter_der;
discrete input Real g_times_height_ab_der;
discrete input Real crossArea_der(start = 1.5707963267948966*(diameter*diameter_der));
discrete input Real roughness_der(start = 0.0);
discrete input Real dp_small_der(start = 0);
discrete input Real Re_turbulent_der(start = 0);
discrete output Real m_flow_der;
protected 
discrete Real Delta_der(start = roughness_der/diameter-roughness*diameter_der/diameter^2);
discrete Real Re1_der(start = (if noEvent((745*exp((if Delta <= 0.0065 then 1 else 0.0065/Delta)))^0.97 < Re_turbulent) then 722.65*((745*exp((if Delta <= 0.0065 then 1 else 0.0065/Delta)))^(-0.030000000000000027)*((if Delta <= 0.0065 then 0 else  -0.0065*Delta_der/Delta^2)*exp((if Delta <= 0.0065 then 1 else 0.0065/Delta)))) else Re_turbulent_der));
discrete Real Re2_der(start = Re_turbulent_der);
discrete Real dp_a_der;
discrete Real dp_b_der;
discrete Real m_flow_a_der;
discrete Real m_flow_b_der;
discrete Real dm_flow_ddp_fric_a_der;
discrete Real dm_flow_ddp_fric_b_der;
discrete Real dp_grav_a_der(start = g_times_height_ab_der*rho_a+g_times_height_ab*rho_a_der);
discrete Real dp_grav_b_der(start = g_times_height_ab_der*rho_b+g_times_height_ab*rho_b_der);
discrete Real dp_zero_der(start = 0.5*(dp_grav_a_der+dp_grav_b_der));
discrete Real dm_flow_ddp_fric_zero_der;
public 
algorithm 
dp_a_der := (if noEvent(dp_grav_a > dp_grav_b) then dp_grav_a_der else dp_grav_b_der)+dp_small_der;
dp_a := max(dp_grav_a, dp_grav_b)+dp_small;
dp_b_der := (if noEvent(dp_grav_a < dp_grav_b) then dp_grav_a_der else dp_grav_b_der)-dp_small_der;
dp_b := min(dp_grav_a, dp_grav_b)-dp_small;
if (dp >= dp_a) then 
m_flow_der := Modelica.Fluid.Pipes.BaseClasses.WallFriction.Detailed.Internal.m_flow_of_dp_fric:der(dp-dp_grav_a, rho_a, rho_b, mu_a, mu_b, length, diameter, crossArea, Re1, Re2, Delta, dp_der-dp_grav_a_der, rho_a_der, rho_b_der, mu_a_der, mu_b_der, length_der, diameter_der, crossArea_der, Re1_der, Re2_der, Delta_der);
elseif (dp <= dp_b) then 
m_flow_der := Modelica.Fluid.Pipes.BaseClasses.WallFriction.Detailed.Internal.m_flow_of_dp_fric:der(dp-dp_grav_b, rho_a, rho_b, mu_a, mu_b, length, diameter, crossArea, Re1, Re2, Delta, dp_der-dp_grav_b_der, rho_a_der, rho_b_der, mu_a_der, mu_b_der, length_der, diameter_der, crossArea_der, Re1_der, Re2_der, Delta_der);
else
(m_flow_a_der, dm_flow_ddp_fric_a_der)  := Modelica.Fluid.Pipes.BaseClasses.WallFriction.Detailed.Internal.m_flow_of_dp_fric:der(dp_a-dp_grav_a, rho_a, rho_b, mu_a, mu_b, length, diameter, crossArea, Re1, Re2, Delta, dp_a_der-dp_grav_a_der, rho_a_der, rho_b_der, mu_a_der, mu_b_der, length_der, diameter_der, crossArea_der, Re1_der, Re2_der, Delta_der);
(m_flow_a, dm_flow_ddp_fric_a)  := Modelica.Fluid.Pipes.BaseClasses.WallFriction.Detailed.Internal.m_flow_of_dp_fric(dp_a-dp_grav_a, rho_a, rho_b, mu_a, mu_b, length, diameter, crossArea, Re1, Re2, Delta);
(m_flow_b_der, dm_flow_ddp_fric_b_der)  := Modelica.Fluid.Pipes.BaseClasses.WallFriction.Detailed.Internal.m_flow_of_dp_fric:der(dp_b-dp_grav_b, rho_a, rho_b, mu_a, mu_b, length, diameter, crossArea, Re1, Re2, Delta, dp_b_der-dp_grav_b_der, rho_a_der, rho_b_der, mu_a_der, mu_b_der, length_der, diameter_der, crossArea_der, Re1_der, Re2_der, Delta_der);
(m_flow_b, dm_flow_ddp_fric_b)  := Modelica.Fluid.Pipes.BaseClasses.WallFriction.Detailed.Internal.m_flow_of_dp_fric(dp_b-dp_grav_b, rho_a, rho_b, mu_a, mu_b, length, diameter, crossArea, Re1, Re2, Delta);
(m_flow_der, dm_flow_ddp_fric_zero_der)  := Modelica.Fluid.Utilities.regFun3:der(dp_zero, dp_b, dp_a, m_flow_b, m_flow_a, dm_flow_ddp_fric_b, dm_flow_ddp_fric_a, dp_zero_der, dp_b_der, dp_a_der, m_flow_b_der, m_flow_a_der, dm_flow_ddp_fric_b_der, dm_flow_ddp_fric_a_der);
(m_flow, dm_flow_ddp_fric_zero)  := Modelica.Fluid.Utilities.regFun3(dp_zero, dp_b, dp_a, m_flow_b, m_flow_a, dm_flow_ddp_fric_b, dm_flow_ddp_fric_a);
if (dp > dp_zero) then 
m_flow_der := Modelica.Fluid.Utilities.regFun3:der(dp, dp_zero, dp_a, 0.0, m_flow_a, dm_flow_ddp_fric_zero, dm_flow_ddp_fric_a, dp_der, dp_zero_der, dp_a_der, 0.0, m_flow_a_der, dm_flow_ddp_fric_zero_der, dm_flow_ddp_fric_a_der);
else
m_flow_der := Modelica.Fluid.Utilities.regFun3:der(dp, dp_b, dp_zero, m_flow_b, 0.0, dm_flow_ddp_fric_b, dm_flow_ddp_fric_zero, dp_der, dp_b_der, dp_zero_der, m_flow_b_der, 0.0, dm_flow_ddp_fric_b_der, dm_flow_ddp_fric_zero_der);
end if;
end if;
annotation(smoothOrder=0);
end massFlowRate_dp_staticHead_Unique18:der;

  */
DYMOLA_STATIC double   massFlowRatex_0dpx_0staticHeadx_0Unique18__der(double  
  dp0_0, double  rhox_0a, double  rhox_0b, double  mux_0a, double  mux_0b, 
  double  length0_0, double  diameter0_0, double  gx_0timesx_0heightx_0ab, 
  double  crossArea0_0, double  roughness0_0, double  dpx_0small, double  
  Rex_0turbulent, double  dpx_0der, double  rhox_0ax_0der, double  rhox_0bx_0der,
   double  mux_0ax_0der, double  mux_0bx_0der, double  lengthx_0der, double  
  diameterx_0der, double  gx_0timesx_0heightx_0abx_0der, double  crossAreax_0der,
   double  roughnessx_0der, double  dpx_0smallx_0der, double  Rex_0turbulentx_0der,
   struct DYNFunctionData_* DYNStackData_) {
  DYNJPushContext("massFlowRate_dp_staticHead_Unique18:der", DYNStackData_)
  {
    /* Declare outputs and temporaries */
    double   mx_0flow;
    double   Delta0_0;
    double   Re0_0;
    double   Re10_0;
    double   Re20_0;
    double   dpx_0a;
    double   dpx_0b;
    double   mx_0flowx_0a;
    double   mx_0flowx_0b;
    double   dmx_0flowx_0ddpx_0fricx_0a;
    double   dmx_0flowx_0ddpx_0fricx_0b;
    double   dpx_0gravx_0a;
    double   dpx_0gravx_0b;
    double   mx_0flowx_0zero;
    double   dpx_0zero;
    double   dmx_0flowx_0ddpx_0fricx_0zero;
    double   mx_0flowx_0der;
    double   Deltax_0der;
    double   Re1x_0der;
    double   Re2x_0der;
    double   dpx_0ax_0der;
    double   dpx_0bx_0der;
    double   mx_0flowx_0ax_0der;
    double   mx_0flowx_0bx_0der;
    double   dmx_0flowx_0ddpx_0fricx_0ax_0der;
    double   dmx_0flowx_0ddpx_0fricx_0bx_0der;
    double   dpx_0gravx_0ax_0der;
    double   dpx_0gravx_0bx_0der;
    double   dpx_0zerox_0der;
    double   dmx_0flowx_0ddpx_0fricx_0zerox_0der;
    mx_0flow=0;
    Delta0_0 = divGuarded(roughness0_0,"roughness",diameter0_0,"diameter");
    Re0_0=0;
    Re10_0 = RealBmin(powGuarded(745*exp(IF Delta0_0 <= 0.0065 THEN 1 ELSE 
      divGuarded(0.0065,"0.0065",Delta0_0,"Delta")),"745*exp((if Delta <= 0.0065 then 1 else 0.0065/Delta))",
      0.97,"0.97"), Rex_0turbulent);
    Re20_0 = Rex_0turbulent;
    dpx_0a=0;
    dpx_0b=0;
    mx_0flowx_0a=0;
    mx_0flowx_0b=0;
    dmx_0flowx_0ddpx_0fricx_0a=0;
    dmx_0flowx_0ddpx_0fricx_0b=0;
    dpx_0gravx_0a = gx_0timesx_0heightx_0ab*rhox_0a;
    dpx_0gravx_0b = gx_0timesx_0heightx_0ab*rhox_0b;
    mx_0flowx_0zero = 0;
    dpx_0zero = 0.5*(dpx_0gravx_0a+dpx_0gravx_0b);
    dmx_0flowx_0ddpx_0fricx_0zero=0;
    mx_0flowx_0der=0;
    Deltax_0der = divGuarded(roughnessx_0der,"roughness_der",diameter0_0,
      "diameter")-divGuarded(roughness0_0*diameterx_0der,"roughness*diameter_der",
      sqr(diameter0_0),"diameter^2");
    Re1x_0der = IF powGuarded(745*exp(IF Delta0_0 <= 0.0065 THEN 1 ELSE 
      divGuarded(0.0065,"0.0065",Delta0_0,"Delta")),"745*exp((if Delta <= 0.0065 then 1 else 0.0065/Delta))",
      0.97,"0.97") < Rex_0turbulent THEN 722.65*powGuarded(745*exp(IF Delta0_0
       <= 0.0065 THEN 1 ELSE divGuarded(0.0065,"0.0065",Delta0_0,"Delta")),
      "745*exp((if Delta <= 0.0065 then 1 else 0.0065/Delta))",-0.030000000000000027,
      "-0.030000000000000027")*(IF Delta0_0 <= 0.0065 THEN 0 ELSE  -divGuarded(
      0.0065*Deltax_0der,"0.0065*Delta_der",sqr(Delta0_0),"Delta^2"))*exp(IF 
      Delta0_0 <= 0.0065 THEN 1 ELSE divGuarded(0.0065,"0.0065",Delta0_0,"Delta"))
       ELSE Rex_0turbulentx_0der;
    Re2x_0der = Rex_0turbulentx_0der;
    dpx_0ax_0der=0;
    dpx_0bx_0der=0;
    mx_0flowx_0ax_0der=0;
    mx_0flowx_0bx_0der=0;
    dmx_0flowx_0ddpx_0fricx_0ax_0der=0;
    dmx_0flowx_0ddpx_0fricx_0bx_0der=0;
    dpx_0gravx_0ax_0der = gx_0timesx_0heightx_0abx_0der*rhox_0a+gx_0timesx_0heightx_0ab
      *rhox_0ax_0der;
    dpx_0gravx_0bx_0der = gx_0timesx_0heightx_0abx_0der*rhox_0b+gx_0timesx_0heightx_0ab
      *rhox_0bx_0der;
    dpx_0zerox_0der = 0.5*(dpx_0gravx_0ax_0der+dpx_0gravx_0bx_0der);
    dmx_0flowx_0ddpx_0fricx_0zerox_0der=0;
    /* Start of real code */
      dpx_0ax_0der = (IF dpx_0gravx_0a > dpx_0gravx_0b THEN dpx_0gravx_0ax_0der
         ELSE dpx_0gravx_0bx_0der)+dpx_0smallx_0der;
      dpx_0a = RealBmax(dpx_0gravx_0a, dpx_0gravx_0b)+dpx_0small;
      dpx_0bx_0der = (IF dpx_0gravx_0a < dpx_0gravx_0b THEN dpx_0gravx_0ax_0der
         ELSE dpx_0gravx_0bx_0der)-dpx_0smallx_0der;
      dpx_0b = RealBmin(dpx_0gravx_0a, dpx_0gravx_0b)-dpx_0small;
      if (dp0_0 >= dpx_0a) {
        mx_0flowx_0der = Modelica_Fluid_Pipes_BaseClasses_WallFriction_Detailed_Internal_mx_0flowx_0ofx_0dpx_0fric__der
          (dp0_0-dpx_0gravx_0a, rhox_0a, rhox_0b, mux_0a, mux_0b, length0_0, 
          diameter0_0, crossArea0_0, Re10_0, Re20_0, Delta0_0, dpx_0der-
          dpx_0gravx_0ax_0der, rhox_0ax_0der, rhox_0bx_0der, mux_0ax_0der, 
          mux_0bx_0der, lengthx_0der, diameterx_0der, crossAreax_0der, Re1x_0der,
           Re2x_0der, Deltax_0der, DYNStackData_).mx_0flowx_0der_0member;
      }
      else if (dp0_0 <= dpx_0b) {
        mx_0flowx_0der = Modelica_Fluid_Pipes_BaseClasses_WallFriction_Detailed_Internal_mx_0flowx_0ofx_0dpx_0fric__der
          (dp0_0-dpx_0gravx_0b, rhox_0a, rhox_0b, mux_0a, mux_0b, length0_0, 
          diameter0_0, crossArea0_0, Re10_0, Re20_0, Delta0_0, dpx_0der-
          dpx_0gravx_0bx_0der, rhox_0ax_0der, rhox_0bx_0der, mux_0ax_0der, 
          mux_0bx_0der, lengthx_0der, diameterx_0der, crossAreax_0der, Re1x_0der,
           Re2x_0der, Deltax_0der, DYNStackData_).mx_0flowx_0der_0member;
      }
      else{
        {
          struct Modelica_Fluid_Pipes_BaseClasses_WallFriction_Detailed_Internal_mx_0flowx_0ofx_0dpx_0fric__der_struct
             dummy_mult_=Modelica_Fluid_Pipes_BaseClasses_WallFriction_Detailed_Internal_mx_0flowx_0ofx_0dpx_0fric__der
            (dpx_0a-dpx_0gravx_0a, rhox_0a, rhox_0b, mux_0a, mux_0b, length0_0, 
            diameter0_0, crossArea0_0, Re10_0, Re20_0, Delta0_0, dpx_0ax_0der-
            dpx_0gravx_0ax_0der, rhox_0ax_0der, rhox_0bx_0der, mux_0ax_0der, 
            mux_0bx_0der, lengthx_0der, diameterx_0der, crossAreax_0der, 
            Re1x_0der, Re2x_0der, Deltax_0der, DYNStackData_);
          mx_0flowx_0ax_0der = dummy_mult_.mx_0flowx_0der_0member;
          dmx_0flowx_0ddpx_0fricx_0ax_0der = dummy_mult_.dmx_0flowx_0ddpx_0fricx_0der_0member;
        }
        {
          struct Modelica_Fluid_Pipes_BaseClasses_WallFriction_Detailed_Internal_mx_0flowx_0ofx_0dpx_0fric_struct
             dummy_mult_=Modelica_Fluid_Pipes_BaseClasses_WallFriction_Detailed_Internal_mx_0flowx_0ofx_0dpx_0fric
            (dpx_0a-dpx_0gravx_0a, rhox_0a, rhox_0b, mux_0a, mux_0b, length0_0, 
            diameter0_0, crossArea0_0, Re10_0, Re20_0, Delta0_0, DYNStackData_);
          mx_0flowx_0a = dummy_mult_.mx_0flow_0member;
          dmx_0flowx_0ddpx_0fricx_0a = dummy_mult_.dmx_0flowx_0ddpx_0fric_0member;
        }
        {
          struct Modelica_Fluid_Pipes_BaseClasses_WallFriction_Detailed_Internal_mx_0flowx_0ofx_0dpx_0fric__der_struct
             dummy_mult_=Modelica_Fluid_Pipes_BaseClasses_WallFriction_Detailed_Internal_mx_0flowx_0ofx_0dpx_0fric__der
            (dpx_0b-dpx_0gravx_0b, rhox_0a, rhox_0b, mux_0a, mux_0b, length0_0, 
            diameter0_0, crossArea0_0, Re10_0, Re20_0, Delta0_0, dpx_0bx_0der-
            dpx_0gravx_0bx_0der, rhox_0ax_0der, rhox_0bx_0der, mux_0ax_0der, 
            mux_0bx_0der, lengthx_0der, diameterx_0der, crossAreax_0der, 
            Re1x_0der, Re2x_0der, Deltax_0der, DYNStackData_);
          mx_0flowx_0bx_0der = dummy_mult_.mx_0flowx_0der_0member;
          dmx_0flowx_0ddpx_0fricx_0bx_0der = dummy_mult_.dmx_0flowx_0ddpx_0fricx_0der_0member;
        }
        {
          struct Modelica_Fluid_Pipes_BaseClasses_WallFriction_Detailed_Internal_mx_0flowx_0ofx_0dpx_0fric_struct
             dummy_mult_=Modelica_Fluid_Pipes_BaseClasses_WallFriction_Detailed_Internal_mx_0flowx_0ofx_0dpx_0fric
            (dpx_0b-dpx_0gravx_0b, rhox_0a, rhox_0b, mux_0a, mux_0b, length0_0, 
            diameter0_0, crossArea0_0, Re10_0, Re20_0, Delta0_0, DYNStackData_);
          mx_0flowx_0b = dummy_mult_.mx_0flow_0member;
          dmx_0flowx_0ddpx_0fricx_0b = dummy_mult_.dmx_0flowx_0ddpx_0fric_0member;
        }
        {
          struct Modelica_Fluid_Utilities_regFun3__der_struct dummy_mult_=
            Modelica_Fluid_Utilities_regFun3__der(dpx_0zero, dpx_0b, dpx_0a, 
            mx_0flowx_0b, mx_0flowx_0a, dmx_0flowx_0ddpx_0fricx_0b, 
            dmx_0flowx_0ddpx_0fricx_0a, dpx_0zerox_0der, dpx_0bx_0der, 
            dpx_0ax_0der, mx_0flowx_0bx_0der, mx_0flowx_0ax_0der, 
            dmx_0flowx_0ddpx_0fricx_0bx_0der, dmx_0flowx_0ddpx_0fricx_0ax_0der, 
            DYNStackData_);
          mx_0flowx_0der = dummy_mult_.yx_0der_0member;
          dmx_0flowx_0ddpx_0fricx_0zerox_0der = dummy_mult_.cx_0der_0member;
        }
        {
          struct Modelica_Fluid_Utilities_regFun3_struct dummy_mult_=
            Modelica_Fluid_Utilities_regFun3(dpx_0zero, dpx_0b, dpx_0a, 
            mx_0flowx_0b, mx_0flowx_0a, dmx_0flowx_0ddpx_0fricx_0b, 
            dmx_0flowx_0ddpx_0fricx_0a, DYNStackData_);
          mx_0flow = dummy_mult_.y0_0_0member;
          dmx_0flowx_0ddpx_0fricx_0zero = dummy_mult_.c0_0_0member;
        }
        if (dp0_0 > dpx_0zero) {
          mx_0flowx_0der = Modelica_Fluid_Utilities_regFun3__der(dp0_0, 
            dpx_0zero, dpx_0a, 0.0, mx_0flowx_0a, dmx_0flowx_0ddpx_0fricx_0zero,
             dmx_0flowx_0ddpx_0fricx_0a, dpx_0der, dpx_0zerox_0der, dpx_0ax_0der,
             0.0, mx_0flowx_0ax_0der, dmx_0flowx_0ddpx_0fricx_0zerox_0der, 
            dmx_0flowx_0ddpx_0fricx_0ax_0der, DYNStackData_).yx_0der_0member;
        }
        else{
          mx_0flowx_0der = Modelica_Fluid_Utilities_regFun3__der(dp0_0, dpx_0b, 
            dpx_0zero, mx_0flowx_0b, 0.0, dmx_0flowx_0ddpx_0fricx_0b, 
            dmx_0flowx_0ddpx_0fricx_0zero, dpx_0der, dpx_0bx_0der, 
            dpx_0zerox_0der, mx_0flowx_0bx_0der, 0.0, dmx_0flowx_0ddpx_0fricx_0bx_0der,
             dmx_0flowx_0ddpx_0fricx_0zerox_0der, DYNStackData_).yx_0der_0member;
        }
      }
    /* Output section */
    DYNJPopContext(DYNStackData_)
    return mx_0flowx_0der;
  }}

/* Flattened Modelica model:

function pressureLoss_m_flow_Unique14
discrete input Real m_flow(unit = "kg/s") "Mass flow rate from port_a to port_b";
discrete input Real rho_a(unit = "kg/m3", displayUnit = "g/cm3", min = 0.0) "Density at port_a";
discrete input Real rho_b(unit = "kg/m3", displayUnit = "g/cm3", min = 0.0) "Density at port_b";
discrete input Real mu_a(unit = "Pa.s", min = 0.0) "Dynamic viscosity at port_a (dummy if use_mu = false)";
discrete input Real mu_b(unit = "Pa.s", min = 0.0) "Dynamic viscosity at port_b (dummy if use_mu = false)";
discrete input Real length(unit = "m") "Length of pipe";
discrete input Real diameter(unit = "m", min = 0.0) "Inner (hydraulic) diameter of pipe";
discrete input Real crossArea(start = 0.7853981633974483*diameter^2, unit = "m2") "Inner cross section area";
discrete input Real roughness(start = 2.5E-05, unit = "m", displayUnit = "mm", min = 0.0) "Absolute roughness of pipe, with a default for a smooth steel pipe (dummy if use_roughness = false)";
discrete input Real m_flow_small(start = 0.01, unit = "kg/s") "Regularization of zero flow if |m_flow| < m_flow_small (dummy if use_m_flow_small = false)";
discrete input Real Re_turbulent(start = 4000, unit = "1") "Turbulent flow if Re >= Re_turbulent (dummy if use_Re_turbulent = false)";
discrete output Real dp(unit = "Pa", displayUnit = "bar") "Pressure loss (dp = port_a.p - port_b.p)";
protected 
discrete Real Delta(start = roughness/diameter, min = 0.0) "Relative roughness";
discrete Real Re1(start = min(745*exp((if Delta <= 0.0065 then 1 else 0.0065/Delta)), Re_turbulent), unit = "1") "Re leaving laminar curve";
discrete Real Re2(start = Re_turbulent, unit = "1") "Re entering turbulent curve";
discrete Real mu(unit = "Pa.s", min = 0.0) "Upstream viscosity";
discrete Real rho(unit = "kg/m3", displayUnit = "g/cm3", min = 0.0) "Upstream density";
discrete Real Re(unit = "1") "Reynolds number";
discrete Real lambda2 "Modified friction coefficient (= lambda*Re^2)";
public 
algorithm 
rho := (if m_flow >= 0 then rho_a else rho_b);
mu := (if m_flow >= 0 then mu_a else mu_b);
Re := diameter*abs(m_flow)/(crossArea*mu);
lambda2 := (if Re <= Re1 then 64*Re else (if Re >= Re2 then 0.25*(Re/log10(Delta/3.7+5.74/Re^0.9))^2 else interpolateInRegion2_Unique15(Re, Re1, Re2, Delta)));
dp := length*mu*mu/(2*rho*diameter*diameter*diameter)*(if m_flow >= 0 then lambda2 else  -lambda2);
annotation(smoothOrder=1);
end pressureLoss_m_flow_Unique14;

  */
DYMOLA_STATIC double   pressureLossx_0mx_0flowx_0Unique14(double  mx_0flow, 
  double  rhox_0a, double  rhox_0b, double  mux_0a, double  mux_0b, double  
  length0_0, double  diameter0_0, double  crossArea0_0, double  roughness0_0, 
  double  mx_0flowx_0small, double  Rex_0turbulent, struct DYNFunctionData_* DYNStackData_)
   {
  DYNJPushContext("pressureLoss_m_flow_Unique14", DYNStackData_)
  {
    /* Declare outputs and temporaries */
    double   dp0_0;
    double   Delta0_0;
    double   Re10_0;
    double   Re20_0;
    double   mu0_0;
    double   rho0_0;
    double   Re0_0;
    double   lambda20_0;
    dp0_0=0;
    Delta0_0 = divGuarded(roughness0_0,"roughness",diameter0_0,"diameter");
    Re10_0 = RealBmin(745*exp(IF Delta0_0 <= 0.0065 THEN 1 ELSE divGuarded(
      0.0065,"0.0065",Delta0_0,"Delta")), Rex_0turbulent);
    Re20_0 = Rex_0turbulent;
    mu0_0=0;
    rho0_0=0;
    Re0_0=0;
    lambda20_0=0;
    /* Start of real code */
      rho0_0 = IF mx_0flow >= 0 THEN rhox_0a ELSE rhox_0b;
      mu0_0 = IF mx_0flow >= 0 THEN mux_0a ELSE mux_0b;
      Re0_0 = divGuarded(diameter0_0*fabs(mx_0flow),"diameter*abs(m_flow)",
        crossArea0_0*mu0_0,"crossArea*mu");
      lambda20_0 = IF Re0_0 <= Re10_0 THEN 64*Re0_0 ELSE IF Re0_0 >= Re20_0
         THEN 0.25*sqr(divGuarded(Re0_0,"Re",log10Guarded(Delta0_0/(double)(3.7)
        +divGuarded(5.74,"5.74",powGuarded(Re0_0,"Re",0.9,"0.9"),"Re^0.9"),
        "Delta/3.7+5.74/Re^0.9"),"log10(Delta/3.7+5.74/Re^0.9)")) ELSE 
        interpolateInRegion2x_0Unique15(Re0_0, Re10_0, Re20_0, Delta0_0, 
        DYNStackData_);
      dp0_0 = divGuarded(length0_0*mu0_0*mu0_0,"length*mu*mu",2*rho0_0*
        diameter0_0*diameter0_0*diameter0_0,"2*rho*diameter*diameter*diameter")*
        (IF mx_0flow >= 0 THEN lambda20_0 ELSE  -lambda20_0);
    /* Output section */
    DYNJPopContext(DYNStackData_)
    return dp0_0;
  }}

/* Flattened Modelica model:

function Modelica.Fluid.Pipes.BaseClasses.WallFriction.Detailed.Internal.m_flow_of_dp_fric
discrete input Real dp_fric(unit = "Pa", displayUnit = "bar") "Pressure loss due to friction (dp = port_a.p - port_b.p)";
discrete input Real rho_a(unit = "kg/m3", displayUnit = "g/cm3", min = 0.0) "Density at port_a";
discrete input Real rho_b(unit = "kg/m3", displayUnit = "g/cm3", min = 0.0) "Density at port_b";
discrete input Real mu_a(unit = "Pa.s", min = 0.0) "Dynamic viscosity at port_a (dummy if use_mu = false)";
discrete input Real mu_b(unit = "Pa.s", min = 0.0) "Dynamic viscosity at port_b (dummy if use_mu = false)";
discrete input Real length(unit = "m") "Length of pipe";
discrete input Real diameter(unit = "m", min = 0.0) "Inner (hydraulic) diameter of pipe";
discrete input Real crossArea(unit = "m2") "Inner cross section area";
discrete input Real Re1(unit = "1") "Boundary between laminar regime and transition";
discrete input Real Re2(unit = "1") "Boundary between transition and turbulent regime";
discrete input Real Delta(min = 0.0) "Relative roughness";
discrete output Real m_flow(unit = "kg/s") "Mass flow rate from port_a to port_b";
discrete output Real dm_flow_ddp_fric "Derivative of mass flow rate with dp_fric";
protected 
discrete Real mu(unit = "Pa.s", min = 0.0) "Upstream viscosity";
discrete Real rho(unit = "kg/m3", displayUnit = "g/cm3", min = 0.0) "Upstream density";
discrete Real lambda2 "Modified friction coefficient (= lambda*Re^2)";
discrete Real Re(unit = "1") "Reynolds number";
discrete Real dRe_ddp "dRe/ddp";
discrete Real aux1;
discrete Real aux2;
public 
algorithm 
if (dp_fric >= 0) then 
rho := rho_a;
mu := mu_a;
else
rho := rho_b;
mu := mu_b;
end if;
lambda2 := abs(dp_fric)*2*diameter^3*rho/(length*mu*mu);
aux1 := 2*diameter^3*rho/(length*mu^2);
Re := lambda2/64;
dRe_ddp := aux1/64;
if (Re > Re1) then 
Re :=  -2*sqrt(lambda2)*log10(2.51/sqrt(lambda2)+0.27*Delta);
aux2 := sqrt(aux1*abs(dp_fric));
dRe_ddp := 0.43429448190325176*(( -2*log(2.51/aux2+0.27*Delta)*aux1/(2*aux2))+5.02/(2*abs(dp_fric)*(2.51/aux2+0.27*Delta)));
if (Re < Re2) then 
(Re, dRe_ddp)  := Modelica.Fluid.Pipes.BaseClasses.WallFriction.Detailed.Internal.m_flow_of_dp_fric.interpolateInRegion2_withDerivative(lambda2, Re1, Re2, Delta, dp_fric);
end if;
end if;
m_flow := crossArea/diameter*mu*(if dp_fric >= 0 then Re else  -Re);
dm_flow_ddp_fric := crossArea/diameter*mu*dRe_ddp;
annotation(derivative=Modelica.Fluid.Pipes.BaseClasses.WallFriction.Detailed.Internal.m_flow_of_dp_fric:der, smoothOrder=1);
end Modelica.Fluid.Pipes.BaseClasses.WallFriction.Detailed.Internal.m_flow_of_dp_fric;

  */
DYMOLA_STATIC struct Modelica_Fluid_Pipes_BaseClasses_WallFriction_Detailed_Internal_mx_0flowx_0ofx_0dpx_0fric_struct
   Modelica_Fluid_Pipes_BaseClasses_WallFriction_Detailed_Internal_mx_0flowx_0ofx_0dpx_0fric
  (double  dpx_0fric, double  rhox_0a, double  rhox_0b, double  mux_0a, double  
  mux_0b, double  length0_0, double  diameter0_0, double  crossArea0_0, double  
  Re10_0, double  Re20_0, double  Delta0_0, struct DYNFunctionData_* DYNStackData_)
   {
  DYNJPushContext("Modelica.Fluid.Pipes.BaseClasses.WallFriction.Detailed.Internal.m_flow_of_dp_fric",
     DYNStackData_)
  {
    /* Declare outputs and temporaries */
    double   mx_0flow;
    double   dmx_0flowx_0ddpx_0fric;
    double   mu0_0;
    double   rho0_0;
    double   lambda20_0;
    double   Re0_0;
    double   dRex_0ddp;
    double   aux10_0;
    double   aux20_0;
    mx_0flow=0;
    dmx_0flowx_0ddpx_0fric=0;
    mu0_0=0;
    rho0_0=0;
    lambda20_0=0;
    Re0_0=0;
    dRex_0ddp=0;
    aux10_0=0;
    aux20_0=0;
    /* Start of real code */
      if (dpx_0fric >= 0) {
        rho0_0 = rhox_0a;
        mu0_0 = mux_0a;
      }
      else{
        rho0_0 = rhox_0b;
        mu0_0 = mux_0b;
      }
      lambda20_0 = divGuarded(fabs(dpx_0fric)*2*powUnguarded(diameter0_0, 3)*
        rho0_0,"abs(dp_fric)*2*diameter^3*rho",length0_0*mu0_0*mu0_0,
        "length*mu*mu");
      aux10_0 = divGuarded(2*powUnguarded(diameter0_0, 3)*rho0_0,
        "2*diameter^3*rho",length0_0*sqr(mu0_0),"length*mu^2");
      Re0_0 = lambda20_0/(double)(64);
      dRex_0ddp = aux10_0/(double)(64);
      if (Re0_0 > Re10_0) {
        Re0_0 =  -2*sqrtGuarded(lambda20_0,"lambda2")*log10Guarded(divGuarded(
          2.51,"2.51",sqrtGuarded(lambda20_0,"lambda2"),"sqrt(lambda2)")+0.27*
          Delta0_0,"2.51/sqrt(lambda2)+0.27*Delta");
        aux20_0 = sqrtGuarded(aux10_0*fabs(dpx_0fric),"aux1*abs(dp_fric)");
        dRex_0ddp = 0.43429448190325176*(( -divGuarded(2*logGuarded(divGuarded(
          2.51,"2.51",aux20_0,"aux2")+0.27*Delta0_0,"2.51/aux2+0.27*Delta")*
          aux10_0,"2*log(2.51/aux2+0.27*Delta)*aux1",2*aux20_0,"2*aux2"))+
          divGuarded(5.02,"5.02",2*fabs(dpx_0fric)*(divGuarded(2.51,"2.51",
          aux20_0,"aux2")+0.27*Delta0_0),"2*abs(dp_fric)*(2.51/aux2+0.27*Delta)"));
        if (Re0_0 < Re20_0) {
          {
            struct Modelica_Fluid_Pipes_BaseClasses_WallFriction_Detailed_Internal_mx_0flowx_0ofx_0dpx_0fric_interpolateInRegion2x_0withDerivative_struct
               dummy_mult_=Modelica_Fluid_Pipes_BaseClasses_WallFriction_Detailed_Internal_mx_0flowx_0ofx_0dpx_0fric_interpolateInRegion2x_0withDerivative
              (lambda20_0, Re10_0, Re20_0, Delta0_0, dpx_0fric, DYNStackData_);
            Re0_0 = dummy_mult_.Re0_0_0member;
            dRex_0ddp = dummy_mult_.dRex_0ddp_0member;
          }
        }
      }
      mx_0flow = divGuarded(crossArea0_0,"crossArea",diameter0_0,"diameter")*
        mu0_0*(IF dpx_0fric >= 0 THEN Re0_0 ELSE  -Re0_0);
      dmx_0flowx_0ddpx_0fric = divGuarded(crossArea0_0,"crossArea",diameter0_0,
        "diameter")*mu0_0*dRex_0ddp;
    /* Output section */
    DYNJPopContext(DYNStackData_)
    {
      struct Modelica_Fluid_Pipes_BaseClasses_WallFriction_Detailed_Internal_mx_0flowx_0ofx_0dpx_0fric_struct out_;
      out_.mx_0flow_0member = mx_0flow;
      out_.dmx_0flowx_0ddpx_0fric_0member = dmx_0flowx_0ddpx_0fric;
      return out_;
    }
  }}

/* Flattened Modelica model:

function Modelica.Fluid.Pipes.BaseClasses.WallFriction.Detailed.Internal.m_flow_of_dp_fric.interpolateInRegion2_withDerivative
discrete input Real lambda2 "Known independent variable";
discrete input Real Re1(unit = "1") "Boundary between laminar regime and transition";
discrete input Real Re2(unit = "1") "Boundary between transition and turbulent regime";
discrete input Real Delta(min = 0.0) "Relative roughness";
discrete input Real dp_fric(unit = "Pa", displayUnit = "bar") "Pressure loss due to friction (dp = port_a.p - port_b.p)";
discrete output Real Re(unit = "1") "Unknown return variable";
discrete output Real dRe_ddp "Derivative of return value";
protected 
discrete Real x1(start = log10(64*Re1));
discrete Real y1(start = log10(Re1));
discrete Real y1d(start = 1);
discrete Real aux2(start = Delta/3.7+5.74/Re2^0.9);
discrete Real aux3(start = log10(aux2));
discrete Real L2(start = 0.25*(Re2/aux3)^2);
discrete Real aux4(start = 2.51/sqrt(L2)+0.27*Delta);
discrete Real aux5(start = (-2.0)*(sqrt(L2)*log10(aux4)));
discrete Real x2(start = log10(L2));
discrete Real y2(start = log10(aux5));
discrete Real y2d(start = 0.5+1.0900791495771618/(aux5*aux4));
discrete Real x(start = log10(lambda2));
discrete Real y;
discrete Real dy_dx "Derivative in transformed space";
public 
algorithm 
(y, dy_dx)  := Modelica.Fluid.Utilities.cubicHermite_withDerivative(x, x1, x2, y1, y2, y1d, y2d);
Re := 10^y;
dRe_ddp := Re/abs(dp_fric)*dy_dx;
annotation(derivative=Modelica.Fluid.Pipes.BaseClasses.WallFriction.Detailed.Internal.m_flow_of_dp_fric.interpolateInRegion2_withDerivative:der, smoothOrder=1);
end Modelica.Fluid.Pipes.BaseClasses.WallFriction.Detailed.Internal.m_flow_of_dp_fric.interpolateInRegion2_withDerivative;

  */
DYMOLA_STATIC struct Modelica_Fluid_Pipes_BaseClasses_WallFriction_Detailed_Internal_mx_0flowx_0ofx_0dpx_0fric_interpolateInRegion2x_0withDerivative_struct
   Modelica_Fluid_Pipes_BaseClasses_WallFriction_Detailed_Internal_mx_0flowx_0ofx_0dpx_0fric_interpolateInRegion2x_0withDerivative
  (double  lambda20_0, double  Re10_0, double  Re20_0, double  Delta0_0, double 
   dpx_0fric, struct DYNFunctionData_* DYNStackData_) {
  DYNJPushContext("Modelica.Fluid.Pipes.BaseClasses.WallFriction.Detailed.Internal.m_flow_of_dp_fric.interpolateInRegion2_withDerivative",
     DYNStackData_)
  {
    /* Declare outputs and temporaries */
    double   Re0_0;
    double   dRex_0ddp;
    double   x10_0;
    double   y10_0;
    double   y1d0_0;
    double   aux20_0;
    double   aux30_0;
    double   L20_0;
    double   aux40_0;
    double   aux50_0;
    double   x20_0;
    double   y20_0;
    double   y2d0_0;
    double   x0_0;
    double   y0_0;
    double   dyx_0dx;
    Re0_0=0;
    dRex_0ddp=0;
    x10_0 = log10Guarded(64*Re10_0,"64*Re1");
    y10_0 = log10Guarded(Re10_0,"Re1");
    y1d0_0 = 1;
    aux20_0 = Delta0_0/(double)(3.7)+divGuarded(5.74,"5.74",powGuarded(Re20_0,
      "Re2",0.9,"0.9"),"Re2^0.9");
    aux30_0 = log10Guarded(aux20_0,"aux2");
    L20_0 = 0.25*sqr(divGuarded(Re20_0,"Re2",aux30_0,"aux3"));
    aux40_0 = divGuarded(2.51,"2.51",sqrtGuarded(L20_0,"L2"),"sqrt(L2)")+0.27*
      Delta0_0;
    aux50_0 = (-2.0)*sqrtGuarded(L20_0,"L2")*log10Guarded(aux40_0,"aux4");
    x20_0 = log10Guarded(L20_0,"L2");
    y20_0 = log10Guarded(aux50_0,"aux5");
    y2d0_0 = 0.5+divGuarded(1.0900791495771618,"1.0900791495771618",aux50_0*
      aux40_0,"aux5*aux4");
    x0_0 = log10Guarded(lambda20_0,"lambda2");
    y0_0=0;
    dyx_0dx=0;
    /* Start of real code */
      {
        struct Modelica_Fluid_Utilities_cubicHermitex_0withDerivative_struct
           dummy_mult_=Modelica_Fluid_Utilities_cubicHermitex_0withDerivative(
          x0_0, x10_0, x20_0, y10_0, y20_0, y1d0_0, y2d0_0, DYNStackData_);
        y0_0 = dummy_mult_.y0_0_0member;
        dyx_0dx = dummy_mult_.dyx_0dx_0member;
      }
      Re0_0 = powGuarded(10,"10",y0_0,"y");
      dRex_0ddp = divGuarded(Re0_0,"Re",fabs(dpx_0fric),"abs(dp_fric)")*dyx_0dx;
    /* Output section */
    DYNJPopContext(DYNStackData_)
    {
      struct Modelica_Fluid_Pipes_BaseClasses_WallFriction_Detailed_Internal_mx_0flowx_0ofx_0dpx_0fric_interpolateInRegion2x_0withDerivative_struct out_;
      out_.Re0_0_0member = Re0_0;
      out_.dRex_0ddp_0member = dRex_0ddp;
      return out_;
    }
  }}

/* Flattened Modelica model:

function Modelica.Fluid.Pipes.BaseClasses.WallFriction.Detailed.Internal.m_flow_of_dp_fric:der
discrete input Real dp_fric;
discrete input Real rho_a;
discrete input Real rho_b;
discrete input Real mu_a;
discrete input Real mu_b;
discrete input Real length;
discrete input Real diameter;
discrete input Real crossArea;
discrete input Real Re1;
discrete input Real Re2;
discrete input Real Delta;
protected 
discrete Real m_flow;
discrete Real dm_flow_ddp_fric;
discrete Real mu;
discrete Real rho;
discrete Real lambda2;
discrete Real Re;
discrete Real dRe_ddp;
discrete Real aux1;
discrete Real aux2;
public 
discrete input Real dp_fric_der;
discrete input Real rho_a_der;
discrete input Real rho_b_der;
discrete input Real mu_a_der;
discrete input Real mu_b_der;
discrete input Real length_der;
discrete input Real diameter_der;
discrete input Real crossArea_der;
discrete input Real Re1_der;
discrete input Real Re2_der;
discrete input Real Delta_der;
discrete output Real m_flow_der;
discrete output Real dm_flow_ddp_fric_der;
protected 
discrete Real mu_der;
discrete Real rho_der;
discrete Real lambda2_der;
discrete Real Re_der;
discrete Real dRe_ddp_der;
discrete Real aux1_der;
discrete Real aux2_der;
public 
algorithm 
if (dp_fric >= 0) then 
rho_der := rho_a_der;
rho := rho_a;
mu_der := mu_a_der;
mu := mu_a;
else
rho_der := rho_b_der;
rho := rho_b;
mu_der := mu_b_der;
mu := mu_b;
end if;
lambda2_der := 2.0*((dp_fric_der*noEvent((if dp_fric > 0 then 1 else -1))*diameter^3+3.0*(abs(dp_fric)*(diameter^2*diameter_der)))*rho+abs(dp_fric)*diameter^3*rho_der)/(length*mu*mu)-2.0*(abs(dp_fric)*diameter^3*rho*((length_der*mu+length*mu_der)*mu+length*mu*mu_der))/(length*mu*mu)^2;
lambda2 := 2.0*(abs(dp_fric)*diameter^3*rho)/(length*mu*mu);
aux1_der := 2.0*(3.0*(diameter^2*diameter_der*rho)+diameter^3*rho_der)/(length*mu^2)-2.0*(diameter^3*rho*(length_der*mu^2+2.0*(length*(mu*mu_der))))/(length*mu^2)^2;
aux1 := 2.0*(diameter^3*rho)/(length*mu^2);
Re_der := 0.015625*lambda2_der;
Re := 0.015625*lambda2;
dRe_ddp_der := 0.015625*aux1_der;
dRe_ddp := 0.015625*aux1;
if (Re > Re1) then 
Re_der := (-2.0)*(0.5*(lambda2_der*log10(2.51/sqrt(lambda2)+0.27*Delta))/sqrt(lambda2)+sqrt(lambda2)*(0.27*Delta_der-1.255*lambda2_der/sqrt(lambda2)/sqrt(lambda2)^2)/(2.302585092994046*(2.51/sqrt(lambda2)+0.27*Delta)));
Re := (-2.0)*(sqrt(lambda2)*log10(2.51/sqrt(lambda2)+0.27*Delta));
aux2_der := 0.5*(aux1_der*abs(dp_fric)+aux1*(dp_fric_der*noEvent((if dp_fric > 0 then 1 else -1))))/sqrt(aux1*abs(dp_fric));
aux2 := sqrt(aux1*abs(dp_fric));
dRe_ddp_der := (-0.43429448190325176)*(10.04*(dp_fric_der*noEvent((if dp_fric > 0 then 1 else -1))*(2.51/aux2+0.27*Delta)+abs(dp_fric)*(0.27*Delta_der-2.51*aux2_der/aux2^2))/(2.0*(abs(dp_fric)*(2.51/aux2+0.27*Delta)))^2+2.0*((0.27*Delta_der-2.51*aux2_der/aux2^2)*aux1/(2.51/aux2+0.27*Delta)+log(2.51/aux2+0.27*Delta)*aux1_der)/(2*aux2)-4.0*(log(2.51/aux2+0.27*Delta)*aux1*aux2_der)/(2*aux2)^2);
dRe_ddp := 0.43429448190325176*(5.02/(2.0*(abs(dp_fric)*(2.51/aux2+0.27*Delta)))-2.0*(log(2.51/aux2+0.27*Delta)*aux1)/(2*aux2));
if (Re < Re2) then 
(Re_der, dRe_ddp_der)  := Modelica.Fluid.Pipes.BaseClasses.WallFriction.Detailed.Internal.m_flow_of_dp_fric.interpolateInRegion2_withDerivative:der(lambda2, Re1, Re2, Delta, dp_fric, lambda2_der, Re1_der, Re2_der, Delta_der, dp_fric_der);
(Re, dRe_ddp)  := Modelica.Fluid.Pipes.BaseClasses.WallFriction.Detailed.Internal.m_flow_of_dp_fric.interpolateInRegion2_withDerivative(lambda2, Re1, Re2, Delta, dp_fric);
end if;
end if;
m_flow_der := ((crossArea_der*mu+crossArea*mu_der)*(if dp_fric >= 0 then Re else  -Re)+crossArea*mu*(if dp_fric >= 0 then Re_der else  -Re_der))/diameter-crossArea*mu*(if dp_fric >= 0 then Re else  -Re)*diameter_der/diameter^2;
m_flow := crossArea*mu*(if dp_fric >= 0 then Re else  -Re)/diameter;
dm_flow_ddp_fric_der := ((crossArea_der*mu+crossArea*mu_der)*dRe_ddp+crossArea*mu*dRe_ddp_der)/diameter-crossArea*mu*dRe_ddp*diameter_der/diameter^2;
annotation(smoothOrder=0);
end Modelica.Fluid.Pipes.BaseClasses.WallFriction.Detailed.Internal.m_flow_of_dp_fric:der;

  */
DYMOLA_STATIC struct Modelica_Fluid_Pipes_BaseClasses_WallFriction_Detailed_Internal_mx_0flowx_0ofx_0dpx_0fric__der_struct
   Modelica_Fluid_Pipes_BaseClasses_WallFriction_Detailed_Internal_mx_0flowx_0ofx_0dpx_0fric__der
  (double  dpx_0fric, double  rhox_0a, double  rhox_0b, double  mux_0a, double  
  mux_0b, double  length0_0, double  diameter0_0, double  crossArea0_0, double  
  Re10_0, double  Re20_0, double  Delta0_0, double  dpx_0fricx_0der, double  
  rhox_0ax_0der, double  rhox_0bx_0der, double  mux_0ax_0der, double  
  mux_0bx_0der, double  lengthx_0der, double  diameterx_0der, double  
  crossAreax_0der, double  Re1x_0der, double  Re2x_0der, double  Deltax_0der, 
  struct DYNFunctionData_* DYNStackData_) {
  DYNJPushContext("Modelica.Fluid.Pipes.BaseClasses.WallFriction.Detailed.Internal.m_flow_of_dp_fric:der",
     DYNStackData_)
  {
    /* Declare outputs and temporaries */
    double   mx_0flow;
    double   dmx_0flowx_0ddpx_0fric;
    double   mu0_0;
    double   rho0_0;
    double   lambda20_0;
    double   Re0_0;
    double   dRex_0ddp;
    double   aux10_0;
    double   aux20_0;
    double   mx_0flowx_0der;
    double   dmx_0flowx_0ddpx_0fricx_0der;
    double   mux_0der;
    double   rhox_0der;
    double   lambda2x_0der;
    double   Rex_0der;
    double   dRex_0ddpx_0der;
    double   aux1x_0der;
    double   aux2x_0der;
    mx_0flow=0;
    dmx_0flowx_0ddpx_0fric=0;
    mu0_0=0;
    rho0_0=0;
    lambda20_0=0;
    Re0_0=0;
    dRex_0ddp=0;
    aux10_0=0;
    aux20_0=0;
    mx_0flowx_0der=0;
    dmx_0flowx_0ddpx_0fricx_0der=0;
    mux_0der=0;
    rhox_0der=0;
    lambda2x_0der=0;
    Rex_0der=0;
    dRex_0ddpx_0der=0;
    aux1x_0der=0;
    aux2x_0der=0;
    /* Start of real code */
      if (dpx_0fric >= 0) {
        rhox_0der = rhox_0ax_0der;
        rho0_0 = rhox_0a;
        mux_0der = mux_0ax_0der;
        mu0_0 = mux_0a;
      }
      else{
        rhox_0der = rhox_0bx_0der;
        rho0_0 = rhox_0b;
        mux_0der = mux_0bx_0der;
        mu0_0 = mux_0b;
      }
      lambda2x_0der = divGuarded(2.0*((dpx_0fricx_0der*(IF dpx_0fric > 0 THEN 1
         ELSE -1)*powUnguarded(diameter0_0, 3)+3.0*fabs(dpx_0fric)*sqr(
        diameter0_0)*diameterx_0der)*rho0_0+fabs(dpx_0fric)*powUnguarded(
        diameter0_0, 3)*rhox_0der),"2.0*((dp_fric_der*noEvent((if dp_fric > 0 then 1 else -1))*diameter^3+3.0*(abs(dp_fric)*(diameter^2*diameter_der)))*rho+abs(dp_fric)*diameter^3*rho_der)",
        length0_0*mu0_0*mu0_0,"length*mu*mu")-divGuarded(2.0*fabs(dpx_0fric)*
        powUnguarded(diameter0_0, 3)*rho0_0*((lengthx_0der*mu0_0+length0_0*
        mux_0der)*mu0_0+length0_0*mu0_0*mux_0der),"2.0*(abs(dp_fric)*diameter^3*rho*((length_der*mu+length*mu_der)*mu+length*mu*mu_der))",
        sqr(length0_0*mu0_0*mu0_0),"(length*mu*mu)^2");
      lambda20_0 = divGuarded(2.0*fabs(dpx_0fric)*powUnguarded(diameter0_0, 3)*
        rho0_0,"2.0*(abs(dp_fric)*diameter^3*rho)",length0_0*mu0_0*mu0_0,
        "length*mu*mu");
      aux1x_0der = divGuarded(2.0*(3.0*sqr(diameter0_0)*diameterx_0der*rho0_0+
        powUnguarded(diameter0_0, 3)*rhox_0der),"2.0*(3.0*(diameter^2*diameter_der*rho)+diameter^3*rho_der)",
        length0_0*sqr(mu0_0),"length*mu^2")-divGuarded(2.0*powUnguarded(
        diameter0_0, 3)*rho0_0*(lengthx_0der*sqr(mu0_0)+2.0*length0_0*mu0_0*
        mux_0der),"2.0*(diameter^3*rho*(length_der*mu^2+2.0*(length*(mu*mu_der))))",
        sqr(length0_0*sqr(mu0_0)),"(length*mu^2)^2");
      aux10_0 = divGuarded(2.0*powUnguarded(diameter0_0, 3)*rho0_0,
        "2.0*(diameter^3*rho)",length0_0*sqr(mu0_0),"length*mu^2");
      Rex_0der = 0.015625*lambda2x_0der;
      Re0_0 = 0.015625*lambda20_0;
      dRex_0ddpx_0der = 0.015625*aux1x_0der;
      dRex_0ddp = 0.015625*aux10_0;
      if (Re0_0 > Re10_0) {
        Rex_0der = (-2.0)*(divGuarded(0.5*lambda2x_0der*log10Guarded(divGuarded(
          2.51,"2.51",sqrtGuarded(lambda20_0,"lambda2"),"sqrt(lambda2)")+0.27*
          Delta0_0,"2.51/sqrt(lambda2)+0.27*Delta"),"0.5*(lambda2_der*log10(2.51/sqrt(lambda2)+0.27*Delta))",
          sqrtGuarded(lambda20_0,"lambda2"),"sqrt(lambda2)")+divGuarded(
          sqrtGuarded(lambda20_0,"lambda2")*(0.27*Deltax_0der-divGuarded(
          divGuarded(1.255*lambda2x_0der,"1.255*lambda2_der",sqrtGuarded(
          lambda20_0,"lambda2"),"sqrt(lambda2)"),"1.255*lambda2_der/sqrt(lambda2)",
          sqr(sqrtGuarded(lambda20_0,"lambda2")),"sqrt(lambda2)^2")),
          "sqrt(lambda2)*(0.27*Delta_der-1.255*lambda2_der/sqrt(lambda2)/sqrt(lambda2)^2)",
          2.302585092994046*(divGuarded(2.51,"2.51",sqrtGuarded(lambda20_0,
          "lambda2"),"sqrt(lambda2)")+0.27*Delta0_0),"2.302585092994046*(2.51/sqrt(lambda2)+0.27*Delta)"));
        Re0_0 = (-2.0)*sqrtGuarded(lambda20_0,"lambda2")*log10Guarded(divGuarded
          (2.51,"2.51",sqrtGuarded(lambda20_0,"lambda2"),"sqrt(lambda2)")+0.27*
          Delta0_0,"2.51/sqrt(lambda2)+0.27*Delta");
        aux2x_0der = divGuarded(0.5*(aux1x_0der*fabs(dpx_0fric)+aux10_0*
          dpx_0fricx_0der*(IF dpx_0fric > 0 THEN 1 ELSE -1)),"0.5*(aux1_der*abs(dp_fric)+aux1*(dp_fric_der*noEvent((if dp_fric > 0 then 1 else -1))))",
          sqrtGuarded(aux10_0*fabs(dpx_0fric),"aux1*abs(dp_fric)"),
          "sqrt(aux1*abs(dp_fric))");
        aux20_0 = sqrtGuarded(aux10_0*fabs(dpx_0fric),"aux1*abs(dp_fric)");
        /* Introducing 13 common subexpressions used in 12 expressions */
        /* Of the common subexpressions 13 are reals, 0 are integers, and 0
           are booleans. */

        { double helpvarF[13];
        DYNX(helpvarF,0) = divGuarded(2.51,"2.51",aux20_0,"aux2")+0.27*Delta0_0;
        DYNX(helpvarF,1) = dpx_0fricx_0der*(IF dpx_0fric > 0 THEN 1 ELSE -1)*
          DYNX(helpvarF,0);
        DYNX(helpvarF,2) = fabs(dpx_0fric);
        DYNX(helpvarF,3) = sqr(aux20_0);
        DYNX(helpvarF,4) = 0.27*Deltax_0der-divGuarded(2.51*aux2x_0der,
          "2.51*aux2_der",DYNX(helpvarF,3),"aux2^2");
        DYNX(helpvarF,5) = DYNX(helpvarF,2)*DYNX(helpvarF,4);
        DYNX(helpvarF,6) = DYNX(helpvarF,2)*DYNX(helpvarF,0);
        DYNX(helpvarF,7) = sqr(2.0*DYNX(helpvarF,6));
        DYNX(helpvarF,8) = logGuarded(DYNX(helpvarF,0),"2.51/aux2+0.27*Delta");
        DYNX(helpvarF,9) = divGuarded(DYNX(helpvarF,4)*aux10_0,"(0.27*Delta_der-2.51*aux2_der/aux2^2)*aux1",
          DYNX(helpvarF,0),"2.51/aux2+0.27*Delta")+DYNX(helpvarF,8)*aux1x_0der;
        DYNX(helpvarF,10) = 2*aux20_0;
        DYNX(helpvarF,11) = DYNX(helpvarF,8)*aux10_0*aux2x_0der;
        DYNX(helpvarF,12) = sqr(DYNX(helpvarF,10));
        dRex_0ddpx_0der = (-0.43429448190325176)*(divGuarded(10.04*(
          DYNX(helpvarF,1)+DYNX(helpvarF,5)),"10.04*(dp_fric_der*noEvent((if dp_fric > 0 then 1 else -1))*(2.51/aux2+0.27*Delta)+abs(dp_fric)*(0.27*Delta_der-2.51*aux2_der/aux2^2))",
          DYNX(helpvarF,7),"(2.0*(abs(dp_fric)*(2.51/aux2+0.27*Delta)))^2")+
          divGuarded(2.0*DYNX(helpvarF,9),"2.0*((0.27*Delta_der-2.51*aux2_der/aux2^2)*aux1/(2.51/aux2+0.27*Delta)+log(2.51/aux2+0.27*Delta)*aux1_der)",
          DYNX(helpvarF,10),"2*aux2")-divGuarded(4.0*DYNX(helpvarF,11),
          "4.0*(log(2.51/aux2+0.27*Delta)*aux1*aux2_der)",DYNX(helpvarF,12),
          "(2*aux2)^2"));
        }
        dRex_0ddp = 0.43429448190325176*(divGuarded(5.02,"5.02",2.0*fabs(
          dpx_0fric)*(divGuarded(2.51,"2.51",aux20_0,"aux2")+0.27*Delta0_0),
          "2.0*(abs(dp_fric)*(2.51/aux2+0.27*Delta))")-divGuarded(2.0*logGuarded
          (divGuarded(2.51,"2.51",aux20_0,"aux2")+0.27*Delta0_0,"2.51/aux2+0.27*Delta")
          *aux10_0,"2.0*(log(2.51/aux2+0.27*Delta)*aux1)",2*aux20_0,"2*aux2"));
        if (Re0_0 < Re20_0) {
          {
            struct Modelica_Fluid_Pipes_BaseClasses_WallFriction_Detailed_Internal_mx_0flowx_0ofx_0dpx_0fric_interpolateInRegion2x_0withDerivative__der_struct
               dummy_mult_=Modelica_Fluid_Pipes_BaseClasses_WallFriction_Detailed_Internal_mx_0flowx_0ofx_0dpx_0fric_interpolateInRegion2x_0withDerivative__der
              (lambda20_0, Re10_0, Re20_0, Delta0_0, dpx_0fric, lambda2x_0der, 
              Re1x_0der, Re2x_0der, Deltax_0der, dpx_0fricx_0der, DYNStackData_);
            Rex_0der = dummy_mult_.Rex_0der_0member;
            dRex_0ddpx_0der = dummy_mult_.dRex_0ddpx_0der_0member;
          }
          {
            struct Modelica_Fluid_Pipes_BaseClasses_WallFriction_Detailed_Internal_mx_0flowx_0ofx_0dpx_0fric_interpolateInRegion2x_0withDerivative_struct
               dummy_mult_=Modelica_Fluid_Pipes_BaseClasses_WallFriction_Detailed_Internal_mx_0flowx_0ofx_0dpx_0fric_interpolateInRegion2x_0withDerivative
              (lambda20_0, Re10_0, Re20_0, Delta0_0, dpx_0fric, DYNStackData_);
            Re0_0 = dummy_mult_.Re0_0_0member;
            dRex_0ddp = dummy_mult_.dRex_0ddp_0member;
          }
        }
      }
      mx_0flowx_0der = divGuarded((crossAreax_0der*mu0_0+crossArea0_0*mux_0der)*
        (IF dpx_0fric >= 0 THEN Re0_0 ELSE  -Re0_0)+crossArea0_0*mu0_0*(IF 
        dpx_0fric >= 0 THEN Rex_0der ELSE  -Rex_0der),"(crossArea_der*mu+crossArea*mu_der)*(if dp_fric >= 0 then Re else  -Re)+crossArea*mu*(if dp_fric >= 0 then Re_der else  -Re_der)",
        diameter0_0,"diameter")-divGuarded(crossArea0_0*mu0_0*(IF dpx_0fric >= 0
         THEN Re0_0 ELSE  -Re0_0)*diameterx_0der,"crossArea*mu*(if dp_fric >= 0 then Re else  -Re)*diameter_der",
        sqr(diameter0_0),"diameter^2");
      mx_0flow = divGuarded(crossArea0_0*mu0_0*(IF dpx_0fric >= 0 THEN Re0_0
         ELSE  -Re0_0),"crossArea*mu*(if dp_fric >= 0 then Re else  -Re)",
        diameter0_0,"diameter");
      dmx_0flowx_0ddpx_0fricx_0der = divGuarded((crossAreax_0der*mu0_0+
        crossArea0_0*mux_0der)*dRex_0ddp+crossArea0_0*mu0_0*dRex_0ddpx_0der,
        "(crossArea_der*mu+crossArea*mu_der)*dRe_ddp+crossArea*mu*dRe_ddp_der",
        diameter0_0,"diameter")-divGuarded(crossArea0_0*mu0_0*dRex_0ddp*
        diameterx_0der,"crossArea*mu*dRe_ddp*diameter_der",sqr(diameter0_0),
        "diameter^2");
    /* Output section */
    DYNJPopContext(DYNStackData_)
    {
      struct Modelica_Fluid_Pipes_BaseClasses_WallFriction_Detailed_Internal_mx_0flowx_0ofx_0dpx_0fric__der_struct out_;
      out_.mx_0flowx_0der_0member = mx_0flowx_0der;
      out_.dmx_0flowx_0ddpx_0fricx_0der_0member = dmx_0flowx_0ddpx_0fricx_0der;
      return out_;
    }
  }}

/* Flattened Modelica model:

function Modelica.Fluid.Utilities.cubicHermite_withDerivative
discrete input Real x "Abscissa value";
discrete input Real x1 "Lower abscissa value";
discrete input Real x2 "Upper abscissa value";
discrete input Real y1 "Lower ordinate value";
discrete input Real y2 "Upper ordinate value";
discrete input Real y1d "Lower gradient";
discrete input Real y2d "Upper gradient";
discrete output Real y "Interpolated ordinate value";
discrete output Real dy_dx "Derivative dy/dx at abscissa value x";
protected 
discrete Real h "Distance between x1 and x2";
discrete Real t "Abscissa scaled with h, i.e., t=[0..1] within x=[x1..x2]";
discrete Real h00 "Basis function 00 of cubic Hermite spline";
discrete Real h10 "Basis function 10 of cubic Hermite spline";
discrete Real h01 "Basis function 01 of cubic Hermite spline";
discrete Real h11 "Basis function 11 of cubic Hermite spline";
discrete Real h00d "d/dt h00";
discrete Real h10d "d/dt h10";
discrete Real h01d "d/dt h01";
discrete Real h11d "d/dt h11";
discrete Real aux3 "t cube";
discrete Real aux2 "t square";
public 
algorithm 
h := x2-x1;
if (abs(h) > 0) then 
t := (x-x1)/h;
aux3 := t^3;
aux2 := t^2;
h00 := 2*aux3-3*aux2+1;
h10 := aux3-2*aux2+t;
h01 := ( -2*aux3)+3*aux2;
h11 := aux3-aux2;
h00d := 6*(aux2-t);
h10d := 3*aux2-4*t+1;
h01d := 6*(t-aux2);
h11d := 3*aux2-2*t;
y := y1*h00+h*y1d*h10+y2*h01+h*y2d*h11;
dy_dx := y1*h00d/h+y1d*h10d+y2*h01d/h+y2d*h11d;
else
y := (y1+y2)/2;
dy_dx := noEvent((if y2-y1 > 0 then 1 else (if y2-y1 < 0 then -1 else 0)))*1E+60;
end if;
annotation(derivative=Modelica.Fluid.Utilities.cubicHermite_withDerivative:der, smoothOrder=3);
end Modelica.Fluid.Utilities.cubicHermite_withDerivative;

  */
DYMOLA_STATIC struct Modelica_Fluid_Utilities_cubicHermitex_0withDerivative_struct
   Modelica_Fluid_Utilities_cubicHermitex_0withDerivative(double  x0_0, double  
  x10_0, double  x20_0, double  y10_0, double  y20_0, double  y1d0_0, double  
  y2d0_0, struct DYNFunctionData_* DYNStackData_) {
  DYNJPushContext("Modelica.Fluid.Utilities.cubicHermite_withDerivative", 
    DYNStackData_)
  {
    /* Declare outputs and temporaries */
    double   y0_0;
    double   dyx_0dx;
    double   h0_0;
    double   t0_0;
    double   h000_0;
    double   h100_0;
    double   h010_0;
    double   h110_0;
    double   h00d0_0;
    double   h10d0_0;
    double   h01d0_0;
    double   h11d0_0;
    double   aux30_0;
    double   aux20_0;
    y0_0=0;
    dyx_0dx=0;
    h0_0=0;
    t0_0=0;
    h000_0=0;
    h100_0=0;
    h010_0=0;
    h110_0=0;
    h00d0_0=0;
    h10d0_0=0;
    h01d0_0=0;
    h11d0_0=0;
    aux30_0=0;
    aux20_0=0;
    /* Start of real code */
      h0_0 = x20_0-x10_0;
      if (fabs(h0_0) > 0) {
        t0_0 = divGuarded(x0_0-x10_0,"x-x1",h0_0,"h");
        aux30_0 = powUnguarded(t0_0, 3);
        aux20_0 = sqr(t0_0);
        h000_0 = 2*aux30_0-3*aux20_0+1;
        h100_0 = aux30_0-2*aux20_0+t0_0;
        h010_0 = ( -2*aux30_0)+3*aux20_0;
        h110_0 = aux30_0-aux20_0;
        h00d0_0 = 6*(aux20_0-t0_0);
        h10d0_0 = 3*aux20_0-4*t0_0+1;
        h01d0_0 = 6*(t0_0-aux20_0);
        h11d0_0 = 3*aux20_0-2*t0_0;
        y0_0 = y10_0*h000_0+h0_0*y1d0_0*h100_0+y20_0*h010_0+h0_0*y2d0_0*h110_0;
        dyx_0dx = divGuarded(y10_0*h00d0_0,"y1*h00d",h0_0,"h")+y1d0_0*h10d0_0+
          divGuarded(y20_0*h01d0_0,"y2*h01d",h0_0,"h")+y2d0_0*h11d0_0;
      }
      else{
        y0_0 = (y10_0+y20_0)/(double)(2);
        dyx_0dx = (IF y20_0-y10_0 > 0 THEN 1 ELSE IF y20_0-y10_0 < 0 THEN -1
           ELSE 0)*1E+60;
      }
    /* Output section */
    DYNJPopContext(DYNStackData_)
    {
      struct Modelica_Fluid_Utilities_cubicHermitex_0withDerivative_struct out_;
      out_.y0_0_0member = y0_0;
      out_.dyx_0dx_0member = dyx_0dx;
      return out_;
    }
  }}

/* Flattened Modelica model:

function Modelica.Fluid.Utilities.regFun3
discrete input Real x "Abscissa value";
discrete input Real x0 "Lower abscissa value";
discrete input Real x1 "Upper abscissa value";
discrete input Real y0 "Ordinate value at lower abscissa value";
discrete input Real y1 "Ordinate value at upper abscissa value";
discrete input Real y0d "Derivative at lower abscissa value";
discrete input Real y1d "Derivative at upper abscissa value";
discrete output Real y "Ordinate value";
discrete output Real c "Slope of linear section between two cubic polynomials or dummy linear section slope if single cubic is used";
protected 
discrete Real h0 "Width of interval i=0";
discrete Real Delta0 "Slope of secant on interval i=0";
discrete Real xstar "Inflection point of cubic polynomial S0";
discrete Real mu "Distance of inflection point and left limit x0";
discrete Real eta "Distance of right limit x1 and inflection point";
discrete Real omega "Slope of cubic polynomial S0 at inflection point";
discrete Real rho "Weighting factor of eta and eta_tilde, mu and mu_tilde";
discrete Real theta0 "Slope metric";
discrete Real mu_tilde "Distance of start of linear section and left limit x0";
discrete Real eta_tilde "Distance of right limit x1 and end of linear section";
discrete Real xi1 "Start of linear section";
discrete Real xi2 "End of linear section";
discrete Real a1 "Leading coefficient of cubic on the left";
discrete Real a2 "Leading coefficient of cubic on the right";
discrete Real const12 "Integration constant of left cubic, linear section";
discrete Real const3 "Integration constant of right cubic";
discrete Real aux01;
discrete Real aux02;
Boolean useSingleCubicPolynomial(start = false) "Indicate to override further logic and use single cubic";
public 
algorithm 
assert(x0 < x1, "regFun3(): Data points not sorted appropriately (x0 = "+       String(x0, true, 0)+" > x1 = "+       String(x1, true, 0)+"). Please flip arguments.");
if (y0d*y1d >= 0) then 
// No equations
else
assert(abs(y0d) < 1E-15 or abs(y1d) < 1E-15, "regFun3(): Derivatives at data points do not allow co-monotone interpolation, as both are non-zero, of opposite sign and have an absolute value larger than machine eps (y0d = "+       String(y0d, true, 0)+", y1d = "+       String(y1d, true, 0)+"). Please correct arguments.");
end if;
h0 := x1-x0;
Delta0 := (y1-y0)/h0;
if (abs(Delta0) <= 0) then 
y := y0+Delta0*(x-x0);
c := 0;
elseif (abs(y1d+y0d-2*Delta0) < 1E-13) then 
y := y0+(x-x0)*(y0d+(x-x0)/h0*(( -2*y0d)-y1d+3*Delta0+(x-x0)*(y0d+y1d-2*Delta0)/h0));
aux01 := (x0+x1)/2;
c := 3*(y0d+y1d-2*Delta0)*(aux01-x0)^2/h0^2+2*(( -2*y0d)-y1d+3*Delta0)*(aux01-x0)/h0+y0d;
else
xstar := 0.3333333333333333*(( -3*x0*y0d)-3*x0*y1d+6*x0*Delta0-2*h0*y0d-h0*y1d+3*h0*Delta0)/(( -y0d)-y1d+2*Delta0);
mu := xstar-x0;
eta := x1-xstar;
omega := 3*(y0d+y1d-2*Delta0)*(xstar-x0)^2/h0^2+2*(( -2*y0d)-y1d+3*Delta0)*(xstar-x0)/h0+y0d;
aux01 := 0.25*noEvent((if Delta0 > 0 then 1 else (if Delta0 < 0 then -1 else 0)))*min(abs(omega), abs(Delta0));
if (abs(y0d-y1d) <= 1E-13) then 
aux02 := y0d;
if (y1 > y0+y0d*(x1-x0)) then 
useSingleCubicPolynomial := true;
end if;
elseif (abs(y1d+y0d-2*Delta0) < 1E-13) then 
aux02 := (6*Delta0*(y1d+y0d-1.5*Delta0)-y1d*y0d-y1d^2-y0d^2)*(if y1d+y0d-2*Delta0 >= 0 then 1 else -1)*1E+60;
else
aux02 := (6*Delta0*(y1d+y0d-1.5*Delta0)-y1d*y0d-y1d^2-y0d^2)/(3*(y1d+y0d-2*Delta0));
end if;
if ((mu > 0 and eta < h0 and Delta0*omega <= 0 or abs(aux01) < abs(aux02) and aux02*Delta0 >= 0 or abs(aux01) < abs(0.1*Delta0)) and  not useSingleCubicPolynomial) then 
c := aux01;
if (abs(c) < abs(aux02) and aux02*Delta0 >= 0) then 
c := aux02;
end if;
if (abs(c) < abs(0.1*Delta0)) then 
c := 0.1*Delta0;
end if;
theta0 := (y0d*mu+y1d*eta)/h0;
if (abs(theta0-c) < 1E-06) then 
c := 0.999999*theta0;
end if;
rho := 3*(Delta0-c)/(theta0-c);
mu_tilde := rho*mu;
eta_tilde := rho*eta;
xi1 := x0+mu_tilde;
xi2 := x1-eta_tilde;
a1 := (y0d-c)/max(mu_tilde^2, 1E-13);
a2 := (y1d-c)/max(eta_tilde^2, 1E-13);
const12 := y0-a1/3*(x0-xi1)^3-c*x0;
const3 := y1-a2/3*(x1-xi2)^3-c*x1;
if (x < xi1) then 
y := a1/3*(x-xi1)^3+c*x+const12;
elseif (x < xi2) then 
y := c*x+const12;
else
y := a2/3*(x-xi2)^3+c*x+const3;
end if;
else
y := y0+(x-x0)*(y0d+(x-x0)/h0*(( -2*y0d)-y1d+3*Delta0+(x-x0)*(y0d+y1d-2*Delta0)/h0));
aux01 := (x0+x1)/2;
c := 3*(y0d+y1d-2*Delta0)*(aux01-x0)^2/h0^2+2*(( -2*y0d)-y1d+3*Delta0)*(aux01-x0)/h0+y0d;
end if;
end if;
annotation(derivative=Modelica.Fluid.Utilities.regFun3:der, smoothOrder=1);
end Modelica.Fluid.Utilities.regFun3;

  */
DYMOLA_STATIC struct Modelica_Fluid_Utilities_regFun3_struct Modelica_Fluid_Utilities_regFun3
  (double  x0_0, double  x00_0, double  x10_0, double  y00_0, double  y10_0, 
  double  y0d0_0, double  y1d0_0, struct DYNFunctionData_* DYNStackData_) {
  char*retSMark_=DYNJGetStringMark(DYNStackData_);
  DYNJPushContext("Modelica.Fluid.Utilities.regFun3", DYNStackData_)
  {
    /* Declare outputs and temporaries */
    double   y0_0;
    double   c0_0;
    double   h00_0;
    double   Delta00_0;
    double   xstar0_0;
    double   mu0_0;
    double   eta0_0;
    double   omega0_0;
    double   rho0_0;
    double   theta00_0;
    double   mux_0tilde;
    double   etax_0tilde;
    double   xi10_0;
    double   xi20_0;
    double   a10_0;
    double   a20_0;
    double   const120_0;
    double   const30_0;
    double   aux010_0;
    double   aux020_0;
    int   useSingleCubicPolynomial0_0;
    y0_0=0;
    c0_0=0;
    h00_0=0;
    Delta00_0=0;
    xstar0_0=0;
    mu0_0=0;
    eta0_0=0;
    omega0_0=0;
    rho0_0=0;
    theta00_0=0;
    mux_0tilde=0;
    etax_0tilde=0;
    xi10_0=0;
    xi20_0=0;
    a10_0=0;
    a20_0=0;
    const120_0=0;
    const30_0=0;
    aux010_0=0;
    aux020_0=0;
    useSingleCubicPolynomial0_0 = false;
    /* Start of real code */
      AssertModelica(x00_0 < x10_0,"x0 < x1", StringAdd(StringAdd(StringAdd(
        StringAdd("regFun3(): Data points not sorted appropriately (x0 = ",
        Real2String2(x00_0, true, 0))," > x1 = "),Real2String2(x10_0, true, 0)),
        "). Please flip arguments."));
      if (y0d0_0*y1d0_0 >= 0) {
        /* No equations */
      }
      else{
        AssertModelica(fabs(y0d0_0) < 1E-15 OR fabs(y1d0_0) < 1E-15,
          "abs(y0d) < 1E-15 or abs(y1d) < 1E-15", StringAdd(StringAdd(StringAdd(
          StringAdd("regFun3(): Derivatives at data points do not allow co-monotone interpolation, as both are non-zero, of opposite sign and have an absolute value larger than machine eps (y0d = ",
          Real2String2(y0d0_0, true, 0)),", y1d = "),Real2String2(y1d0_0, true, 0)),
          "). Please correct arguments."));
      }
      h00_0 = x10_0-x00_0;
      Delta00_0 = divGuarded(y10_0-y00_0,"y1-y0",h00_0,"h0");
      if (fabs(Delta00_0) <= 0) {
        y0_0 = y00_0+Delta00_0*(x0_0-x00_0);
        c0_0 = 0;
      }
      else if (fabs(y1d0_0+y0d0_0-2*Delta00_0) < 1E-13) {
        y0_0 = y00_0+(x0_0-x00_0)*(y0d0_0+divGuarded(x0_0-x00_0,"x-x0",h00_0,
          "h0")*(( -2*y0d0_0)-y1d0_0+3*Delta00_0+divGuarded((x0_0-x00_0)*(y0d0_0
          +y1d0_0-2*Delta00_0),"(x-x0)*(y0d+y1d-2*Delta0)",h00_0,"h0")));
        aux010_0 = (x00_0+x10_0)/(double)(2);
        c0_0 = divGuarded(3*(y0d0_0+y1d0_0-2*Delta00_0)*sqr(aux010_0-x00_0),
          "3*(y0d+y1d-2*Delta0)*(aux01-x0)^2",sqr(h00_0),"h0^2")+divGuarded(2*((
           -2*y0d0_0)-y1d0_0+3*Delta00_0)*(aux010_0-x00_0),"2*(( -2*y0d)-y1d+3*Delta0)*(aux01-x0)",
          h00_0,"h0")+y0d0_0;
      }
      else{
        xstar0_0 = divGuarded(0.3333333333333333*(( -3*x00_0*y0d0_0)-3*x00_0*
          y1d0_0+6*x00_0*Delta00_0-2*h00_0*y0d0_0-h00_0*y1d0_0+3*h00_0*Delta00_0),
          "0.3333333333333333*(( -3*x0*y0d)-3*x0*y1d+6*x0*Delta0-2*h0*y0d-h0*y1d+3*h0*Delta0)",
          ( -y0d0_0)-y1d0_0+2*Delta00_0,"( -y0d)-y1d+2*Delta0");
        mu0_0 = xstar0_0-x00_0;
        eta0_0 = x10_0-xstar0_0;
        omega0_0 = divGuarded(3*(y0d0_0+y1d0_0-2*Delta00_0)*sqr(xstar0_0-x00_0),
          "3*(y0d+y1d-2*Delta0)*(xstar-x0)^2",sqr(h00_0),"h0^2")+divGuarded(2*((
           -2*y0d0_0)-y1d0_0+3*Delta00_0)*(xstar0_0-x00_0),"2*(( -2*y0d)-y1d+3*Delta0)*(xstar-x0)",
          h00_0,"h0")+y0d0_0;
        aux010_0 = 0.25*(IF Delta00_0 > 0 THEN 1 ELSE IF Delta00_0 < 0 THEN -1
           ELSE 0)*RealBmin(fabs(omega0_0), fabs(Delta00_0));
        if (fabs(y0d0_0-y1d0_0) <= 1E-13) {
          aux020_0 = y0d0_0;
          if (y10_0 > y00_0+y0d0_0*(x10_0-x00_0)) {
            useSingleCubicPolynomial0_0 = true;
          }
        }
        else if (fabs(y1d0_0+y0d0_0-2*Delta00_0) < 1E-13) {
          aux020_0 = (6*Delta00_0*(y1d0_0+y0d0_0-1.5*Delta00_0)-y1d0_0*y0d0_0-
            sqr(y1d0_0)-sqr(y0d0_0))*(IF y1d0_0+y0d0_0-2*Delta00_0 >= 0 THEN 1
             ELSE -1)*1E+60;
        }
        else{
          aux020_0 = divGuarded(6*Delta00_0*(y1d0_0+y0d0_0-1.5*Delta00_0)-y1d0_0
            *y0d0_0-sqr(y1d0_0)-sqr(y0d0_0),"6*Delta0*(y1d+y0d-1.5*Delta0)-y1d*y0d-y1d^2-y0d^2",3
            *(y1d0_0+y0d0_0-2*Delta00_0),"3*(y1d+y0d-2*Delta0)");
        }
        if ((mu0_0 > 0 AND eta0_0 < h00_0 AND Delta00_0*omega0_0 <= 0 OR fabs(
          aux010_0) < fabs(aux020_0) AND aux020_0*Delta00_0 >= 0 OR fabs(
          aux010_0) < fabs(0.1*Delta00_0)) AND  NOT useSingleCubicPolynomial0_0)
           {
          c0_0 = aux010_0;
          if (fabs(c0_0) < fabs(aux020_0) AND aux020_0*Delta00_0 >= 0) {
            c0_0 = aux020_0;
          }
          if (fabs(c0_0) < fabs(0.1*Delta00_0)) {
            c0_0 = 0.1*Delta00_0;
          }
          theta00_0 = divGuarded(y0d0_0*mu0_0+y1d0_0*eta0_0,"y0d*mu+y1d*eta",
            h00_0,"h0");
          if (fabs(theta00_0-c0_0) < 1E-06) {
            c0_0 = 0.999999*theta00_0;
          }
          rho0_0 = divGuarded(3*(Delta00_0-c0_0),"3*(Delta0-c)",theta00_0-c0_0,
            "theta0-c");
          mux_0tilde = rho0_0*mu0_0;
          etax_0tilde = rho0_0*eta0_0;
          xi10_0 = x00_0+mux_0tilde;
          xi20_0 = x10_0-etax_0tilde;
          a10_0 = divGuarded(y0d0_0-c0_0,"y0d-c",RealBmax(sqr(mux_0tilde), 1E-13),
            "max(mu_tilde^2, 1E-13)");
          a20_0 = divGuarded(y1d0_0-c0_0,"y1d-c",RealBmax(sqr(etax_0tilde), 
            1E-13),"max(eta_tilde^2, 1E-13)");
          const120_0 = y00_0-a10_0/(double)(3)*powUnguarded(x00_0-xi10_0, 3)-
            c0_0*x00_0;
          const30_0 = y10_0-a20_0/(double)(3)*powUnguarded(x10_0-xi20_0, 3)-c0_0
            *x10_0;
          if (x0_0 < xi10_0) {
            y0_0 = a10_0/(double)(3)*powUnguarded(x0_0-xi10_0, 3)+c0_0*x0_0+
              const120_0;
          }
          else if (x0_0 < xi20_0) {
            y0_0 = c0_0*x0_0+const120_0;
          }
          else{
            y0_0 = a20_0/(double)(3)*powUnguarded(x0_0-xi20_0, 3)+c0_0*x0_0+
              const30_0;
          }
        }
        else{
          y0_0 = y00_0+(x0_0-x00_0)*(y0d0_0+divGuarded(x0_0-x00_0,"x-x0",h00_0,
            "h0")*(( -2*y0d0_0)-y1d0_0+3*Delta00_0+divGuarded((x0_0-x00_0)*(
            y0d0_0+y1d0_0-2*Delta00_0),"(x-x0)*(y0d+y1d-2*Delta0)",h00_0,"h0")));
          aux010_0 = (x00_0+x10_0)/(double)(2);
          c0_0 = divGuarded(3*(y0d0_0+y1d0_0-2*Delta00_0)*sqr(aux010_0-x00_0),
            "3*(y0d+y1d-2*Delta0)*(aux01-x0)^2",sqr(h00_0),"h0^2")+divGuarded(2*
            (( -2*y0d0_0)-y1d0_0+3*Delta00_0)*(aux010_0-x00_0),"2*(( -2*y0d)-y1d+3*Delta0)*(aux01-x0)",
            h00_0,"h0")+y0d0_0;
        }
      }
    /* Output section */
    DYNJSetStringMark(retSMark_, DYNStackData_);
    DYNJPopContext(DYNStackData_)
    {
      struct Modelica_Fluid_Utilities_regFun3_struct out_;
      out_.y0_0_0member = y0_0;
      out_.c0_0_0member = c0_0;
      return out_;
    }
  }}

/* Flattened Modelica model:

function Modelica.Fluid.Utilities.regFun3:der
discrete input Real x;
discrete input Real x0;
discrete input Real x1;
discrete input Real y0;
discrete input Real y1;
discrete input Real y0d;
discrete input Real y1d;
protected 
discrete Real y;
discrete Real c;
discrete Real h0;
discrete Real Delta0;
discrete Real xstar;
discrete Real mu;
discrete Real eta;
discrete Real omega;
discrete Real rho;
discrete Real theta0;
discrete Real mu_tilde;
discrete Real eta_tilde;
discrete Real xi1;
discrete Real xi2;
discrete Real a1;
discrete Real a2;
discrete Real const12;
discrete Real const3;
discrete Real aux01;
discrete Real aux02;
Boolean useSingleCubicPolynomial(start = false);
public 
discrete input Real x_der;
discrete input Real x0_der;
discrete input Real x1_der;
discrete input Real y0_der;
discrete input Real y1_der;
discrete input Real y0d_der;
discrete input Real y1d_der;
discrete output Real y_der;
discrete output Real c_der;
protected 
discrete Real h0_der;
discrete Real Delta0_der;
discrete Real xstar_der;
discrete Real mu_der;
discrete Real eta_der;
discrete Real omega_der;
discrete Real rho_der;
discrete Real theta0_der;
discrete Real mu_tilde_der;
discrete Real eta_tilde_der;
discrete Real xi1_der;
discrete Real xi2_der;
discrete Real a1_der;
discrete Real a2_der;
discrete Real const12_der;
discrete Real const3_der;
discrete Real aux01_der;
discrete Real aux02_der;
public 
algorithm 
assert(x0 < x1, "regFun3(): Data points not sorted appropriately (x0 = "+       String(x0, true, 0)+" > x1 = "+       String(x1, true, 0)+"). Please flip arguments.");
if (y0d*y1d >= 0) then 
// No equations
else
assert(abs(y0d) < 1E-15 or abs(y1d) < 1E-15, "regFun3(): Derivatives at data points do not allow co-monotone interpolation, as both are non-zero, of opposite sign and have an absolute value larger than machine eps (y0d = "+       String(y0d, true, 0)+", y1d = "+       String(y1d, true, 0)+"). Please correct arguments.");
end if;
h0_der := x1_der-x0_der;
h0 := x1-x0;
Delta0_der := (y1_der-y0_der)/h0-(y1-y0)*h0_der/h0^2;
Delta0 := (y1-y0)/h0;
if (abs(Delta0) <= 0) then 
y_der := y0_der+Delta0_der*(x-x0)+Delta0*(x_der-x0_der);
y := y0+Delta0*(x-x0);
c_der := 0;
elseif (abs(y1d+y0d-2*Delta0) < 1E-13) then 
y_der := y0_der+(x_der-x0_der)*(y0d+(x-x0)*((-2)*y0d-y1d+3*Delta0+(x-x0)*(y0d+y1d-2*Delta0)/h0)/h0)+(x-x0)*(y0d_der+((x_der-x0_der)*((-2)*y0d-y1d+3*Delta0+(x-x0)*(y0d+y1d-2*Delta0)/h0)+(x-x0)*((-2)*y0d_der-y1d_der+3*Delta0_der+((x_der-x0_der)*(y0d+y1d-2*Delta0)+(x-x0)*(y0d_der+y1d_der-2*Delta0_der))/h0-(x-x0)*(y0d+y1d-2*Delta0)*h0_der/h0^2))/h0-(x-x0)*((-2)*y0d-y1d+3*Delta0+(x-x0)*(y0d+y1d-2*Delta0)/h0)*h0_der/h0^2);
y := y0+(x-x0)*(y0d+(x-x0)*((-2)*y0d-y1d+3*Delta0+(x-x0)*(y0d+y1d-2*Delta0)/h0)/h0);
aux01_der := 0.5*(x0_der+x1_der);
aux01 := 0.5*(x0+x1);
c_der := 3.0*((y0d_der+y1d_der-2*Delta0_der)*(aux01-x0)^2+2.0*((y0d+y1d-2*Delta0)*((aux01-x0)*(aux01_der-x0_der))))/h0^2-6.0*((y0d+y1d-2*Delta0)*(aux01-x0)^2*(h0*h0_der))/(h0^2)^2+2.0*(((-2)*y0d_der-y1d_der+3*Delta0_der)*(aux01-x0)+((-2)*y0d-y1d+3*Delta0)*(aux01_der-x0_der))/h0-2.0*(((-2)*y0d-y1d+3*Delta0)*(aux01-x0)*h0_der)/h0^2+y0d_der;
else
xstar_der := 0.3333333333333333*(6.0*(x0_der*Delta0+x0*Delta0_der)-3.0*(x0_der*y0d+x0*y0d_der+x0_der*y1d+x0*y1d_der)-2.0*(h0_der*y0d+h0*y0d_der)-(h0_der*y1d+h0*y1d_der)+3.0*(h0_der*Delta0+h0*Delta0_der))/(2*Delta0-(y0d+y1d))-0.3333333333333333*((6.0*(x0*Delta0)-3.0*(x0*y0d+x0*y1d)-2.0*(h0*y0d)-h0*y1d+3.0*(h0*Delta0))*(2*Delta0_der-(y0d_der+y1d_der)))/(2*Delta0-(y0d+y1d))^2;
xstar := 0.3333333333333333*(6.0*(x0*Delta0)-3.0*(x0*y0d+x0*y1d)-2.0*(h0*y0d)-h0*y1d+3.0*(h0*Delta0))/(2*Delta0-(y0d+y1d));
mu_der := xstar_der-x0_der;
mu := xstar-x0;
eta_der := x1_der-xstar_der;
eta := x1-xstar;
omega_der := 3.0*((y0d_der+y1d_der-2*Delta0_der)*(xstar-x0)^2+2.0*((y0d+y1d-2*Delta0)*((xstar-x0)*(xstar_der-x0_der))))/h0^2-6.0*((y0d+y1d-2*Delta0)*(xstar-x0)^2*(h0*h0_der))/(h0^2)^2+2.0*(((-2)*y0d_der-y1d_der+3*Delta0_der)*(xstar-x0)+((-2)*y0d-y1d+3*Delta0)*(xstar_der-x0_der))/h0-2.0*(((-2)*y0d-y1d+3*Delta0)*(xstar-x0)*h0_der)/h0^2+y0d_der;
omega := 3.0*((y0d+y1d-2*Delta0)*(xstar-x0)^2)/h0^2+2.0*(((-2)*y0d-y1d+3*Delta0)*(xstar-x0))/h0+y0d;
aux01_der := 0.25*(noEvent((if Delta0 > 0 then 1 else (if Delta0 < 0 then -1 else 0)))*(if noEvent(abs(omega) < abs(Delta0)) then omega_der*noEvent((if omega > 0 then 1 else -1)) else Delta0_der*noEvent((if Delta0 > 0 then 1 else -1))));
aux01 := 0.25*(noEvent((if Delta0 > 0 then 1 else (if Delta0 < 0 then -1 else 0)))*min(abs(omega), abs(Delta0)));
if (abs(y0d-y1d) <= 1E-13) then 
aux02_der := y0d_der;
aux02 := y0d;
if (y1 > y0+y0d*(x1-x0)) then 
useSingleCubicPolynomial := true;
end if;
elseif (abs(y1d+y0d-2*Delta0) < 1E-13) then 
aux02_der := 1E+60*((6.0*(Delta0_der*(y1d+y0d-1.5*Delta0)+Delta0*(y1d_der+y0d_der-1.5*Delta0_der))-(y1d_der*y0d+y1d*y0d_der)-2.0*(y1d*y1d_der)-2.0*(y0d*y0d_der))*(if y1d+y0d-2*Delta0 >= 0 then 1 else -1));
aux02 := 1E+60*((6.0*(Delta0*(y1d+y0d-1.5*Delta0))-y1d*y0d-y1d^2-y0d^2)*(if y1d+y0d-2*Delta0 >= 0 then 1 else -1));
else
aux02_der := (6.0*(Delta0_der*(y1d+y0d-1.5*Delta0)+Delta0*(y1d_der+y0d_der-1.5*Delta0_der))-(y1d_der*y0d+y1d*y0d_der)-2.0*(y1d*y1d_der)-2.0*(y0d*y0d_der))/(3*(y1d+y0d-2*Delta0))-3.0*((6.0*(Delta0*(y1d+y0d-1.5*Delta0))-y1d*y0d-y1d^2-y0d^2)*(y1d_der+y0d_der-2*Delta0_der))/(3*(y1d+y0d-2*Delta0))^2;
aux02 := (6.0*(Delta0*(y1d+y0d-1.5*Delta0))-y1d*y0d-y1d^2-y0d^2)/(3*(y1d+y0d-2*Delta0));
end if;
if ((mu > 0 and eta < h0 and Delta0*omega <= 0 or abs(aux01) < abs(aux02) and aux02*Delta0 >= 0 or abs(aux01) < abs(0.1*Delta0)) and  not useSingleCubicPolynomial) then 
c_der := aux01_der;
c := aux01;
if (abs(c) < abs(aux02) and aux02*Delta0 >= 0) then 
c_der := aux02_der;
c := aux02;
end if;
if (abs(c) < abs(0.1*Delta0)) then 
c_der := 0.1*Delta0_der;
c := 0.1*Delta0;
end if;
theta0_der := (y0d_der*mu+y0d*mu_der+y1d_der*eta+y1d*eta_der)/h0-(y0d*mu+y1d*eta)*h0_der/h0^2;
theta0 := (y0d*mu+y1d*eta)/h0;
if (abs(theta0-c) < 1E-06) then 
c_der := 0.999999*theta0_der;
c := 0.999999*theta0;
end if;
rho_der := 3*(Delta0_der-c_der)/(theta0-c)-3.0*((Delta0-c)*(theta0_der-c_der))/(theta0-c)^2;
rho := 3*(Delta0-c)/(theta0-c);
mu_tilde_der := rho_der*mu+rho*mu_der;
mu_tilde := rho*mu;
eta_tilde_der := rho_der*eta+rho*eta_der;
eta_tilde := rho*eta;
xi1_der := x0_der+mu_tilde_der;
xi1 := x0+mu_tilde;
xi2_der := x1_der-eta_tilde_der;
xi2 := x1-eta_tilde;
a1_der := (y0d_der-c_der)/max(mu_tilde^2, 1E-13)-(y0d-c)*(if noEvent(mu_tilde^2 > 1E-13) then 2.0*(mu_tilde*mu_tilde_der) else 0.0)/max(mu_tilde^2, 1E-13)^2;
a1 := (y0d-c)/max(mu_tilde^2, 1E-13);
a2_der := (y1d_der-c_der)/max(eta_tilde^2, 1E-13)-(y1d-c)*(if noEvent(eta_tilde^2 > 1E-13) then 2.0*(eta_tilde*eta_tilde_der) else 0.0)/max(eta_tilde^2, 1E-13)^2;
a2 := (y1d-c)/max(eta_tilde^2, 1E-13);
const12_der := y0_der-0.3333333333333333*(a1_der*(x0-xi1)^3+3.0*(a1*((x0-xi1)^2*(x0_der-xi1_der))))-(c_der*x0+c*x0_der);
const12 := y0-0.3333333333333333*(a1*(x0-xi1)^3)-c*x0;
const3_der := y1_der-0.3333333333333333*(a2_der*(x1-xi2)^3+3.0*(a2*((x1-xi2)^2*(x1_der-xi2_der))))-(c_der*x1+c*x1_der);
const3 := y1-0.3333333333333333*(a2*(x1-xi2)^3)-c*x1;
if (x < xi1) then 
y_der := 0.3333333333333333*(a1_der*(x-xi1)^3+3.0*(a1*((x-xi1)^2*(x_der-xi1_der))))+c_der*x+c*x_der+const12_der;
elseif (x < xi2) then 
y_der := c_der*x+c*x_der+const12_der;
else
y_der := 0.3333333333333333*(a2_der*(x-xi2)^3+3.0*(a2*((x-xi2)^2*(x_der-xi2_der))))+c_der*x+c*x_der+const3_der;
end if;
else
y_der := y0_der+(x_der-x0_der)*(y0d+(x-x0)*((-2)*y0d-y1d+3*Delta0+(x-x0)*(y0d+y1d-2*Delta0)/h0)/h0)+(x-x0)*(y0d_der+((x_der-x0_der)*((-2)*y0d-y1d+3*Delta0+(x-x0)*(y0d+y1d-2*Delta0)/h0)+(x-x0)*((-2)*y0d_der-y1d_der+3*Delta0_der+((x_der-x0_der)*(y0d+y1d-2*Delta0)+(x-x0)*(y0d_der+y1d_der-2*Delta0_der))/h0-(x-x0)*(y0d+y1d-2*Delta0)*h0_der/h0^2))/h0-(x-x0)*((-2)*y0d-y1d+3*Delta0+(x-x0)*(y0d+y1d-2*Delta0)/h0)*h0_der/h0^2);
y := y0+(x-x0)*(y0d+(x-x0)*((-2)*y0d-y1d+3*Delta0+(x-x0)*(y0d+y1d-2*Delta0)/h0)/h0);
aux01_der := 0.5*(x0_der+x1_der);
aux01 := 0.5*(x0+x1);
c_der := 3.0*((y0d_der+y1d_der-2*Delta0_der)*(aux01-x0)^2+2.0*((y0d+y1d-2*Delta0)*((aux01-x0)*(aux01_der-x0_der))))/h0^2-6.0*((y0d+y1d-2*Delta0)*(aux01-x0)^2*(h0*h0_der))/(h0^2)^2+2.0*(((-2)*y0d_der-y1d_der+3*Delta0_der)*(aux01-x0)+((-2)*y0d-y1d+3*Delta0)*(aux01_der-x0_der))/h0-2.0*(((-2)*y0d-y1d+3*Delta0)*(aux01-x0)*h0_der)/h0^2+y0d_der;
end if;
end if;
annotation(smoothOrder=0);
end Modelica.Fluid.Utilities.regFun3:der;

  */
DYMOLA_STATIC struct Modelica_Fluid_Utilities_regFun3__der_struct 
  Modelica_Fluid_Utilities_regFun3__der(double  x0_0, double  x00_0, double  
  x10_0, double  y00_0, double  y10_0, double  y0d0_0, double  y1d0_0, double  
  xx_0der, double  x0x_0der, double  x1x_0der, double  y0x_0der, double  
  y1x_0der, double  y0dx_0der, double  y1dx_0der, struct DYNFunctionData_* DYNStackData_)
   {
  char*retSMark_=DYNJGetStringMark(DYNStackData_);
  DYNJPushContext("Modelica.Fluid.Utilities.regFun3:der", DYNStackData_)
  {
    /* Declare outputs and temporaries */
    double   y0_0;
    double   c0_0;
    double   h00_0;
    double   Delta00_0;
    double   xstar0_0;
    double   mu0_0;
    double   eta0_0;
    double   omega0_0;
    double   rho0_0;
    double   theta00_0;
    double   mux_0tilde;
    double   etax_0tilde;
    double   xi10_0;
    double   xi20_0;
    double   a10_0;
    double   a20_0;
    double   const120_0;
    double   const30_0;
    double   aux010_0;
    double   aux020_0;
    int   useSingleCubicPolynomial0_0;
    double   yx_0der;
    double   cx_0der;
    double   h0x_0der;
    double   Delta0x_0der;
    double   xstarx_0der;
    double   mux_0der;
    double   etax_0der;
    double   omegax_0der;
    double   rhox_0der;
    double   theta0x_0der;
    double   mux_0tildex_0der;
    double   etax_0tildex_0der;
    double   xi1x_0der;
    double   xi2x_0der;
    double   a1x_0der;
    double   a2x_0der;
    double   const12x_0der;
    double   const3x_0der;
    double   aux01x_0der;
    double   aux02x_0der;
    y0_0=0;
    c0_0=0;
    h00_0=0;
    Delta00_0=0;
    xstar0_0=0;
    mu0_0=0;
    eta0_0=0;
    omega0_0=0;
    rho0_0=0;
    theta00_0=0;
    mux_0tilde=0;
    etax_0tilde=0;
    xi10_0=0;
    xi20_0=0;
    a10_0=0;
    a20_0=0;
    const120_0=0;
    const30_0=0;
    aux010_0=0;
    aux020_0=0;
    useSingleCubicPolynomial0_0 = false;
    yx_0der=0;
    cx_0der=0;
    h0x_0der=0;
    Delta0x_0der=0;
    xstarx_0der=0;
    mux_0der=0;
    etax_0der=0;
    omegax_0der=0;
    rhox_0der=0;
    theta0x_0der=0;
    mux_0tildex_0der=0;
    etax_0tildex_0der=0;
    xi1x_0der=0;
    xi2x_0der=0;
    a1x_0der=0;
    a2x_0der=0;
    const12x_0der=0;
    const3x_0der=0;
    aux01x_0der=0;
    aux02x_0der=0;
    /* Start of real code */
      AssertModelica(x00_0 < x10_0,"x0 < x1", StringAdd(StringAdd(StringAdd(
        StringAdd("regFun3(): Data points not sorted appropriately (x0 = ",
        Real2String2(x00_0, true, 0))," > x1 = "),Real2String2(x10_0, true, 0)),
        "). Please flip arguments."));
      if (y0d0_0*y1d0_0 >= 0) {
        /* No equations */
      }
      else{
        AssertModelica(fabs(y0d0_0) < 1E-15 OR fabs(y1d0_0) < 1E-15,
          "abs(y0d) < 1E-15 or abs(y1d) < 1E-15", StringAdd(StringAdd(StringAdd(
          StringAdd("regFun3(): Derivatives at data points do not allow co-monotone interpolation, as both are non-zero, of opposite sign and have an absolute value larger than machine eps (y0d = ",
          Real2String2(y0d0_0, true, 0)),", y1d = "),Real2String2(y1d0_0, true, 0)),
          "). Please correct arguments."));
      }
      h0x_0der = x1x_0der-x0x_0der;
      h00_0 = x10_0-x00_0;
      Delta0x_0der = divGuarded(y1x_0der-y0x_0der,"y1_der-y0_der",h00_0,"h0")-
        divGuarded((y10_0-y00_0)*h0x_0der,"(y1-y0)*h0_der",sqr(h00_0),"h0^2");
      Delta00_0 = divGuarded(y10_0-y00_0,"y1-y0",h00_0,"h0");
      if (fabs(Delta00_0) <= 0) {
        yx_0der = y0x_0der+Delta0x_0der*(x0_0-x00_0)+Delta00_0*(xx_0der-x0x_0der);
        y0_0 = y00_0+Delta00_0*(x0_0-x00_0);
        cx_0der = 0;
      }
      else if (fabs(y1d0_0+y0d0_0-2*Delta00_0) < 1E-13) {
        /* Introducing 16 common subexpressions used in 16 expressions */
        /* Of the common subexpressions 16 are reals, 0 are integers, and 0
           are booleans. */

        { double helpvarF[16];
        DYNX(helpvarF,0) = xx_0der-x0x_0der;
        DYNX(helpvarF,1) = x0_0-x00_0;
        DYNX(helpvarF,2) = y0d0_0+y1d0_0-2*Delta00_0;
        DYNX(helpvarF,3) = DYNX(helpvarF,1)*DYNX(helpvarF,2);
        DYNX(helpvarF,4) = divinvGuarded(h00_0,"h0");
        DYNX(helpvarF,5) = (-2)*y0d0_0-y1d0_0+3*Delta00_0+DYNX(helpvarF,4)*
          DYNX(helpvarF,3);
        DYNX(helpvarF,6) = DYNX(helpvarF,1)*DYNX(helpvarF,5);
        DYNX(helpvarF,7) = DYNX(helpvarF,4)*DYNX(helpvarF,6);
        DYNX(helpvarF,8) = (-2)*y0dx_0der;
        DYNX(helpvarF,9) = DYNX(helpvarF,0)*DYNX(helpvarF,2)+DYNX(helpvarF,1)*(
          y0dx_0der+y1dx_0der-2*Delta0x_0der);
        DYNX(helpvarF,10) = DYNX(helpvarF,3)*h0x_0der;
        DYNX(helpvarF,11) = sqr(h00_0);
        DYNX(helpvarF,12) = divinvGuarded(DYNX(helpvarF,11),"h0^2");
        DYNX(helpvarF,13) = DYNX(helpvarF,12)*DYNX(helpvarF,10);
        DYNX(helpvarF,14) = DYNX(helpvarF,4)*(DYNX(helpvarF,0)*DYNX(helpvarF,5)+
          DYNX(helpvarF,1)*(DYNX(helpvarF,8)-y1dx_0der+3*Delta0x_0der+
          DYNX(helpvarF,4)*DYNX(helpvarF,9)-DYNX(helpvarF,13)));
        DYNX(helpvarF,15) = DYNX(helpvarF,12)*DYNX(helpvarF,6)*h0x_0der;
        yx_0der = y0x_0der+DYNX(helpvarF,0)*(y0d0_0+DYNX(helpvarF,7))+
          DYNX(helpvarF,1)*(y0dx_0der+DYNX(helpvarF,14)-DYNX(helpvarF,15));
        }
        y0_0 = y00_0+(x0_0-x00_0)*(y0d0_0+divGuarded((x0_0-x00_0)*((-2)*y0d0_0-
          y1d0_0+3*Delta00_0+divGuarded((x0_0-x00_0)*(y0d0_0+y1d0_0-2*Delta00_0),
          "(x-x0)*(y0d+y1d-2*Delta0)",h00_0,"h0")),"(x-x0)*((-2)*y0d-y1d+3*Delta0+(x-x0)*(y0d+y1d-2*Delta0)/h0)",
          h00_0,"h0"));
        aux01x_0der = 0.5*(x0x_0der+x1x_0der);
        aux010_0 = 0.5*(x00_0+x10_0);
        /* Introducing 12 common subexpressions used in 12 expressions */
        /* Of the common subexpressions 12 are reals, 0 are integers, and 0
           are booleans. */

        { double helpvarF[12];
        DYNX(helpvarF,0) = aux010_0-x00_0;
        DYNX(helpvarF,1) = sqr(DYNX(helpvarF,0));
        DYNX(helpvarF,2) = y0d0_0+y1d0_0-2*Delta00_0;
        DYNX(helpvarF,3) = aux01x_0der-x0x_0der;
        DYNX(helpvarF,4) = (y0dx_0der+y1dx_0der-2*Delta0x_0der)*DYNX(helpvarF,1)
          +2.0*DYNX(helpvarF,2)*DYNX(helpvarF,0)*DYNX(helpvarF,3);
        DYNX(helpvarF,5) = sqr(h00_0);
        DYNX(helpvarF,6) = divinvGuarded(DYNX(helpvarF,5),"h0^2");
        DYNX(helpvarF,7) = DYNX(helpvarF,2)*DYNX(helpvarF,1)*h00_0*h0x_0der;
        DYNX(helpvarF,8) = sqr(DYNX(helpvarF,5));
        DYNX(helpvarF,9) = (-2)*y0d0_0-y1d0_0+3*Delta00_0;
        DYNX(helpvarF,10) = ((-2)*y0dx_0der-y1dx_0der+3*Delta0x_0der)*
          DYNX(helpvarF,0)+DYNX(helpvarF,9)*DYNX(helpvarF,3);
        DYNX(helpvarF,11) = DYNX(helpvarF,9)*DYNX(helpvarF,0)*h0x_0der;
        cx_0der = DYNX(helpvarF,6)*3.0*DYNX(helpvarF,4)-divGuarded(6.0*
          DYNX(helpvarF,7),"6.0*((y0d+y1d-2*Delta0)*(aux01-x0)^2*(h0*h0_der))",
          DYNX(helpvarF,8),"(h0^2)^2")+divGuarded(2.0*DYNX(helpvarF,10),
          "2.0*(((-2)*y0d_der-y1d_der+3*Delta0_der)*(aux01-x0)+((-2)*y0d-y1d+3*Delta0)*(aux01_der-x0_der))",
          h00_0,"h0")-DYNX(helpvarF,6)*2.0*DYNX(helpvarF,11)+y0dx_0der;
        }
      }
      else{
        xstarx_0der = divGuarded(0.3333333333333333*(6.0*(x0x_0der*Delta00_0+
          x00_0*Delta0x_0der)-3.0*(x0x_0der*y0d0_0+x00_0*y0dx_0der+x0x_0der*
          y1d0_0+x00_0*y1dx_0der)-2.0*(h0x_0der*y0d0_0+h00_0*y0dx_0der)-(
          h0x_0der*y1d0_0+h00_0*y1dx_0der)+3.0*(h0x_0der*Delta00_0+h00_0*
          Delta0x_0der)),"0.3333333333333333*(6.0*(x0_der*Delta0+x0*Delta0_der)-3.0*(x0_der*y0d+x0*y0d_der+x0_der*y1d+x0*y1d_der)-2.0*(h0_der*y0d+h0*y0d_der)-(h0_der*y1d+h0*y1d_der)+3.0*(h0_der*Delta0+h0*Delta0_der))",2
          *Delta00_0-(y0d0_0+y1d0_0),"2*Delta0-(y0d+y1d)")-divGuarded(
          0.3333333333333333*(6.0*x00_0*Delta00_0-3.0*(x00_0*y0d0_0+x00_0*y1d0_0)
          -2.0*h00_0*y0d0_0-h00_0*y1d0_0+3.0*h00_0*Delta00_0)*(2*Delta0x_0der-(
          y0dx_0der+y1dx_0der)),"0.3333333333333333*((6.0*(x0*Delta0)-3.0*(x0*y0d+x0*y1d)-2.0*(h0*y0d)-h0*y1d+3.0*(h0*Delta0))*(2*Delta0_der-(y0d_der+y1d_der)))",
          sqr(2*Delta00_0-(y0d0_0+y1d0_0)),"(2*Delta0-(y0d+y1d))^2");
        xstar0_0 = divGuarded(0.3333333333333333*(6.0*x00_0*Delta00_0-3.0*(x00_0
          *y0d0_0+x00_0*y1d0_0)-2.0*h00_0*y0d0_0-h00_0*y1d0_0+3.0*h00_0*
          Delta00_0),"0.3333333333333333*(6.0*(x0*Delta0)-3.0*(x0*y0d+x0*y1d)-2.0*(h0*y0d)-h0*y1d+3.0*(h0*Delta0))",2
          *Delta00_0-(y0d0_0+y1d0_0),"2*Delta0-(y0d+y1d)");
        mux_0der = xstarx_0der-x0x_0der;
        mu0_0 = xstar0_0-x00_0;
        etax_0der = x1x_0der-xstarx_0der;
        eta0_0 = x10_0-xstar0_0;
        /* Introducing 12 common subexpressions used in 12 expressions */
        /* Of the common subexpressions 12 are reals, 0 are integers, and 0
           are booleans. */

        { double helpvarF[12];
        DYNX(helpvarF,0) = xstar0_0-x00_0;
        DYNX(helpvarF,1) = sqr(DYNX(helpvarF,0));
        DYNX(helpvarF,2) = y0d0_0+y1d0_0-2*Delta00_0;
        DYNX(helpvarF,3) = xstarx_0der-x0x_0der;
        DYNX(helpvarF,4) = (y0dx_0der+y1dx_0der-2*Delta0x_0der)*DYNX(helpvarF,1)
          +2.0*DYNX(helpvarF,2)*DYNX(helpvarF,0)*DYNX(helpvarF,3);
        DYNX(helpvarF,5) = sqr(h00_0);
        DYNX(helpvarF,6) = divinvGuarded(DYNX(helpvarF,5),"h0^2");
        DYNX(helpvarF,7) = DYNX(helpvarF,2)*DYNX(helpvarF,1)*h00_0*h0x_0der;
        DYNX(helpvarF,8) = sqr(DYNX(helpvarF,5));
        DYNX(helpvarF,9) = (-2)*y0d0_0-y1d0_0+3*Delta00_0;
        DYNX(helpvarF,10) = ((-2)*y0dx_0der-y1dx_0der+3*Delta0x_0der)*
          DYNX(helpvarF,0)+DYNX(helpvarF,9)*DYNX(helpvarF,3);
        DYNX(helpvarF,11) = DYNX(helpvarF,9)*DYNX(helpvarF,0)*h0x_0der;
        omegax_0der = DYNX(helpvarF,6)*3.0*DYNX(helpvarF,4)-divGuarded(6.0*
          DYNX(helpvarF,7),"6.0*((y0d+y1d-2*Delta0)*(xstar-x0)^2*(h0*h0_der))",
          DYNX(helpvarF,8),"(h0^2)^2")+divGuarded(2.0*DYNX(helpvarF,10),
          "2.0*(((-2)*y0d_der-y1d_der+3*Delta0_der)*(xstar-x0)+((-2)*y0d-y1d+3*Delta0)*(xstar_der-x0_der))",
          h00_0,"h0")-DYNX(helpvarF,6)*2.0*DYNX(helpvarF,11)+y0dx_0der;
        }
        omega0_0 = divGuarded(3.0*(y0d0_0+y1d0_0-2*Delta00_0)*sqr(xstar0_0-x00_0),
          "3.0*((y0d+y1d-2*Delta0)*(xstar-x0)^2)",sqr(h00_0),"h0^2")+divGuarded(
          2.0*((-2)*y0d0_0-y1d0_0+3*Delta00_0)*(xstar0_0-x00_0),"2.0*(((-2)*y0d-y1d+3*Delta0)*(xstar-x0))",
          h00_0,"h0")+y0d0_0;
        aux01x_0der = 0.25*(IF Delta00_0 > 0 THEN 1 ELSE IF Delta00_0 < 0 THEN -1
           ELSE 0)*(IF fabs(omega0_0) < fabs(Delta00_0) THEN omegax_0der*(IF 
          omega0_0 > 0 THEN 1 ELSE -1) ELSE Delta0x_0der*(IF Delta00_0 > 0 THEN 1
           ELSE -1));
        aux010_0 = 0.25*(IF Delta00_0 > 0 THEN 1 ELSE IF Delta00_0 < 0 THEN -1
           ELSE 0)*RealBmin(fabs(omega0_0), fabs(Delta00_0));
        if (fabs(y0d0_0-y1d0_0) <= 1E-13) {
          aux02x_0der = y0dx_0der;
          aux020_0 = y0d0_0;
          if (y10_0 > y00_0+y0d0_0*(x10_0-x00_0)) {
            useSingleCubicPolynomial0_0 = true;
          }
        }
        else if (fabs(y1d0_0+y0d0_0-2*Delta00_0) < 1E-13) {
          aux02x_0der = 1E+60*(6.0*(Delta0x_0der*(y1d0_0+y0d0_0-1.5*Delta00_0)+
            Delta00_0*(y1dx_0der+y0dx_0der-1.5*Delta0x_0der))-(y1dx_0der*y0d0_0+
            y1d0_0*y0dx_0der)-2.0*y1d0_0*y1dx_0der-2.0*y0d0_0*y0dx_0der)*(IF 
            y1d0_0+y0d0_0-2*Delta00_0 >= 0 THEN 1 ELSE -1);
          aux020_0 = 1E+60*(6.0*Delta00_0*(y1d0_0+y0d0_0-1.5*Delta00_0)-y1d0_0*
            y0d0_0-sqr(y1d0_0)-sqr(y0d0_0))*(IF y1d0_0+y0d0_0-2*Delta00_0 >= 0
             THEN 1 ELSE -1);
        }
        else{
          /* Introducing 11 common subexpressions used in 6 expressions */
          /* Of the common subexpressions 11 are reals, 0 are integers, and 0
             are booleans. */

          { double helpvarF[11];
          DYNX(helpvarF,0) = y1d0_0+y0d0_0;
          DYNX(helpvarF,1) = DYNX(helpvarF,0)-1.5*Delta00_0;
          DYNX(helpvarF,2) = y1dx_0der+y0dx_0der;
          DYNX(helpvarF,3) = 6.0*(Delta0x_0der*DYNX(helpvarF,1)+Delta00_0*(
            DYNX(helpvarF,2)-1.5*Delta0x_0der));
          DYNX(helpvarF,4) = y1dx_0der*y0d0_0+y1d0_0*y0dx_0der;
          DYNX(helpvarF,5) = y1d0_0*y1dx_0der;
          DYNX(helpvarF,6) = 3*(DYNX(helpvarF,0)-2*Delta00_0);
          DYNX(helpvarF,7) = 6.0*Delta00_0*DYNX(helpvarF,1)-y1d0_0*y0d0_0-sqr(
            y1d0_0);
          DYNX(helpvarF,8) = sqr(y0d0_0);
          DYNX(helpvarF,9) = 2*Delta0x_0der;
          DYNX(helpvarF,10) = sqr(DYNX(helpvarF,6));
          aux02x_0der = divGuarded(DYNX(helpvarF,3)-DYNX(helpvarF,4)-2.0*
            DYNX(helpvarF,5)-2.0*y0d0_0*y0dx_0der,"6.0*(Delta0_der*(y1d+y0d-1.5*Delta0)+Delta0*(y1d_der+y0d_der-1.5*Delta0_der))-(y1d_der*y0d+y1d*y0d_der)-2.0*(y1d*y1d_der)-2.0*(y0d*y0d_der)",
            DYNX(helpvarF,6),"3*(y1d+y0d-2*Delta0)")-divGuarded(3.0*(
            DYNX(helpvarF,7)-DYNX(helpvarF,8))*(DYNX(helpvarF,2)-
            DYNX(helpvarF,9)),"3.0*((6.0*(Delta0*(y1d+y0d-1.5*Delta0))-y1d*y0d-y1d^2-y0d^2)*(y1d_der+y0d_der-2*Delta0_der))",
            DYNX(helpvarF,10),"(3*(y1d+y0d-2*Delta0))^2");
          }
          aux020_0 = divGuarded(6.0*Delta00_0*(y1d0_0+y0d0_0-1.5*Delta00_0)-
            y1d0_0*y0d0_0-sqr(y1d0_0)-sqr(y0d0_0),"6.0*(Delta0*(y1d+y0d-1.5*Delta0))-y1d*y0d-y1d^2-y0d^2",3
            *(y1d0_0+y0d0_0-2*Delta00_0),"3*(y1d+y0d-2*Delta0)");
        }
        if ((mu0_0 > 0 AND eta0_0 < h00_0 AND Delta00_0*omega0_0 <= 0 OR fabs(
          aux010_0) < fabs(aux020_0) AND aux020_0*Delta00_0 >= 0 OR fabs(
          aux010_0) < fabs(0.1*Delta00_0)) AND  NOT useSingleCubicPolynomial0_0)
           {
          cx_0der = aux01x_0der;
          c0_0 = aux010_0;
          if (fabs(c0_0) < fabs(aux020_0) AND aux020_0*Delta00_0 >= 0) {
            cx_0der = aux02x_0der;
            c0_0 = aux020_0;
          }
          if (fabs(c0_0) < fabs(0.1*Delta00_0)) {
            cx_0der = 0.1*Delta0x_0der;
            c0_0 = 0.1*Delta00_0;
          }
          theta0x_0der = divGuarded(y0dx_0der*mu0_0+y0d0_0*mux_0der+y1dx_0der*
            eta0_0+y1d0_0*etax_0der,"y0d_der*mu+y0d*mu_der+y1d_der*eta+y1d*eta_der",
            h00_0,"h0")-divGuarded((y0d0_0*mu0_0+y1d0_0*eta0_0)*h0x_0der,
            "(y0d*mu+y1d*eta)*h0_der",sqr(h00_0),"h0^2");
          theta00_0 = divGuarded(y0d0_0*mu0_0+y1d0_0*eta0_0,"y0d*mu+y1d*eta",
            h00_0,"h0");
          if (fabs(theta00_0-c0_0) < 1E-06) {
            cx_0der = 0.999999*theta0x_0der;
            c0_0 = 0.999999*theta00_0;
          }
          rhox_0der = divGuarded(3*(Delta0x_0der-cx_0der),"3*(Delta0_der-c_der)",
            theta00_0-c0_0,"theta0-c")-divGuarded(3.0*(Delta00_0-c0_0)*(
            theta0x_0der-cx_0der),"3.0*((Delta0-c)*(theta0_der-c_der))",sqr(
            theta00_0-c0_0),"(theta0-c)^2");
          rho0_0 = divGuarded(3*(Delta00_0-c0_0),"3*(Delta0-c)",theta00_0-c0_0,
            "theta0-c");
          mux_0tildex_0der = rhox_0der*mu0_0+rho0_0*mux_0der;
          mux_0tilde = rho0_0*mu0_0;
          etax_0tildex_0der = rhox_0der*eta0_0+rho0_0*etax_0der;
          etax_0tilde = rho0_0*eta0_0;
          xi1x_0der = x0x_0der+mux_0tildex_0der;
          xi10_0 = x00_0+mux_0tilde;
          xi2x_0der = x1x_0der-etax_0tildex_0der;
          xi20_0 = x10_0-etax_0tilde;
          a1x_0der = divGuarded(y0dx_0der-cx_0der,"y0d_der-c_der",RealBmax(sqr(
            mux_0tilde), 1E-13),"max(mu_tilde^2, 1E-13)")-divGuarded((y0d0_0-
            c0_0)*(IF sqr(mux_0tilde) > 1E-13 THEN 2.0*mux_0tilde*
            mux_0tildex_0der ELSE 0.0),"(y0d-c)*(if noEvent(mu_tilde^2 > 1E-13) then 2.0*(mu_tilde*mu_tilde_der) else 0.0)",
            sqr(RealBmax(sqr(mux_0tilde), 1E-13)),"max(mu_tilde^2, 1E-13)^2");
          a10_0 = divGuarded(y0d0_0-c0_0,"y0d-c",RealBmax(sqr(mux_0tilde), 1E-13),
            "max(mu_tilde^2, 1E-13)");
          a2x_0der = divGuarded(y1dx_0der-cx_0der,"y1d_der-c_der",RealBmax(sqr(
            etax_0tilde), 1E-13),"max(eta_tilde^2, 1E-13)")-divGuarded((y1d0_0-
            c0_0)*(IF sqr(etax_0tilde) > 1E-13 THEN 2.0*etax_0tilde*
            etax_0tildex_0der ELSE 0.0),"(y1d-c)*(if noEvent(eta_tilde^2 > 1E-13) then 2.0*(eta_tilde*eta_tilde_der) else 0.0)",
            sqr(RealBmax(sqr(etax_0tilde), 1E-13)),"max(eta_tilde^2, 1E-13)^2");
          a20_0 = divGuarded(y1d0_0-c0_0,"y1d-c",RealBmax(sqr(etax_0tilde), 
            1E-13),"max(eta_tilde^2, 1E-13)");
          const12x_0der = y0x_0der-0.3333333333333333*(a1x_0der*powUnguarded(
            x00_0-xi10_0, 3)+3.0*a10_0*sqr(x00_0-xi10_0)*(x0x_0der-xi1x_0der))-(
            cx_0der*x00_0+c0_0*x0x_0der);
          const120_0 = y00_0-0.3333333333333333*a10_0*powUnguarded(x00_0-xi10_0,
             3)-c0_0*x00_0;
          const3x_0der = y1x_0der-0.3333333333333333*(a2x_0der*powUnguarded(
            x10_0-xi20_0, 3)+3.0*a20_0*sqr(x10_0-xi20_0)*(x1x_0der-xi2x_0der))-(
            cx_0der*x10_0+c0_0*x1x_0der);
          const30_0 = y10_0-0.3333333333333333*a20_0*powUnguarded(x10_0-xi20_0, 3)
            -c0_0*x10_0;
          if (x0_0 < xi10_0) {
            yx_0der = 0.3333333333333333*(a1x_0der*powUnguarded(x0_0-xi10_0, 3)+
              3.0*a10_0*sqr(x0_0-xi10_0)*(xx_0der-xi1x_0der))+cx_0der*x0_0+c0_0*
              xx_0der+const12x_0der;
          }
          else if (x0_0 < xi20_0) {
            yx_0der = cx_0der*x0_0+c0_0*xx_0der+const12x_0der;
          }
          else{
            yx_0der = 0.3333333333333333*(a2x_0der*powUnguarded(x0_0-xi20_0, 3)+
              3.0*a20_0*sqr(x0_0-xi20_0)*(xx_0der-xi2x_0der))+cx_0der*x0_0+c0_0*
              xx_0der+const3x_0der;
          }
        }
        else{
          /* Introducing 16 common subexpressions used in 16 expressions */
          /* Of the common subexpressions 16 are reals, 0 are integers, and 0
             are booleans. */

          { double helpvarF[16];
          DYNX(helpvarF,0) = xx_0der-x0x_0der;
          DYNX(helpvarF,1) = x0_0-x00_0;
          DYNX(helpvarF,2) = y0d0_0+y1d0_0-2*Delta00_0;
          DYNX(helpvarF,3) = DYNX(helpvarF,1)*DYNX(helpvarF,2);
          DYNX(helpvarF,4) = divinvGuarded(h00_0,"h0");
          DYNX(helpvarF,5) = (-2)*y0d0_0-y1d0_0+3*Delta00_0+DYNX(helpvarF,4)*
            DYNX(helpvarF,3);
          DYNX(helpvarF,6) = DYNX(helpvarF,1)*DYNX(helpvarF,5);
          DYNX(helpvarF,7) = DYNX(helpvarF,4)*DYNX(helpvarF,6);
          DYNX(helpvarF,8) = (-2)*y0dx_0der;
          DYNX(helpvarF,9) = DYNX(helpvarF,0)*DYNX(helpvarF,2)+DYNX(helpvarF,1)*
            (y0dx_0der+y1dx_0der-2*Delta0x_0der);
          DYNX(helpvarF,10) = DYNX(helpvarF,3)*h0x_0der;
          DYNX(helpvarF,11) = sqr(h00_0);
          DYNX(helpvarF,12) = divinvGuarded(DYNX(helpvarF,11),"h0^2");
          DYNX(helpvarF,13) = DYNX(helpvarF,12)*DYNX(helpvarF,10);
          DYNX(helpvarF,14) = DYNX(helpvarF,4)*(DYNX(helpvarF,0)*
            DYNX(helpvarF,5)+DYNX(helpvarF,1)*(DYNX(helpvarF,8)-y1dx_0der+3*
            Delta0x_0der+DYNX(helpvarF,4)*DYNX(helpvarF,9)-DYNX(helpvarF,13)));
          DYNX(helpvarF,15) = DYNX(helpvarF,12)*DYNX(helpvarF,6)*h0x_0der;
          yx_0der = y0x_0der+DYNX(helpvarF,0)*(y0d0_0+DYNX(helpvarF,7))+
            DYNX(helpvarF,1)*(y0dx_0der+DYNX(helpvarF,14)-DYNX(helpvarF,15));
          }
          y0_0 = y00_0+(x0_0-x00_0)*(y0d0_0+divGuarded((x0_0-x00_0)*((-2)*y0d0_0
            -y1d0_0+3*Delta00_0+divGuarded((x0_0-x00_0)*(y0d0_0+y1d0_0-2*
            Delta00_0),"(x-x0)*(y0d+y1d-2*Delta0)",h00_0,"h0")),"(x-x0)*((-2)*y0d-y1d+3*Delta0+(x-x0)*(y0d+y1d-2*Delta0)/h0)",
            h00_0,"h0"));
          aux01x_0der = 0.5*(x0x_0der+x1x_0der);
          aux010_0 = 0.5*(x00_0+x10_0);
          /* Introducing 12 common subexpressions used in 12 expressions */
          /* Of the common subexpressions 12 are reals, 0 are integers, and 0
             are booleans. */

          { double helpvarF[12];
          DYNX(helpvarF,0) = aux010_0-x00_0;
          DYNX(helpvarF,1) = sqr(DYNX(helpvarF,0));
          DYNX(helpvarF,2) = y0d0_0+y1d0_0-2*Delta00_0;
          DYNX(helpvarF,3) = aux01x_0der-x0x_0der;
          DYNX(helpvarF,4) = (y0dx_0der+y1dx_0der-2*Delta0x_0der)*
            DYNX(helpvarF,1)+2.0*DYNX(helpvarF,2)*DYNX(helpvarF,0)*
            DYNX(helpvarF,3);
          DYNX(helpvarF,5) = sqr(h00_0);
          DYNX(helpvarF,6) = divinvGuarded(DYNX(helpvarF,5),"h0^2");
          DYNX(helpvarF,7) = DYNX(helpvarF,2)*DYNX(helpvarF,1)*h00_0*h0x_0der;
          DYNX(helpvarF,8) = sqr(DYNX(helpvarF,5));
          DYNX(helpvarF,9) = (-2)*y0d0_0-y1d0_0+3*Delta00_0;
          DYNX(helpvarF,10) = ((-2)*y0dx_0der-y1dx_0der+3*Delta0x_0der)*
            DYNX(helpvarF,0)+DYNX(helpvarF,9)*DYNX(helpvarF,3);
          DYNX(helpvarF,11) = DYNX(helpvarF,9)*DYNX(helpvarF,0)*h0x_0der;
          cx_0der = DYNX(helpvarF,6)*3.0*DYNX(helpvarF,4)-divGuarded(6.0*
            DYNX(helpvarF,7),"6.0*((y0d+y1d-2*Delta0)*(aux01-x0)^2*(h0*h0_der))",
            DYNX(helpvarF,8),"(h0^2)^2")+divGuarded(2.0*DYNX(helpvarF,10),
            "2.0*(((-2)*y0d_der-y1d_der+3*Delta0_der)*(aux01-x0)+((-2)*y0d-y1d+3*Delta0)*(aux01_der-x0_der))",
            h00_0,"h0")-DYNX(helpvarF,6)*2.0*DYNX(helpvarF,11)+y0dx_0der;
          }
        }
      }
    /* Output section */
    DYNJSetStringMark(retSMark_, DYNStackData_);
    DYNJPopContext(DYNStackData_)
    {
      struct Modelica_Fluid_Utilities_regFun3__der_struct out_;
      out_.yx_0der_0member = yx_0der;
      out_.cx_0der_0member = cx_0der;
      return out_;
    }
  }}

/* Flattened Modelica model:

function interpolateInRegion2_Unique15
discrete input Real Re(unit = "1") "Reynolds number (= independent variable)";
discrete input Real Re1(unit = "1") "Boundary Reynolds number for laminar regime";
discrete input Real Re2(unit = "1") "Boundary Reynolds number for turbulent regime";
discrete input Real Delta "Relative roughness";
discrete output Real lambda2 "Interpolated modified friction coefficient in transition regime";
protected 
discrete Real x1(start = log10(Re1)) "Lower abscissa value";
discrete Real y1(start = log10(64*Re1)) "Lower ordinate value";
discrete Real yd1(start = 1) "Left boundary slope";
discrete Real aux1(start = 1.1217826467560994);
discrete Real aux2(start = Delta/3.7+5.74/Re2^0.9);
discrete Real aux3(start = log10(aux2));
discrete Real L2(start = 0.25*(Re2/aux3)^2);
discrete Real aux4(start = 2.51/sqrt(L2)+0.27*Delta);
discrete Real aux5(start = (-2.0)*(sqrt(L2)*log10(aux4)));
discrete Real x2(start = log10(Re2)) "Upper abscissa value";
discrete Real y2(start = log10(L2)) "Upper ordinate value";
discrete Real yd2(start = 2+4*aux1/(aux2*aux3*Re2^0.9)) "Right boundary slope";
discrete Real diff_x(start = x2-x1) "Interval length";
discrete Real m(start = (y2-y1)/diff_x);
discrete Real c2(start = (3*m-2*yd1-yd2)/diff_x);
discrete Real c3(start = (yd1+yd2-2*m)/(diff_x*diff_x));
discrete Real dx(start = log10(Re/Re1));
public 
algorithm 
lambda2 := 64*Re1*(Re/Re1)^(yd1+dx*(c2+dx*c3));
annotation(Inline=false, smoothOrder=5);
end interpolateInRegion2_Unique15;

  */
DYMOLA_STATIC double   interpolateInRegion2x_0Unique15(double  Re0_0, double  
  Re10_0, double  Re20_0, double  Delta0_0, struct DYNFunctionData_* DYNStackData_)
   {
  DYNJPushContext("interpolateInRegion2_Unique15", DYNStackData_)
  {
    /* Declare outputs and temporaries */
    double   lambda20_0;
    double   x10_0;
    double   y10_0;
    double   yd10_0;
    double   aux10_0;
    double   aux20_0;
    double   aux30_0;
    double   L20_0;
    double   aux40_0;
    double   aux50_0;
    double   x20_0;
    double   y20_0;
    double   yd20_0;
    double   diffx_0x;
    double   m0_0;
    double   c20_0;
    double   c30_0;
    double   dx0_0;
    lambda20_0=0;
    x10_0 = log10Guarded(Re10_0,"Re1");
    y10_0 = log10Guarded(64*Re10_0,"64*Re1");
    yd10_0 = 1;
    aux10_0 = 1.1217826467560994;
    aux20_0 = Delta0_0/(double)(3.7)+divGuarded(5.74,"5.74",powGuarded(Re20_0,
      "Re2",0.9,"0.9"),"Re2^0.9");
    aux30_0 = log10Guarded(aux20_0,"aux2");
    L20_0 = 0.25*sqr(divGuarded(Re20_0,"Re2",aux30_0,"aux3"));
    aux40_0 = divGuarded(2.51,"2.51",sqrtGuarded(L20_0,"L2"),"sqrt(L2)")+0.27*
      Delta0_0;
    aux50_0 = (-2.0)*sqrtGuarded(L20_0,"L2")*log10Guarded(aux40_0,"aux4");
    x20_0 = log10Guarded(Re20_0,"Re2");
    y20_0 = log10Guarded(L20_0,"L2");
    yd20_0 = 2+divGuarded(4*aux10_0,"4*aux1",aux20_0*aux30_0*powGuarded(Re20_0,
      "Re2",0.9,"0.9"),"aux2*aux3*Re2^0.9");
    diffx_0x = x20_0-x10_0;
    m0_0 = divGuarded(y20_0-y10_0,"y2-y1",diffx_0x,"diff_x");
    c20_0 = divGuarded(3*m0_0-2*yd10_0-yd20_0,"3*m-2*yd1-yd2",diffx_0x,"diff_x");
    c30_0 = divGuarded(yd10_0+yd20_0-2*m0_0,"yd1+yd2-2*m",diffx_0x*diffx_0x,
      "diff_x*diff_x");
    dx0_0 = log10Guarded(divGuarded(Re0_0,"Re",Re10_0,"Re1"),"Re/Re1");
    /* Start of real code */
      lambda20_0 = 64*Re10_0*powGuarded(divGuarded(Re0_0,"Re",Re10_0,"Re1"),
        "Re/Re1",yd10_0+dx0_0*(c20_0+dx0_0*c30_0),"yd1+dx*(c2+dx*c3)");
    /* Output section */
    DYNJPopContext(DYNStackData_)
    return lambda20_0;
  }}

/* Flattened Modelica model:

function Modelica.Fluid.Pipes.BaseClasses.WallFriction.Detailed.Internal.m_flow_of_dp_fric.interpolateInRegion2_withDerivative:der
discrete input Real lambda2;
discrete input Real Re1;
discrete input Real Re2;
discrete input Real Delta;
discrete input Real dp_fric;
protected 
discrete Real Re;
discrete Real dRe_ddp;
discrete Real x1(start = log10(64*Re1));
discrete Real y1(start = log10(Re1));
discrete Real y1d(start = 1);
discrete Real aux2(start = 0.27027027027027023*Delta+5.74/Re2^0.9);
discrete Real aux3(start = log10(aux2));
discrete Real L2(start = 0.25*(Re2/aux3)^2);
discrete Real aux4(start = 2.51/sqrt(L2)+0.27*Delta);
discrete Real aux5(start = (-2.0)*(sqrt(L2)*log10(aux4)));
discrete Real x2(start = log10(L2));
discrete Real y2(start = log10(aux5));
discrete Real y2d(start = 0.5+1.0900791495771618/(aux5*aux4));
discrete Real x(start = log10(lambda2));
discrete Real y;
discrete Real dy_dx;
public 
discrete input Real lambda2_der;
discrete input Real Re1_der;
discrete input Real Re2_der;
discrete input Real Delta_der;
discrete input Real dp_fric_der;
discrete output Real Re_der;
discrete output Real dRe_ddp_der;
protected 
discrete Real x1_der(start = 64*Re1_der/(147.36544595161894*Re1));
discrete Real y1_der(start = Re1_der/(2.302585092994046*Re1));
discrete Real aux2_der(start = 0.27027027027027023*Delta_der-5.166*(Re2^(-0.09999999999999998)*Re2_der)/(Re2^0.9)^2);
discrete Real aux3_der(start = aux2_der/(2.302585092994046*aux2));
discrete Real L2_der(start = 0.5*(Re2*(Re2_der/aux3-Re2*aux3_der/aux3^2))/aux3);
discrete Real aux4_der(start = 0.27*Delta_der-1.255*L2_der/sqrt(L2)/sqrt(L2)^2);
discrete Real aux5_der(start = (-2.0)*(0.5*(L2_der*log10(aux4))/sqrt(L2)+sqrt(L2)*aux4_der/(2.302585092994046*aux4)));
discrete Real x2_der(start = L2_der/(2.302585092994046*L2));
discrete Real y2_der(start = aux5_der/(2.302585092994046*aux5));
discrete Real y2d_der(start =  -1.0900791495771618*(aux5_der*aux4+aux5*aux4_der)/(aux5*aux4)^2);
discrete Real x_der(start = lambda2_der/(2.302585092994046*lambda2));
discrete Real y_der;
discrete Real dy_dx_der;
public 
algorithm 
(y_der, dy_dx_der)  := Modelica.Fluid.Utilities.cubicHermite_withDerivative:der(x, x1, x2, y1, y2, y1d, y2d, x_der, x1_der, x2_der, y1_der, y2_der, 0.0, y2d_der);
(y, dy_dx)  := Modelica.Fluid.Utilities.cubicHermite_withDerivative(x, x1, x2, y1, y2, y1d, y2d);
Re_der := 2.302585092994046*(10^y*y_der);
Re := 10^y;
dRe_ddp_der := (Re_der*dy_dx+Re*dy_dx_der)/abs(dp_fric)-Re*dy_dx*(dp_fric_der*noEvent((if dp_fric > 0 then 1 else -1)))/abs(dp_fric)^2;
annotation(smoothOrder=0);
end Modelica.Fluid.Pipes.BaseClasses.WallFriction.Detailed.Internal.m_flow_of_dp_fric.interpolateInRegion2_withDerivative:der;

  */
DYMOLA_STATIC struct Modelica_Fluid_Pipes_BaseClasses_WallFriction_Detailed_Internal_mx_0flowx_0ofx_0dpx_0fric_interpolateInRegion2x_0withDerivative__der_struct
   Modelica_Fluid_Pipes_BaseClasses_WallFriction_Detailed_Internal_mx_0flowx_0ofx_0dpx_0fric_interpolateInRegion2x_0withDerivative__der
  (double  lambda20_0, double  Re10_0, double  Re20_0, double  Delta0_0, double 
   dpx_0fric, double  lambda2x_0der, double  Re1x_0der, double  Re2x_0der, 
  double  Deltax_0der, double  dpx_0fricx_0der, struct DYNFunctionData_* DYNStackData_)
   {
  DYNJPushContext("Modelica.Fluid.Pipes.BaseClasses.WallFriction.Detailed.Internal.m_flow_of_dp_fric.interpolateInRegion2_withDerivative:der",
     DYNStackData_)
  {
    /* Declare outputs and temporaries */
    double   Re0_0;
    double   dRex_0ddp;
    double   x10_0;
    double   y10_0;
    double   y1d0_0;
    double   aux20_0;
    double   aux30_0;
    double   L20_0;
    double   aux40_0;
    double   aux50_0;
    double   x20_0;
    double   y20_0;
    double   y2d0_0;
    double   x0_0;
    double   y0_0;
    double   dyx_0dx;
    double   Rex_0der;
    double   dRex_0ddpx_0der;
    double   x1x_0der;
    double   y1x_0der;
    double   aux2x_0der;
    double   aux3x_0der;
    double   L2x_0der;
    double   aux4x_0der;
    double   aux5x_0der;
    double   x2x_0der;
    double   y2x_0der;
    double   y2dx_0der;
    double   xx_0der;
    double   yx_0der;
    double   dyx_0dxx_0der;
    Re0_0=0;
    dRex_0ddp=0;
    x10_0 = log10Guarded(64*Re10_0,"64*Re1");
    y10_0 = log10Guarded(Re10_0,"Re1");
    y1d0_0 = 1;
    aux20_0 = 0.27027027027027023*Delta0_0+divGuarded(5.74,"5.74",powGuarded(
      Re20_0,"Re2",0.9,"0.9"),"Re2^0.9");
    aux30_0 = log10Guarded(aux20_0,"aux2");
    L20_0 = 0.25*sqr(divGuarded(Re20_0,"Re2",aux30_0,"aux3"));
    aux40_0 = divGuarded(2.51,"2.51",sqrtGuarded(L20_0,"L2"),"sqrt(L2)")+0.27*
      Delta0_0;
    aux50_0 = (-2.0)*sqrtGuarded(L20_0,"L2")*log10Guarded(aux40_0,"aux4");
    x20_0 = log10Guarded(L20_0,"L2");
    y20_0 = log10Guarded(aux50_0,"aux5");
    y2d0_0 = 0.5+divGuarded(1.0900791495771618,"1.0900791495771618",aux50_0*
      aux40_0,"aux5*aux4");
    x0_0 = log10Guarded(lambda20_0,"lambda2");
    y0_0=0;
    dyx_0dx=0;
    Rex_0der=0;
    dRex_0ddpx_0der=0;
    x1x_0der = divGuarded(64*Re1x_0der,"64*Re1_der",147.36544595161894*Re10_0,
      "147.36544595161894*Re1");
    y1x_0der = divGuarded(Re1x_0der,"Re1_der",2.302585092994046*Re10_0,
      "2.302585092994046*Re1");
    aux2x_0der = 0.27027027027027023*Deltax_0der-divGuarded(5.166*powGuarded(
      Re20_0,"Re2",-0.09999999999999998,"-0.09999999999999998")*Re2x_0der,
      "5.166*(Re2^(-0.09999999999999998)*Re2_der)",sqr(powGuarded(Re20_0,"Re2",
      0.9,"0.9")),"(Re2^0.9)^2");
    aux3x_0der = divGuarded(aux2x_0der,"aux2_der",2.302585092994046*aux20_0,
      "2.302585092994046*aux2");
    L2x_0der = divGuarded(0.5*Re20_0*(divGuarded(Re2x_0der,"Re2_der",aux30_0,
      "aux3")-divGuarded(Re20_0*aux3x_0der,"Re2*aux3_der",sqr(aux30_0),"aux3^2")),
      "0.5*(Re2*(Re2_der/aux3-Re2*aux3_der/aux3^2))",aux30_0,"aux3");
    aux4x_0der = 0.27*Deltax_0der-divGuarded(divGuarded(1.255*L2x_0der,
      "1.255*L2_der",sqrtGuarded(L20_0,"L2"),"sqrt(L2)"),"1.255*L2_der/sqrt(L2)",
      sqr(sqrtGuarded(L20_0,"L2")),"sqrt(L2)^2");
    aux5x_0der = (-2.0)*(divGuarded(0.5*L2x_0der*log10Guarded(aux40_0,"aux4"),
      "0.5*(L2_der*log10(aux4))",sqrtGuarded(L20_0,"L2"),"sqrt(L2)")+divGuarded(
      sqrtGuarded(L20_0,"L2")*aux4x_0der,"sqrt(L2)*aux4_der",2.302585092994046*
      aux40_0,"2.302585092994046*aux4"));
    x2x_0der = divGuarded(L2x_0der,"L2_der",2.302585092994046*L20_0,
      "2.302585092994046*L2");
    y2x_0der = divGuarded(aux5x_0der,"aux5_der",2.302585092994046*aux50_0,
      "2.302585092994046*aux5");
    y2dx_0der =  -divGuarded(1.0900791495771618*(aux5x_0der*aux40_0+aux50_0*
      aux4x_0der),"1.0900791495771618*(aux5_der*aux4+aux5*aux4_der)",sqr(aux50_0
      *aux40_0),"(aux5*aux4)^2");
    xx_0der = divGuarded(lambda2x_0der,"lambda2_der",2.302585092994046*
      lambda20_0,"2.302585092994046*lambda2");
    yx_0der=0;
    dyx_0dxx_0der=0;
    /* Start of real code */
      {
        struct Modelica_Fluid_Utilities_cubicHermitex_0withDerivative__der_struct
           dummy_mult_=Modelica_Fluid_Utilities_cubicHermitex_0withDerivative__der
          (x0_0, x10_0, x20_0, y10_0, y20_0, y1d0_0, y2d0_0, xx_0der, x1x_0der, 
          x2x_0der, y1x_0der, y2x_0der, 0.0, y2dx_0der, DYNStackData_);
        yx_0der = dummy_mult_.yx_0der_0member;
        dyx_0dxx_0der = dummy_mult_.dyx_0dxx_0der_0member;
      }
      {
        struct Modelica_Fluid_Utilities_cubicHermitex_0withDerivative_struct
           dummy_mult_=Modelica_Fluid_Utilities_cubicHermitex_0withDerivative(
          x0_0, x10_0, x20_0, y10_0, y20_0, y1d0_0, y2d0_0, DYNStackData_);
        y0_0 = dummy_mult_.y0_0_0member;
        dyx_0dx = dummy_mult_.dyx_0dx_0member;
      }
      Rex_0der = 2.302585092994046*powGuarded(10,"10",y0_0,"y")*yx_0der;
      Re0_0 = powGuarded(10,"10",y0_0,"y");
      dRex_0ddpx_0der = divGuarded(Rex_0der*dyx_0dx+Re0_0*dyx_0dxx_0der,
        "Re_der*dy_dx+Re*dy_dx_der",fabs(dpx_0fric),"abs(dp_fric)")-divGuarded(
        Re0_0*dyx_0dx*dpx_0fricx_0der*(IF dpx_0fric > 0 THEN 1 ELSE -1),
        "Re*dy_dx*(dp_fric_der*noEvent((if dp_fric > 0 then 1 else -1)))",sqr(
        fabs(dpx_0fric)),"abs(dp_fric)^2");
    /* Output section */
    DYNJPopContext(DYNStackData_)
    {
      struct Modelica_Fluid_Pipes_BaseClasses_WallFriction_Detailed_Internal_mx_0flowx_0ofx_0dpx_0fric_interpolateInRegion2x_0withDerivative__der_struct out_;
      out_.Rex_0der_0member = Rex_0der;
      out_.dRex_0ddpx_0der_0member = dRex_0ddpx_0der;
      return out_;
    }
  }}

/* Flattened Modelica model:

function Modelica.Fluid.Utilities.cubicHermite_withDerivative:der
discrete input Real x;
discrete input Real x1;
discrete input Real x2;
discrete input Real y1;
discrete input Real y2;
discrete input Real y1d;
discrete input Real y2d;
protected 
discrete Real y;
discrete Real dy_dx;
discrete Real h;
discrete Real t;
discrete Real h00;
discrete Real h10;
discrete Real h01;
discrete Real h11;
discrete Real h00d;
discrete Real h10d;
discrete Real h01d;
discrete Real h11d;
discrete Real aux3;
discrete Real aux2;
public 
discrete input Real x_der;
discrete input Real x1_der;
discrete input Real x2_der;
discrete input Real y1_der;
discrete input Real y2_der;
discrete input Real y1d_der;
discrete input Real y2d_der;
discrete output Real y_der;
discrete output Real dy_dx_der;
protected 
discrete Real h_der;
discrete Real t_der;
discrete Real h00_der;
discrete Real h10_der;
discrete Real h01_der;
discrete Real h11_der;
discrete Real h00d_der;
discrete Real h10d_der;
discrete Real h01d_der;
discrete Real h11d_der;
discrete Real aux3_der;
discrete Real aux2_der;
public 
algorithm 
h_der := x2_der-x1_der;
h := x2-x1;
if (abs(h) > 0) then 
t_der := (x_der-x1_der)/h-(x-x1)*h_der/h^2;
t := (x-x1)/h;
aux3_der := 3.0*(t^2*t_der);
aux3 := t^3;
aux2_der := 2.0*(t*t_der);
aux2 := t^2;
h00_der := 2*aux3_der-3*aux2_der;
h00 := 1+2*aux3-3*aux2;
h10_der := aux3_der-2*aux2_der+t_der;
h10 := aux3-2*aux2+t;
h01_der := 3*aux2_der-2*aux3_der;
h01 := 3*aux2-2*aux3;
h11_der := aux3_der-aux2_der;
h11 := aux3-aux2;
h00d_der := 6*(aux2_der-t_der);
h00d := 6*(aux2-t);
h10d_der := 3*aux2_der-4*t_der;
h10d := 1+3*aux2-4*t;
h01d_der := 6*(t_der-aux2_der);
h01d := 6*(t-aux2);
h11d_der := 3*aux2_der-2*t_der;
h11d := 3*aux2-2*t;
y_der := y1_der*h00+y1*h00_der+(h_der*y1d+h*y1d_der)*h10+h*y1d*h10_der+y2_der*h01+y2*h01_der+(h_der*y2d+h*y2d_der)*h11+h*y2d*h11_der;
y := y1*h00+h*y1d*h10+y2*h01+h*y2d*h11;
dy_dx_der := (y1_der*h00d+y1*h00d_der)/h-y1*h00d*h_der/h^2+y1d_der*h10d+y1d*h10d_der+(y2_der*h01d+y2*h01d_der)/h-y2*h01d*h_der/h^2+y2d_der*h11d+y2d*h11d_der;
else
y_der := 0.5*(y1_der+y2_der);
y := 0.5*(y1+y2);
dy_dx_der := 0.0;
end if;
annotation(smoothOrder=2);
end Modelica.Fluid.Utilities.cubicHermite_withDerivative:der;

  */
DYMOLA_STATIC struct Modelica_Fluid_Utilities_cubicHermitex_0withDerivative__der_struct
   Modelica_Fluid_Utilities_cubicHermitex_0withDerivative__der(double  x0_0, 
  double  x10_0, double  x20_0, double  y10_0, double  y20_0, double  y1d0_0, 
  double  y2d0_0, double  xx_0der, double  x1x_0der, double  x2x_0der, double  
  y1x_0der, double  y2x_0der, double  y1dx_0der, double  y2dx_0der, 
  struct DYNFunctionData_* DYNStackData_) {
  DYNJPushContext("Modelica.Fluid.Utilities.cubicHermite_withDerivative:der", 
    DYNStackData_)
  {
    /* Declare outputs and temporaries */
    double   y0_0;
    double   dyx_0dx;
    double   h0_0;
    double   t0_0;
    double   h000_0;
    double   h100_0;
    double   h010_0;
    double   h110_0;
    double   h00d0_0;
    double   h10d0_0;
    double   h01d0_0;
    double   h11d0_0;
    double   aux30_0;
    double   aux20_0;
    double   yx_0der;
    double   dyx_0dxx_0der;
    double   hx_0der;
    double   tx_0der;
    double   h00x_0der;
    double   h10x_0der;
    double   h01x_0der;
    double   h11x_0der;
    double   h00dx_0der;
    double   h10dx_0der;
    double   h01dx_0der;
    double   h11dx_0der;
    double   aux3x_0der;
    double   aux2x_0der;
    y0_0=0;
    dyx_0dx=0;
    h0_0=0;
    t0_0=0;
    h000_0=0;
    h100_0=0;
    h010_0=0;
    h110_0=0;
    h00d0_0=0;
    h10d0_0=0;
    h01d0_0=0;
    h11d0_0=0;
    aux30_0=0;
    aux20_0=0;
    yx_0der=0;
    dyx_0dxx_0der=0;
    hx_0der=0;
    tx_0der=0;
    h00x_0der=0;
    h10x_0der=0;
    h01x_0der=0;
    h11x_0der=0;
    h00dx_0der=0;
    h10dx_0der=0;
    h01dx_0der=0;
    h11dx_0der=0;
    aux3x_0der=0;
    aux2x_0der=0;
    /* Start of real code */
      hx_0der = x2x_0der-x1x_0der;
      h0_0 = x20_0-x10_0;
      if (fabs(h0_0) > 0) {
        tx_0der = divGuarded(xx_0der-x1x_0der,"x_der-x1_der",h0_0,"h")-
          divGuarded((x0_0-x10_0)*hx_0der,"(x-x1)*h_der",sqr(h0_0),"h^2");
        t0_0 = divGuarded(x0_0-x10_0,"x-x1",h0_0,"h");
        aux3x_0der = 3.0*sqr(t0_0)*tx_0der;
        aux30_0 = powUnguarded(t0_0, 3);
        aux2x_0der = 2.0*t0_0*tx_0der;
        aux20_0 = sqr(t0_0);
        h00x_0der = 2*aux3x_0der-3*aux2x_0der;
        h000_0 = 1+2*aux30_0-3*aux20_0;
        h10x_0der = aux3x_0der-2*aux2x_0der+tx_0der;
        h100_0 = aux30_0-2*aux20_0+t0_0;
        h01x_0der = 3*aux2x_0der-2*aux3x_0der;
        h010_0 = 3*aux20_0-2*aux30_0;
        h11x_0der = aux3x_0der-aux2x_0der;
        h110_0 = aux30_0-aux20_0;
        h00dx_0der = 6*(aux2x_0der-tx_0der);
        h00d0_0 = 6*(aux20_0-t0_0);
        h10dx_0der = 3*aux2x_0der-4*tx_0der;
        h10d0_0 = 1+3*aux20_0-4*t0_0;
        h01dx_0der = 6*(tx_0der-aux2x_0der);
        h01d0_0 = 6*(t0_0-aux20_0);
        h11dx_0der = 3*aux2x_0der-2*tx_0der;
        h11d0_0 = 3*aux20_0-2*t0_0;
        yx_0der = y1x_0der*h000_0+y10_0*h00x_0der+(hx_0der*y1d0_0+h0_0*y1dx_0der)
          *h100_0+h0_0*y1d0_0*h10x_0der+y2x_0der*h010_0+y20_0*h01x_0der+(hx_0der
          *y2d0_0+h0_0*y2dx_0der)*h110_0+h0_0*y2d0_0*h11x_0der;
        y0_0 = y10_0*h000_0+h0_0*y1d0_0*h100_0+y20_0*h010_0+h0_0*y2d0_0*h110_0;
        dyx_0dxx_0der = divGuarded(y1x_0der*h00d0_0+y10_0*h00dx_0der,
          "y1_der*h00d+y1*h00d_der",h0_0,"h")-divGuarded(y10_0*h00d0_0*hx_0der,
          "y1*h00d*h_der",sqr(h0_0),"h^2")+y1dx_0der*h10d0_0+y1d0_0*h10dx_0der+
          divGuarded(y2x_0der*h01d0_0+y20_0*h01dx_0der,"y2_der*h01d+y2*h01d_der",
          h0_0,"h")-divGuarded(y20_0*h01d0_0*hx_0der,"y2*h01d*h_der",sqr(h0_0),
          "h^2")+y2dx_0der*h11d0_0+y2d0_0*h11dx_0der;
      }
      else{
        yx_0der = 0.5*(y1x_0der+y2x_0der);
        y0_0 = 0.5*(y10_0+y20_0);
        dyx_0dxx_0der = 0.0;
      }
    /* Output section */
    DYNJPopContext(DYNStackData_)
    {
      struct Modelica_Fluid_Utilities_cubicHermitex_0withDerivative__der_struct out_;
      out_.yx_0der_0member = yx_0der;
      out_.dyx_0dxx_0der_0member = dyx_0dxx_0der;
      return out_;
    }
  }}
/* DSblock C-code: */

BreakSectionFunctionDef(1)
BreakSectionFunctionDef(2)
  BreakSectionDef(3);
BreakSectionFunctionDef(4)
#define NX_    1
#define NX2_   4
#define NU_    2
#define NY_    5
#define NW_    353
#define NWP_   280
#define NP_    63
#define NPS_   0
#define ND_   0
#define NXP_   0
#define NInitial_   3
#define MAXAuxStr_   0
#define MAXAuxStrLen_   500
#define NHash1_ -1575954286
#define NHash2_ 1708967930
#define NHash3_ 364685085
#define NI_    0
#define NRelF_ 5
#define NRel_  5
#define NTim_  0
#define NSamp_ 0
#define NCons_ 0
#define NA_    138
#define SizePre_ 3
#define SizeEq_ 4
#define SizeDelay_ 4
#define QNLmax_ 3
#define MAXAux 24
#define NrDymolaTimers_ 0
#define NWhen_ 0
#define NCheckIf_ 0
#define NGlobalHelp_ 351
#define NGlobalHelpI_ 76
#define NSparse_ 0
#ifndef NExternalObject_
#define NExternalObject_ 0
#endif
#include <moutil.c>
DYMOLA_STATIC unsigned int FMIClockValueReferences_[1]={0};
DYMOLA_STATIC unsigned int FMIClockFirstValueReferences_[1]={0};
PreNonAliasDef(0)
PreNonAliasDef(1)
PreNonAliasDef(2)
PreNonAliasDef(3)
PreNonAliasDef(4)
PreNonAliasDef(5)
#if !defined(DYM2CCUR)
 DYMOLA_STATIC const char*modelName="simple_network";
#endif
DYMOLA_STATIC const char*usedLibraries[]={0};
DYMOLA_STATIC const char*dllLibraryPath[]={0};
DYMOLA_STATIC const char*default_dymosim_license_filename=
#if defined(_WIN32)
"C:/Users/Henn/AppData/Roaming/DassaultSystemes/Dymola/dymola.lic"
#else
"/mnt/c/Users/Henn/AppData/Roaming/DassaultSystemes/Dymola/dymola.lic"
#endif
;
DYMOLA_STATIC const char*GUIDString="{54f71029-a863-4d42-89d5-0ab66ef2bf64}";
DYMOLA_STATIC const double cvodeTolerance=1E-05;
#include <dsblock1.c>

/* Define variable names. */

#define Sections_
#define DIRECT_FEED_THROUGH 1

TranslatedEquations
InitialSection
#if defined(DynSimStruct)
DYNX(W_,297) = 0.0;
DYNX(W_,298) = 0.0;
DYNX(W_,300) = 100000.0;
DYNX(W_,305) = 100000.0;
DYNX(W_,309) = 288.15;
DYNX(W_,310) = 288.15;
DYNX(W_,311) = 288.15;
DYNX(W_,313) = 100000.0;
DYNX(W_,317) = 288.15;
DYNX(W_,318) = 288.15;
DYNX(W_,326) = 288.15;
DYNX(W_,327) = 288.15;
DYNX(W_,335) = 288.15;
DYNX(W_,349) = 288.15;
DYNX(W_,350) = 288.15;
DYNX(W_,351) = 288.15;
DYNX(W_,352) = 288.15;
#endif

InitialSection
#if defined(DynSimStruct)
DYNX(W_,0) = true;
DYNX(W_,11) = true;
DYNX(W_,18) = false;
DYNX(W_,21) = 2;
DYNX(W_,22) = 2;
DYNX(W_,33) = true;
DYNX(W_,40) = false;
DYNX(W_,41) = 1;
DYNX(W_,50) = 1;
DYNX(W_,54) = 1;
DYNX(W_,55) = 1;
DYNX(W_,56) = true;
DYNX(W_,57) = 1;
DYNX(W_,63) = false;
DYNX(W_,68) = 3;
DYNX(W_,74) = 1;
DYNX(W_,80) = false;
DYNX(W_,85) = 3;
DYNX(W_,91) = 1;
DYNX(W_,97) = false;
DYNX(W_,102) = 3;
memcpy(&DYNX(W_,108), &DymArrays0, sizeof(double)*3);
DYNX(W_,111) = false;
DYNX(W_,117) = true;
DYNX(W_,118) = true;
DYNX(W_,121) = true;
DYNX(W_,130) = 2;
DYNX(W_,135) = true;
DYNX(W_,136) = 4;
DYNX(W_,151) = false;
DYNX(W_,163) = true;
DYNX(W_,172) = 2;
DYNX(W_,177) = true;
DYNX(W_,178) = 4;
DYNX(W_,193) = false;
DYNX(W_,205) = true;
DYNX(W_,215) = 2;
DYNX(W_,221) = true;
DYNX(W_,222) = 4;
DYNX(W_,237) = false;
DYNX(W_,249) = true;
DYNX(W_,259) = true;
DYNX(W_,271) = true;
DYNX(W_,277) = true;
DYNX(W_,278) = true;
DYNX(W_,6) = 0;
memcpy(&DYNX(W_,1), &DymArrays1, sizeof(double)*5);
DYNX(W_,9) = false;
DYNX(W_,12) = true;
DYNX(W_,17) = 995.586;
DYNX(W_,19) = 0.1;
DYNX(W_,23) = 2;
DYNX(W_,24) = 2;
DYNX(W_,26) = true;
DYNX(W_,34) = true;
DYNX(W_,44) = false;
DYNX(W_,45) = 0;
DYNX(W_,52) = false;
DYNX(W_,64) = true;
DYNX(W_,69) = true;
DYNX(W_,71) = 995.586;
DYNX(W_,72) = true;
DYNX(W_,81) = true;
DYNX(W_,86) = true;
DYNX(W_,88) = 995.586;
DYNX(W_,89) = true;
DYNX(W_,98) = true;
DYNX(W_,103) = true;
DYNX(W_,105) = 995.586;
DYNX(W_,106) = true;
DYNX(W_,112) = false;
DYNX(W_,113) = false;
DYNX(W_,115) = 0.0;
DYNX(W_,122) = true;
DYNX(W_,128) = 0.0;
DYNX(W_,129) = true;
DYNX(W_,137) = 0.0;
DYNX(W_,140) = 1;
DYNX(W_,142) = true;
DYNX(W_,143) = false;
DYNX(W_,150) = 4000;
DYNX(W_,152) = false;
DYNX(W_,153) = false;
DYNX(W_,159) = false;
DYNX(W_,160) = false;
DYNX(W_,164) = true;
DYNX(W_,170) = 0.0;
DYNX(W_,171) = true;
DYNX(W_,179) = 0.0;
DYNX(W_,182) = 1;
DYNX(W_,184) = true;
DYNX(W_,185) = false;
DYNX(W_,192) = 4000;
DYNX(W_,194) = false;
DYNX(W_,195) = false;
DYNX(W_,201) = false;
DYNX(W_,202) = false;
DYNX(W_,207) = true;
DYNX(W_,213) = 0.0;
DYNX(W_,214) = true;
DYNX(W_,223) = 0.0;
DYNX(W_,226) = 1;
DYNX(W_,228) = true;
DYNX(W_,229) = false;
DYNX(W_,236) = 4000;
DYNX(W_,238) = false;
DYNX(W_,239) = false;
DYNX(W_,245) = false;
DYNX(W_,246) = false;
DYNX(W_,272) = false;
DYNX(W_,273) = false;
DYNX(W_,275) = 0.0;
DYNX(W_,39) = false;
DYNX(W_,36) = 0.0;
DYNX(W_,35) = 99.55860000000001;
DYNX(W_,141) = 0.0;
DYNX(W_,255) = 0;
DYNX(W_,227) = 0.0;
DYNX(W_,183) = 0.0;
DYNX(W_,265) = 0;
DYNX(W_,269) = 0;
DYNX(W_,257) = 0;
DYNX(W_,254) = 995.586;
DYNX(W_,264) = 995.586;
DYNX(W_,267) = 0;
DYNX(W_,31) = 0;
DYNX(W_,51) = 0;
DYNX(W_,61) = 0;
DYNX(W_,78) = 0;
DYNX(W_,95) = 0;
DYNX(W_,146) = 995.586;
DYNX(W_,149) = 0.001;
DYNX(W_,188) = 995.586;
DYNX(W_,191) = 0.001;
DYNX(W_,232) = 995.586;
DYNX(W_,235) = 0.001;
DYNX(W_,154) = 4000.0;
DYNX(W_,147) = 0.001;
DYNX(W_,148) = 0.001;
DYNX(W_,144) = 995.586;
DYNX(W_,145) = 995.586;
DYNX(W_,196) = 4000.0;
DYNX(W_,189) = 0.001;
DYNX(W_,190) = 0.001;
DYNX(W_,186) = 995.586;
DYNX(W_,187) = 995.586;
DYNX(W_,240) = 4000.0;
DYNX(W_,233) = 0.001;
DYNX(W_,234) = 0.001;
DYNX(W_,230) = 995.586;
DYNX(W_,231) = 995.586;
DYNX(W_,256) = 83680.0;
DYNX(W_,258) = 83680.0;
DYNX(W_,266) = 83680.0;
DYNX(W_,268) = 83680.0;
DYNX(W_,38) = 0.0;
DYNX(W_,20) = 0.1;
DYNX(W_,43) = 0.0;
DYNX(W_,47) = 0.0;
DYNX(W_,42) = 1.0418794157356093;
DYNX(W_,37) = 0.0;
DYNX(W_,32) = 0.018015268;
DYNX(W_,30) = 1.0;
DYNX(W_,29) = 995.586;
DYNX(W_,49) = 995.586;
DYNX(W_,270) = 0.0;
DYNX(W_,79) = 0.018015268;
DYNX(W_,76) = 1.0;
DYNX(W_,75) = 995.586;
DYNX(W_,62) = 0.018015268;
DYNX(W_,59) = 1.0;
DYNX(W_,58) = 995.586;
DYNX(W_,96) = 0.018015268;
DYNX(W_,93) = 1.0;
DYNX(W_,92) = 995.586;
DYNX(W_,252) = 995.586;
DYNX(W_,253) = 995.586;
DYNX(W_,262) = 995.586;
DYNX(W_,263) = 995.586;
#endif
if (!DymolaUserHomotopy) UpdateInitVars(time, X_, XD_, U_, DP_, IP_, LP_, F_, Y_, W_, QZ_, duser_, iuser_, cuser_, did_, 1);
BoundParameterSection
AssertModelica(DYNX(DP_,24) >= DYNX(DP_,27),"pipe_1.length >= pipe_1.height_ab",
   "Parameter length must be greater or equal height_ab.");
AssertModelica(DYNX(DP_,34) >= DYNX(DP_,37),"pipe_2.length >= pipe_2.height_ab",
   "Parameter length must be greater or equal height_ab.");
AssertModelica(DYNX(DP_,44) >= DYNX(DP_,47),"pipe_3.length >= pipe_3.height_ab",
   "Parameter length must be greater or equal height_ab.");
BoundParameterSection
DYNX(W_,7) = DYNX(DP_,0);
DYNX(W_,8) = DYNX(DP_,1);
DYNX(W_,10) = IF DYNX(W_,9) THEN 1 ELSE 100.0*DYNX(DP_,5);
DYNX(W_,13) = DYNX(W_,7);
DYNX(W_,14) = DYNX(W_,13);
DYNX(DYNhelp,0) = divinvGuarded(DYNX(W_,17),"pump_1.rho_nominal");
DYNX(W_,15) = DYNX(DYNhelp,0)*DYNX(DP_,8);
DYNX(W_,16) = 0.34196*DYNX(W_,15)-0.065158*sqr(DYNX(W_,15));
DYNX(W_,25) = DYNX(W_,14);
if (DYNX(W_,26)) {
  DYNX(W_,27) = DYNX(W_,8);
  DYNX(W_,28) = 4184*(DYNX(W_,27)-273.15);
}
else{
  DYNX(W_,28) = 83680.0;
  DYNX(W_,27) = 273.15+0.0002390057361376673*DYNX(W_,28);
}
DYNX(W_,46) = DYNX(DP_,1);
DYNX(W_,48) = DYNX(DP_,2);
DYNX(W_,70) = DYNX(DP_,0);
DYNX(W_,73) = DYNX(DP_,1);
AssertModelica(DYNX(W_,70) >= 0.0,"source_1.medium.p >= 0.0", StringAdd(
  StringAdd(StringAdd(StringAdd(StringAdd(StringAdd("Pressure (= ",Real2String2(
  DYNX(W_,70), true, 0))," Pa) of medium \""),"SimpleLiquidWater"),
  "\" is negative\n(Temperature = "),Real2String2(DYNX(W_,73), true, 0))," K)"));
AssertModelica(DYNX(W_,73) >= 272.15 AND DYNX(W_,73) <= 403.15,"source_1.medium.T >= 272.15 and source_1.medium.T <= 403.15",
   StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(
  StringAdd("\nTemperature T (= ",Real2String2(DYNX(W_,73), true, 0)),
  " K) is not\nin the allowed range ("),"272.15")," K <= T <= "),"403.15"),
  " K)\nrequired from medium model \""),"SimpleLiquidWater"),"\".\n"));
DYNX(W_,87) = DYNX(DP_,0);
DYNX(W_,90) = DYNX(DP_,1);
AssertModelica(DYNX(W_,87) >= 0.0,"sink_2.medium.p >= 0.0", StringAdd(StringAdd(
  StringAdd(StringAdd(StringAdd(StringAdd("Pressure (= ",Real2String2(
  DYNX(W_,87), true, 0))," Pa) of medium \""),"SimpleLiquidWater"),
  "\" is negative\n(Temperature = "),Real2String2(DYNX(W_,90), true, 0))," K)"));
AssertModelica(DYNX(W_,90) >= 272.15 AND DYNX(W_,90) <= 403.15,"sink_2.medium.T >= 272.15 and sink_2.medium.T <= 403.15",
   StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(
  StringAdd("\nTemperature T (= ",Real2String2(DYNX(W_,90), true, 0)),
  " K) is not\nin the allowed range ("),"272.15")," K <= T <= "),"403.15"),
  " K)\nrequired from medium model \""),"SimpleLiquidWater"),"\".\n"));
DYNX(W_,104) = DYNX(DP_,0);
DYNX(W_,107) = DYNX(DP_,1);
AssertModelica(DYNX(W_,104) >= 0.0,"source_4.medium.p >= 0.0", StringAdd(
  StringAdd(StringAdd(StringAdd(StringAdd(StringAdd("Pressure (= ",Real2String2(
  DYNX(W_,104), true, 0))," Pa) of medium \""),"SimpleLiquidWater"),
  "\" is negative\n(Temperature = "),Real2String2(DYNX(W_,107), true, 0))," K)"));
AssertModelica(DYNX(W_,107) >= 272.15 AND DYNX(W_,107) <= 403.15,
  "source_4.medium.T >= 272.15 and source_4.medium.T <= 403.15", StringAdd(
  StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(
  "\nTemperature T (= ",Real2String2(DYNX(W_,107), true, 0))," K) is not\nin the allowed range ("),
  "272.15")," K <= T <= "),"403.15")," K)\nrequired from medium model \""),
  "SimpleLiquidWater"),"\".\n"));
DYNX(W_,114) = 0.01*DYNX(W_,7);
DYNX(W_,116) = IF DYNX(W_,9) THEN DYNX(DP_,3)*DYNX(W_,10) ELSE DYNX(DP_,5);
DYNX(DYNhelp,1) = divinvGuarded(DYNX(DP_,18),"valve_2.dp_nominal");
DYNX(W_,120) = DYNX(DYNhelp,1)*DYNX(DP_,19);
DYNX(W_,123) = 0.7853981633974483*DYNX(DP_,25)*DYNX(DP_,25);
DYNX(W_,124) = 3.141592653589793*DYNX(DP_,25);
DYNX(W_,125) = DYNX(W_,123)*DYNX(DP_,24)*DYNX(DP_,23);
DYNX(W_,126) = DYNX(W_,7);
DYNX(W_,127) = DYNX(W_,126);
DYNX(W_,131) = DYNX(DP_,23);
DYNX(W_,134) = DYNX(DP_,2);
DYNX(W_,138) = DYNX(W_,126);
DYNX(W_,139) = DYNX(W_,127);
if (DYNX(W_,9)) {
  DYNX(W_,156) = DYNX(W_,10);
  DYNX(W_,157) = DYNX(DP_,3)*DYNX(W_,156);
}
else{
  DYNX(W_,157) = DYNX(DP_,5);
  DYNX(W_,156) = 100.0*DYNX(W_,157);
}
DYNX(W_,165) = 0.7853981633974483*DYNX(DP_,35)*DYNX(DP_,35);
DYNX(W_,166) = 3.141592653589793*DYNX(DP_,35);
DYNX(W_,167) = DYNX(W_,165)*DYNX(DP_,34)*DYNX(DP_,33);
DYNX(W_,168) = DYNX(W_,7);
DYNX(W_,169) = DYNX(W_,168);
DYNX(W_,173) = DYNX(DP_,33);
DYNX(W_,176) = DYNX(DP_,2);
DYNX(W_,180) = DYNX(W_,168);
DYNX(W_,181) = DYNX(W_,169);
if (DYNX(W_,9)) {
  DYNX(W_,198) = DYNX(W_,10);
  DYNX(W_,199) = DYNX(DP_,3)*DYNX(W_,198);
}
else{
  DYNX(W_,199) = DYNX(DP_,5);
  DYNX(W_,198) = 100.0*DYNX(W_,199);
}
DYNX(W_,208) = 0.7853981633974483*DYNX(DP_,45)*DYNX(DP_,45);
DYNX(W_,209) = 3.141592653589793*DYNX(DP_,45);
DYNX(W_,210) = DYNX(W_,208)*DYNX(DP_,44)*DYNX(DP_,43);
DYNX(W_,211) = DYNX(W_,7);
DYNX(W_,212) = DYNX(W_,211);
DYNX(W_,217) = DYNX(DP_,43);
DYNX(W_,220) = DYNX(DP_,2);
DYNX(W_,224) = DYNX(W_,211);
DYNX(W_,225) = DYNX(W_,212);
if (DYNX(W_,9)) {
  DYNX(W_,242) = DYNX(W_,10);
  DYNX(W_,243) = DYNX(DP_,3)*DYNX(W_,242);
}
else{
  DYNX(W_,243) = DYNX(DP_,5);
  DYNX(W_,242) = 100.0*DYNX(W_,243);
}
DYNX(W_,250) = DYNX(W_,10);
DYNX(W_,251) = IF DYNX(W_,9) THEN DYNX(DP_,3)*DYNX(W_,250) ELSE DYNX(DP_,5);
DYNX(W_,260) = DYNX(W_,10);
DYNX(W_,261) = IF DYNX(W_,9) THEN DYNX(DP_,3)*DYNX(W_,260) ELSE DYNX(DP_,5);
DYNX(W_,274) = 0.01*DYNX(W_,7);
DYNX(W_,276) = IF DYNX(W_,9) THEN DYNX(DP_,3)*DYNX(W_,10) ELSE DYNX(DP_,5);
DYNX(DYNhelp,2) = divinvGuarded(DYNX(DP_,60),"valveDiscreteRamp.dp_nominal");
DYNX(W_,279) = DYNX(DYNhelp,2)*DYNX(DP_,61);
BoundParameterConstantSection
DYNX(DYNhelp,3) = divinvGuarded(DYNX(W_,124),"pipe_1.perimeter");
DYNX(W_,132) = DYNX(DYNhelp,3)*4*DYNX(W_,123);
DYNX(W_,133) = DYNX(DYNhelp,3)*4*DYNX(W_,123);
DYNX(W_,161) = 0.5*(DYNX(W_,132)+DYNX(W_,133));
DYNX(DYNhelp,4) = divinvGuarded(DYNX(W_,209),"pipe_3.perimeter");
DYNX(W_,218) = DYNX(DYNhelp,4)*4*DYNX(W_,208);
DYNX(W_,219) = DYNX(DYNhelp,4)*4*DYNX(W_,208);
DYNX(W_,247) = 0.5*(DYNX(W_,218)+DYNX(W_,219));
DYNX(DYNhelp,5) = divinvGuarded(DYNX(W_,166),"pipe_2.perimeter");
DYNX(W_,174) = DYNX(DYNhelp,5)*4*DYNX(W_,165);
BreakSectionFunctionCallNew(2);
BreakSectionFunctionEnd()
BreakSectionFunctionStart(1);
DYNX(W_,175) = DYNX(DYNhelp,5)*4*DYNX(W_,165);
DYNX(W_,203) = 0.5*(DYNX(W_,174)+DYNX(W_,175));
DYNX(W_,67) = 4184*(DYNX(W_,73)-273.15);
DYNX(Aux_,0) = DYNX(W_,67);
DYNX(W_,101) = 4184*(DYNX(W_,107)-273.15);
DYNX(W_,206) = DYNX(W_,101)+DYNX(DP_,2)*DYNX(DP_,47);
DYNX(W_,84) = 4184*(DYNX(W_,90)-273.15);
DYNX(Aux_,3) = DYNX(W_,84);
DYNX(W_,119) = 273.15+0.0002390057361376673*DYNX(Aux_,3);
DYNX(W_,53) = 273.15+0.0002390057361376673*DYNX(Aux_,0);
DYNX(W_,60) = 4184*(DYNX(W_,73)-273.15);
DYNX(W_,65) = DYNX(W_,73)-273.15;
DYNX(W_,66) = 1E-05*DYNX(W_,70);
DYNX(W_,77) = 4184*(DYNX(W_,90)-273.15);
DYNX(W_,82) = DYNX(W_,90)-273.15;
DYNX(W_,83) = 1E-05*DYNX(W_,87);
DYNX(W_,94) = 4184*(DYNX(W_,107)-273.15);
DYNX(W_,99) = DYNX(W_,107)-273.15;
DYNX(W_,100) = 1E-05*DYNX(W_,104);

/* Introducing 1 common subexpressions and reusing 1 variables totally whereof 2
   are global used in 1 expressions */
/* Of the common subexpressions 2 are reals, 0 are integers, and 0
   are booleans. */
DYNX(DYNhelp,6) = divinvGuarded(DYNX(W_,131),"pipe_1.flowModel.nParallel");
DYNX(W_,162) = (DYNJPushModelContext(1,"pressureLoss_m_flow_Unique14(pipe_1.flowModel.m_flow_nominal/pipe_1.flowModel.nParallel, pipe_1.flowModel.rho_nominal, pipe_1.flowModel.rho_nominal, pipe_1.flowModel.mu_nominal, pipe_1.flowModel.mu_nominal, pipe_1.flowModel.pathLengths_internal[1], pipe_1.flowModel.diameters[1], pipe_1.flowModel.crossAreas[1], pipe_1.flowModel.roughnesses[1], pipe_1.flowModel.m_flow_small/pipe_1.flowModel.nPara...",
   DYNStackData_)pressureLossx_0mx_0flowx_0Unique14(DYNX(DYNhelp,6)*DYNX(W_,156),
   DYNX(DP_,28), DYNX(DP_,28), DYNX(DP_,29), DYNX(DP_,29), DYNX(DP_,24), 
  DYNX(W_,161), DYNX(W_,123), DYNX(DP_,26), DYNX(DYNhelp,6)*DYNX(W_,157), 4000.0,
   DYNStackData_));
DYNJPopModelContext(DYNStackData_);

/* Introducing 1 common subexpressions and reusing 1 variables totally whereof 2
   are global used in 1 expressions */
/* Of the common subexpressions 2 are reals, 0 are integers, and 0
   are booleans. */
DYNX(DYNhelp,7) = divinvGuarded(DYNX(W_,173),"pipe_2.flowModel.nParallel");
DYNX(W_,204) = (DYNJPushModelContext(1,"pressureLoss_m_flow_Unique14(pipe_2.flowModel.m_flow_nominal/pipe_2.flowModel.nParallel, pipe_2.flowModel.rho_nominal, pipe_2.flowModel.rho_nominal, pipe_2.flowModel.mu_nominal, pipe_2.flowModel.mu_nominal, pipe_2.flowModel.pathLengths_internal[1], pipe_2.flowModel.diameters[1], pipe_2.flowModel.crossAreas[1], pipe_2.flowModel.roughnesses[1], pipe_2.flowModel.m_flow_small/pipe_2.flowModel.nPara...",
   DYNStackData_)pressureLossx_0mx_0flowx_0Unique14(DYNX(DYNhelp,7)*DYNX(W_,198),
   DYNX(DP_,38), DYNX(DP_,38), DYNX(DP_,39), DYNX(DP_,39), DYNX(DP_,34), 
  DYNX(W_,203), DYNX(W_,165), DYNX(DP_,36), DYNX(DYNhelp,7)*DYNX(W_,199), 4000.0,
   DYNStackData_));
DYNJPopModelContext(DYNStackData_);
DYNX(W_,216) = 273.15+0.0002390057361376673*DYNX(W_,101);

/* Introducing 1 common subexpressions and reusing 1 variables totally whereof 2
   are global used in 1 expressions */
/* Of the common subexpressions 2 are reals, 0 are integers, and 0
   are booleans. */
DYNX(DYNhelp,8) = divinvGuarded(DYNX(W_,217),"pipe_3.flowModel.nParallel");
DYNX(W_,248) = (DYNJPushModelContext(1,"pressureLoss_m_flow_Unique14(pipe_3.flowModel.m_flow_nominal/pipe_3.flowModel.nParallel, pipe_3.flowModel.rho_nominal, pipe_3.flowModel.rho_nominal, pipe_3.flowModel.mu_nominal, pipe_3.flowModel.mu_nominal, pipe_3.flowModel.pathLengths_internal[1], pipe_3.flowModel.diameters[1], pipe_3.flowModel.crossAreas[1], pipe_3.flowModel.roughnesses[1], pipe_3.flowModel.m_flow_small/pipe_3.flowModel.nPara...",
   DYNStackData_)pressureLossx_0mx_0flowx_0Unique14(DYNX(DYNhelp,8)*DYNX(W_,242),
   DYNX(DP_,48), DYNX(DP_,48), DYNX(DP_,49), DYNX(DP_,49), DYNX(DP_,44), 
  DYNX(W_,247), DYNX(W_,208), DYNX(DP_,46), DYNX(DYNhelp,8)*DYNX(W_,243), 4000.0,
   DYNStackData_));
DYNJPopModelContext(DYNStackData_);
BoundParameterSection
InitialSection
InitialStartSection
InitialStartSection2
DYNX(W_,281) = DYNX(DP_,8);
DYNX(W_,282) = DYNX(W_,28);
DYNX(W_,283) = DYNX(W_,25);
DYNX(W_,293) = 0.0010044335697769957*DYNX(DP_,8);
DYNX(W_,307) = DYNX(W_,114);
DYNX(W_,324) = DYNX(W_,138)-DYNX(W_,139);
DYNX(W_,333) = DYNX(W_,180)-DYNX(W_,181);
DYNX(W_,341) = DYNX(W_,224)-DYNX(W_,225);
DYNX(W_,347) = DYNX(W_,274);
DYNX(X_,0) = DYNX(W_,27);
InitialSection
if (!DymolaUserHomotopy) UpdateInitVars(time, X_, XD_, U_, DP_, IP_, LP_, F_, Y_, W_, QZ_, duser_, iuser_, cuser_, did_, 1);
DefaultSection
InitializeData(0)
InitialSection
InitialSection2
DYNX(W_,158) = DYNX(DP_,4);
DYNX(W_,155) = 1000.0*DYNX(W_,158);
DYNX(W_,200) = DYNX(DP_,4);
DYNX(W_,197) = 1000.0*DYNX(W_,200);
DYNX(W_,244) = DYNX(DP_,4);
DYNX(W_,241) = 1000.0*DYNX(W_,244);
DYNX(X_,0) = DYNX(W_,27);
AssertModelica(GreaterEqual(DYNX(X_,0),"pump_1.medium.T", 272.15,"272.15", 0)
   AND LessEqual(DYNX(X_,0),"pump_1.medium.T", 403.15,"403.15", 1),
  "pump_1.medium.T >= 272.15 and pump_1.medium.T <= 403.15", StringAdd(
  StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(
  "\nTemperature T (= ",Real2String2(DYNX(X_,0), true, 0))," K) is not\nin the allowed range ("),
  "272.15")," K <= T <= "),"403.15")," K)\nrequired from medium model \""),
  "SimpleLiquidWater"),"\".\n"));
DYNX(W_,346) = DYNdelay(DYNX(U_,0), DYNX(DP_,56), DYNX(DP_,56), 0, 
  "delay(fixedDelay.u, fixedDelay.delayTime)");
DYNX(W_,280) = Greater(DYNX(W_,346),"greaterThreshold.u", DYNX(DP_,58),
  "greaterThreshold.threshold", 2);
DYNX(W_,296) = IF DYNX(W_,280) THEN DYNX(W_,346) ELSE 0.0;
DYNX(W_,294) = RealBmax(DYNX(W_,296), 0.001);
DYNX(W_,312) = DYNdelay(DYNX(U_,1), DYNX(DP_,57), DYNX(DP_,57), 1, 
  "delay(fixedDelay3.u, fixedDelay3.delayTime)");
if (DymolaHomotopyLambda==0){
  BreakSectionCallNew(3);
}
else {
  /* Introducing 26 common subexpressions whereof 3 are global used in 30
     expressions */
  /* Of the common subexpressions 26 are reals, 0 are integers, and 0
     are booleans. */

  { /* Non-linear system of equations to solve. */
  /* Tag: initialization.nonlinear[1] */
  const char*const varnames_[]={"valve_2.dp", "idealJunction_2.port_1.p", 
    "valveDiscreteRamp.dp"};
  const double nominal_[]={100000.0, 100000.0, 100000.0};
  static const int sJacobianCG_[1] = {-1};
  static const struct QJacobianTag_ sJacobianGC2_[1] = {{-1,0}};
  NonLinearSystemOfEquations(Jacobian__, residue__, x__, 3, 0, 0, 2, -2, 
    DYNX(DYNhelp,96), 68, DYNX(did_->helpvari_vec,25), 25);
  SetInitVector(x__, 1, DYNX(W_,307), DYNX(W_,114));
  SetInitVectorSimple(x__, 2, DYNX(W_,300), 1, 100000.0);
  SetInitVector(x__, 3, DYNX(W_,347), DYNX(W_,274));
  Residues;
    DYNX(W_,305) = DYNX(W_,307)+DYNX(W_,87);
    DYNX(W_,331) = DYNX(W_,173)*DYNX(W_,165)*(DYNX(W_,305)-DYNX(W_,300));
    DYNX(DYNhelp,164) = 2.0*DYNX(W_,165);
    DYNX(DYNhelp,165) = divinvGuarded(DYNX(DYNhelp,164),"2.0*pipe_2.flowModel.crossAreas[1]");
    DYNX(W_,333) = DYNX(DYNhelp,165)*DYNX(DYNhelp,7)*(-2)*DYNX(W_,331);
    DYNX(DYNhelp,166) = DYNX(W_,312)*DYNX(W_,120);
    DYNX(W_,297) = DYNX(DYNhelp,166)*DYNX(W_,307);
    DYNX(W_,281) = IF DYNX(W_,280) THEN 1*DYNX(W_,279)*DYNX(W_,347) ELSE 
      DYNX(DP_,62)*DYNX(W_,279)*DYNX(W_,347);
    DYNX(W_,293) = 0.0010044335697769957*DYNX(W_,281);
    DYNX(W_,292) = 1231.056*DYNX(W_,293)*DYNX(W_,294)-0.065158*sqr(3600*
      DYNX(W_,293))+8.1602*sqr(DYNX(W_,294));
    DYNX(W_,291) = 995.586*DYNX(W_,292)*DYNX(W_,48);
    DYNX(W_,283) = DYNX(W_,291)+DYNX(W_,70);
    DYNX(W_,313) = DYNX(W_,283)-DYNX(W_,347);
    DYNX(W_,322) = DYNX(W_,131)*DYNX(W_,123)*(DYNX(W_,300)-DYNX(W_,313));
    DYNX(DYNhelp,167) = 2.0*DYNX(W_,123);
    DYNX(DYNhelp,168) = divinvGuarded(DYNX(DYNhelp,167),"2.0*pipe_1.flowModel.crossAreas[1]");
    DYNX(W_,324) = DYNX(DYNhelp,168)*DYNX(DYNhelp,6)*(-2)*DYNX(W_,322);
    DYNX(W_,339) = DYNX(W_,217)*DYNX(W_,208)*(DYNX(W_,104)-DYNX(W_,300));
    DYNX(DYNhelp,169) = 2.0*DYNX(W_,208);
    DYNX(DYNhelp,170) = divinvGuarded(DYNX(DYNhelp,169),"2.0*pipe_3.flowModel.crossAreas[1]");
    DYNX(W_,341) = DYNX(DYNhelp,170)*DYNX(DYNhelp,8)*(-2)*DYNX(W_,339);
    DYNX(DYNhelp,171) = DYNX(W_,220)*DYNX(DP_,47);
    DYNX(DYNhelp,172) = divinvGuarded(DYNX(W_,241),"pipe_3.flowModel.dp_nominal");
    DYNX(W_,298) = homotopy(DYNX(W_,217)*(DYNJPushModelContext(1,
      "massFlowRate_dp_staticHead_Unique18(pipe_3.flowModel.dps_fg[1], 995.586, 995.586, 0.001, 0.001, pipe_3.flowModel.pathLengths_internal[1], pipe_3.flowModel.diameters[1], pipe_3.flowModel.g*pipe_3.flowModel.dheights[1], pipe_3.flowModel.crossAreas[1], pipe_3.flowModel.roughnesses[1], pipe_3.flowModel.dp_small, 4000.0)",
       DYNStackData_)massFlowRatex_0dpx_0staticHeadx_0Unique18(DYNX(W_,341), 
      995.586, 995.586, 0.001, 0.001, DYNX(DP_,44), DYNX(W_,247), 
      DYNX(DYNhelp,171), DYNX(W_,208), DYNX(DP_,46), DYNX(W_,244), 4000.0, 
      DYNStackData_)), DYNX(DYNhelp,172)*DYNX(W_,242)*(DYNX(W_,341)-DYNX(DP_,48)
      *DYNX(W_,220)*DYNX(DP_,47)));
    DYNJPopModelContext(DYNStackData_);
  DYNX(DYNhelp,173) = DYNX(W_,134)*DYNX(DP_,27);
  DYNX(DYNhelp,174) = DYNX(DP_,28)*DYNX(W_,134);
  DYNX(DYNhelp,175) = divinvGuarded(DYNX(W_,155),"pipe_1.flowModel.dp_nominal");
  DYNX(DYNhelp,176) = DYNX(W_,176)*DYNX(DP_,37);
  DYNX(DYNhelp,177) = DYNX(DP_,38)*DYNX(W_,176);
  DYNX(DYNhelp,178) = divinvGuarded(DYNX(W_,197),"pipe_2.flowModel.dp_nominal");
  SetVector(residue__, 1, DYNX(W_,281)-homotopy(DYNX(W_,131)*(DYNJPushModelContext(1,
    "massFlowRate_dp_staticHead_Unique18(pipe_1.flowModel.dps_fg[1], 995.586, 995.586, 0.001, 0.001, pipe_1.flowModel.pathLengths_internal[1], pipe_1.flowModel.diameters[1], pipe_1.flowModel.g*pipe_1.flowModel.dheights[1], pipe_1.flowModel.crossAreas[1], pipe_1.flowModel.roughnesses[1], pipe_1.flowModel.dp_small, 4000.0)",
     DYNStackData_)massFlowRatex_0dpx_0staticHeadx_0Unique18(DYNX(W_,324), 
    995.586, 995.586, 0.001, 0.001, DYNX(DP_,24), DYNX(W_,161), DYNX(DYNhelp,173),
     DYNX(W_,123), DYNX(DP_,26), DYNX(W_,158), 4000.0, DYNStackData_)), 
    DYNX(DYNhelp,175)*DYNX(W_,156)*(DYNX(W_,324)-DYNX(DYNhelp,174)*DYNX(DP_,27))));
  DYNJPopModelContext(DYNStackData_);
  SetVector(residue__, 2, DYNX(W_,297)-homotopy(DYNX(W_,173)*(DYNJPushModelContext(1,
    "massFlowRate_dp_staticHead_Unique18(pipe_2.flowModel.dps_fg[1], 995.586, 995.586, 0.001, 0.001, pipe_2.flowModel.pathLengths_internal[1], pipe_2.flowModel.diameters[1], pipe_2.flowModel.g*pipe_2.flowModel.dheights[1], pipe_2.flowModel.crossAreas[1], pipe_2.flowModel.roughnesses[1], pipe_2.flowModel.dp_small, 4000.0)",
     DYNStackData_)massFlowRatex_0dpx_0staticHeadx_0Unique18(DYNX(W_,333), 
    995.586, 995.586, 0.001, 0.001, DYNX(DP_,34), DYNX(W_,203), DYNX(DYNhelp,176),
     DYNX(W_,165), DYNX(DP_,36), DYNX(W_,200), 4000.0, DYNStackData_)), 
    DYNX(DYNhelp,178)*DYNX(W_,198)*(DYNX(W_,333)-DYNX(DYNhelp,177)*DYNX(DP_,37))));
  DYNJPopModelContext(DYNStackData_);
  SetVector(residue__, 3, DYNX(W_,281)-DYNX(W_,298)-DYNX(W_,297));

  Jacobian(Jacobian__)
  MatrixZeros(Jacobian__);
  DYNX(DYNhelp,179) = homotopy(DYNX(W_,131)*(DYNJPushModelContext(1,
    "massFlowRate_dp_staticHead_Unique18:der(pipe_1.flowModel.dps_fg[1], 995.586, 995.586, 0.001, 0.001, pipe_1.flowModel.pathLengths_internal[1], pipe_1.flowModel.diameters[1], pipe_1.flowModel.g*pipe_1.flowModel.dheights[1], pipe_1.flowModel.crossAreas[1], pipe_1.flowModel.roughnesses[1], pipe_1.flowModel.dp_small, 4000.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)",
     DYNStackData_)massFlowRatex_0dpx_0staticHeadx_0Unique18__der(DYNX(W_,324), 
    995.586, 995.586, 0.001, 0.001, DYNX(DP_,24), DYNX(W_,161), DYNX(DYNhelp,173),
     DYNX(W_,123), DYNX(DP_,26), DYNX(W_,158), 4000.0, 1.0, 0.0, 0.0, 0.0, 0.0, 
    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, DYNStackData_)), DYNX(DYNhelp,175)*
    DYNX(W_,156))*DYNX(W_,131)*DYNX(W_,123);
  DYNJPopModelContext(DYNStackData_);
  DYNX(DYNhelp,180) = DYNX(DYNhelp,168)*DYNX(DYNhelp,6)*(-2.0)*DYNX(DYNhelp,179);
  DYNX(DYNhelp,181) = 2.0*(1231.056*DYNX(W_,294)-1688895.3599999999*DYNX(W_,293))
    *DYNX(W_,48)*DYNX(DYNhelp,179);
  DYNX(DYNhelp,182) = IF DYNX(W_,280) THEN 1*DYNX(W_,279) ELSE DYNX(DP_,62)*
    DYNX(W_,279);
  DYNX(DYNhelp,183) = DYNX(W_,173)*DYNX(W_,165);
  DYNX(DYNhelp,184) = DYNX(W_,173)*(DYNJPushModelContext(1,"massFlowRate_dp_staticHead_Unique18:der(pipe_2.flowModel.dps_fg[1], 995.586, 995.586, 0.001, 0.001, pipe_2.flowModel.pathLengths_internal[1], pipe_2.flowModel.diameters[1], pipe_2.flowModel.g*pipe_2.flowModel.dheights[1], pipe_2.flowModel.crossAreas[1], pipe_2.flowModel.roughnesses[1], pipe_2.flowModel.dp_small, 4000.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)",
     DYNStackData_)massFlowRatex_0dpx_0staticHeadx_0Unique18__der(DYNX(W_,333), 
    995.586, 995.586, 0.001, 0.001, DYNX(DP_,34), DYNX(W_,203), DYNX(DYNhelp,176),
     DYNX(W_,165), DYNX(DP_,36), DYNX(W_,200), 4000.0, 1.0, 0.0, 0.0, 0.0, 0.0, 
    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, DYNStackData_));
  DYNJPopModelContext(DYNStackData_);
  DYNX(DYNhelp,185) = DYNX(DYNhelp,178)*DYNX(W_,198);
  DYNX(DYNhelp,186) = DYNX(DYNhelp,183)*homotopy(DYNX(DYNhelp,184), 
    DYNX(DYNhelp,185));
  SetMatrixLeading(Jacobian__, 1, 2, 3,  -DYNX(DYNhelp,180));
  SetMatrixLeading(Jacobian__, 1, 3, 3, (1.0-DYNX(DYNhelp,168)*DYNX(DYNhelp,6)*
    DYNX(DYNhelp,181))*DYNX(DYNhelp,182)-DYNX(DYNhelp,180));
  SetMatrixLeading(Jacobian__, 2, 1, 3, DYNX(DYNhelp,166)-DYNX(DYNhelp,165)*
    DYNX(DYNhelp,7)*(-2.0)*DYNX(DYNhelp,186));
  SetMatrixLeading(Jacobian__, 2, 2, 3,  -DYNX(DYNhelp,165)*DYNX(DYNhelp,7)*2.0*
    DYNX(DYNhelp,186));
  SetMatrixLeading(Jacobian__, 3, 1, 3, (-1.0)*DYNX(DYNhelp,166));
  SetMatrixLeading(Jacobian__, 3, 2, 3, DYNX(DYNhelp,170)*DYNX(DYNhelp,8)*(-2.0)
    *homotopy(DYNX(W_,217)*(DYNJPushModelContext(1,"massFlowRate_dp_staticHead_Unique18:der(pipe_3.flowModel.dps_fg[1], 995.586, 995.586, 0.001, 0.001, pipe_3.flowModel.pathLengths_internal[1], pipe_3.flowModel.diameters[1], pipe_3.flowModel.g*pipe_3.flowModel.dheights[1], pipe_3.flowModel.crossAreas[1], pipe_3.flowModel.roughnesses[1], pipe_3.flowModel.dp_small, 4000.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)",
     DYNStackData_)massFlowRatex_0dpx_0staticHeadx_0Unique18__der(DYNX(W_,341), 
    995.586, 995.586, 0.001, 0.001, DYNX(DP_,44), DYNX(W_,247), DYNX(DYNhelp,171),
     DYNX(W_,208), DYNX(DP_,46), DYNX(W_,244), 4000.0, 1.0, 0.0, 0.0, 0.0, 0.0, 
    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, DYNStackData_)), DYNX(DYNhelp,172)*
    DYNX(W_,242))*DYNX(W_,217)*DYNX(W_,208));
  DYNJPopModelContext(DYNStackData_);
  SetMatrixLeading(Jacobian__, 3, 3, 3, DYNX(DYNhelp,182));

  SolveNonLinearSystemOfEquationsInit(Jacobian__, 0, 0, 0, residue__, x__,"Tag: initialization.nonlinear[1]");
  DYNX(W_,307) = GetVector(x__, 1);
  DYNX(W_,300) = GetVector(x__, 2);
  DYNX(W_,347) = GetVector(x__, 3);
  EndNonLinearSystemOfEquationsInit(residue__, x__, 2);
   /* End of Non-Linear Equation Block */ }



}
AssertModelica(GreaterEqual(DYNX(W_,283),"pump_1.medium.p", 0.0,"0.0", 3),
  "pump_1.medium.p >= 0.0", StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(
  StringAdd("Pressure (= ",Real2String2(DYNX(W_,283), true, 0))," Pa) of medium \""),
  "SimpleLiquidWater"),"\" is negative\n(Temperature = "),Real2String2(
  DYNX(X_,0), true, 0))," K)"));
AssertModelica(Greater(DYNX(W_,297),"valve_2.port_a.m_flow",  -DYNX(W_,116),
  " -valve_2.m_flow_small", 4),"valve_2.port_a.m_flow >  -valve_2.m_flow_small",
   "Reversing flow occurs even though allowFlowReversal is false");
InitialSection
InitialSection2
DYNX(W_,342) = 0.0010044335697769957*DYNX(W_,281);
DYNX(Y_,0) = 3600*DYNX(W_,342);
DYNX(W_,343) = DYNX(W_,313)-DYNX(W_,70);
DYNX(Y_,1) = 1E-05*DYNX(W_,343);
DYNX(W_,344) = 0.0010044335697769957*DYNX(W_,297);
DYNX(Y_,2) = 3600*DYNX(W_,344);
DYNX(W_,345) = DYNX(W_,305)-DYNX(W_,87);
DYNX(Y_,3) = 1E-05*DYNX(W_,345);
DYNX(Y_,4) = 6.0431+1.1881*sqr(3600*DYNX(W_,293))*DYNX(W_,294)-0.14637*
  powUnguarded(3600*DYNX(W_,293), 3)+83096.64*DYNX(W_,293)*sqr(DYNX(W_,294))+
  53.0304*powUnguarded(DYNX(W_,294), 3);
DYNX(W_,282) = 4184*(DYNX(X_,0)-273.15);
InitialBoundSection
DYNX(Aux_,14) = RealBmax( -DYNX(W_,298), 0.0)+RealBmax( -DYNX(W_,297), 0.0);
DYNX(Aux_,15) = IF DYNX(Aux_,14) > 1E-10 THEN 1.0 ELSE IF DYNX(Aux_,14) > 0.0
   THEN sqr(10000000000.0*DYNX(Aux_,14))*(3.0-20000000000.0*DYNX(Aux_,14)) ELSE 
  0.0;
DYNX(Aux_,12) = RealBmax(DYNX(W_,281), 0.0)+RealBmax( -DYNX(W_,298), 0.0);
DYNX(Aux_,13) = IF DYNX(Aux_,12) > 1E-10 THEN 1.0 ELSE IF DYNX(Aux_,12) > 0.0
   THEN sqr(10000000000.0*DYNX(Aux_,12))*(3.0-20000000000.0*DYNX(Aux_,12)) ELSE 
  0.0;
InitialSection2
DYNX(W_,316) = DYNX(W_,282)-DYNX(DP_,2)*DYNX(DP_,27);
DYNX(W_,304) = divGuarded((DYNX(Aux_,13)*RealBmax(DYNX(W_,281), 0.0)+1E-10*(1.0-
  DYNX(Aux_,13)))*DYNX(W_,316)+(DYNX(Aux_,13)*RealBmax( -DYNX(W_,298), 0.0)+
  1E-10*(1.0-DYNX(Aux_,13)))*DYNX(W_,206),"(stream_alpha1*max(idealJunction_2.port_2.m_flow, 0.0)+1E-10*(1.0-stream_alpha1))*pipe_1.port_b.h_outflow+(stream_alpha1*max(idealJunction_2.port_1.m_flow, 0.0)+1E-10*(1.0-stream_alpha1))*pipe_3.port_a.h_outflow",
  DYNX(Aux_,13)*RealBmax(DYNX(W_,281), 0.0)+1E-10*(1.0-DYNX(Aux_,13))+
  DYNX(Aux_,13)*RealBmax( -DYNX(W_,298), 0.0)+1E-10*(1.0-DYNX(Aux_,13)),
  "stream_alpha1*max(idealJunction_2.port_2.m_flow, 0.0)+1E-10*(1.0-stream_alpha1)+stream_alpha1*max(idealJunction_2.port_1.m_flow, 0.0)+1E-10*(1.0-stream_alpha1)");
DYNX(W_,306) = DYNX(W_,304)-DYNX(DP_,2)*DYNX(DP_,37);
DYNX(W_,325) = DYNX(W_,306)+DYNX(DP_,2)*DYNX(DP_,37);
DYNX(W_,302) = divGuarded((DYNX(Aux_,15)*RealBmax( -DYNX(W_,298), 0.0)+1E-10*(
  1.0-DYNX(Aux_,15)))*DYNX(W_,206)+(DYNX(Aux_,15)*RealBmax( -DYNX(W_,297), 0.0)+
  1E-10*(1.0-DYNX(Aux_,15)))*DYNX(W_,325),"(stream_alpha3*max(idealJunction_2.port_1.m_flow, 0.0)+1E-10*(1.0-stream_alpha3))*pipe_3.port_a.h_outflow+(stream_alpha3*max(idealJunction_2.port_3.m_flow, 0.0)+1E-10*(1.0-stream_alpha3))*pipe_2.port_a.h_outflow",
  DYNX(Aux_,15)*RealBmax( -DYNX(W_,298), 0.0)+1E-10*(1.0-DYNX(Aux_,15))+
  DYNX(Aux_,15)*RealBmax( -DYNX(W_,297), 0.0)+1E-10*(1.0-DYNX(Aux_,15)),
  "stream_alpha3*max(idealJunction_2.port_1.m_flow, 0.0)+1E-10*(1.0-stream_alpha3)+stream_alpha3*max(idealJunction_2.port_3.m_flow, 0.0)+1E-10*(1.0-stream_alpha3)");
DYNX(W_,314) = DYNX(W_,302)+DYNX(DP_,2)*DYNX(DP_,27);
DYNX(W_,290) = DYNX(W_,281)*(IF DYNX(W_,281) > 0.0 THEN DYNX(Aux_,0) ELSE 
  DYNX(W_,282))-DYNX(W_,281)*(IF  -DYNX(W_,281) > 0.0 THEN DYNX(W_,314) ELSE 
  DYNX(W_,282));
DYNX(W_,289) = DYNX(W_,290)+DYNX(Y_,4);
DYNX(W_,285) = 0.010044335697769956*DYNX(W_,289);
DYNX(F_,0) = 0.0002390057361376673*DYNX(W_,285);
InitialSection
InitialSectionB
Init_=false;InitializeData(2);Init_=true;
EndInitialSection

OutputSection
AssertModelica(GreaterEqual(DYNX(X_,0),"pump_1.medium.T", 272.15,"272.15", 0)
   AND LessEqual(DYNX(X_,0),"pump_1.medium.T", 403.15,"403.15", 1),
  "pump_1.medium.T >= 272.15 and pump_1.medium.T <= 403.15", StringAdd(
  StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(
  "\nTemperature T (= ",Real2String2(DYNX(X_,0), true, 0))," K) is not\nin the allowed range ("),
  "272.15")," K <= T <= "),"403.15")," K)\nrequired from medium model \""),
  "SimpleLiquidWater"),"\".\n"));

/* Introducing 0 common subexpressions and reusing 1 variables totally whereof 1
   are global used in 0 expressions */
/* Of the common subexpressions 1 are reals, 0 are integers, and 0
   are booleans. */
DYNX(W_,346) = DYNdelay(DYNX(U_,0), DYNX(DP_,56), DYNX(DP_,56), 2, 
  "delay(fixedDelay.u, fixedDelay.delayTime)");
DYNX(W_,280) = Greater(DYNX(W_,346),"greaterThreshold.u", DYNX(DP_,58),
  "greaterThreshold.threshold", 2);
DYNX(W_,296) = IF DYNX(W_,280) THEN DYNX(W_,346) ELSE 0.0;

/* Introducing 0 common subexpressions and reusing 1 variables totally whereof 1
   are global used in 0 expressions */
/* Of the common subexpressions 1 are reals, 0 are integers, and 0
   are booleans. */
DYNX(W_,294) = RealBmax(DYNX(W_,296), 0.001);

/* Introducing 0 common subexpressions and reusing 1 variables totally whereof 1
   are global used in 0 expressions */
/* Of the common subexpressions 1 are reals, 0 are integers, and 0
   are booleans. */
DYNX(W_,312) = DYNdelay(DYNX(U_,1), DYNX(DP_,57), DYNX(DP_,57), 3, 
  "delay(fixedDelay3.u, fixedDelay3.delayTime)");

{ /* Non-linear system of equations to solve. */
/* Tag: simulation.nonlinear[1] */
/* Introducing 32 common subexpressions whereof 19 are global used in 39
   expressions */
/* Of the common subexpressions 32 are reals, 0 are integers, and 0
   are booleans. */
const char*const varnames_[]={"valve_2.port_a.p", "idealJunction_2.port_1.p", 
  "pipe_1.port_a.p", "pump_1.medium.p"};
const double nominal_[]={100000.0, 100000.0, 100000.0, 100000.0};
static const int sJacobianCG_[1] = {-1};
static const struct QJacobianTag_ sJacobianGC2_[1] = {{-1,0}};
NonLinearSystemOfEquationsNH(Jacobian__, residue__, x__, 4, 0, 0, 3, 0, 2, 
  DYNX(DYNhelp,187), 94, DYNX(did_->helpvari_vec,50), 26);
NonLinearSystemSave(DYNX(W_,294), 0);
NonLinearSystemSave(DYNX(W_,312), 1);
SetInitVectorNH(x__, 1, DYNX(W_,305), Remember_(DYNX(W_,305), 0));
SetInitVectorNH(x__, 2, DYNX(W_,300), Remember_(DYNX(W_,300), 1));
SetInitVectorNH(x__, 3, DYNX(W_,313), Remember_(DYNX(W_,313), 2));
SetInitVectorNH(x__, 4, DYNX(W_,283), Remember_(DYNX(W_,283), 3));
Residues;
  DYNX(W_,331) = DYNX(W_,173)*DYNX(W_,165)*(DYNX(W_,305)-DYNX(W_,300));
  if (NewParameters_) {
  DYNX(DYNhelp,281) = 2.0*DYNX(W_,165);
  }
  if (NewParameters_) {
  DYNX(DYNhelp,282) = divinvGuarded(DYNX(DYNhelp,281),"2.0*pipe_2.flowModel.crossAreas[1]");
  }
  DYNX(W_,333) = DYNX(DYNhelp,282)*DYNX(DYNhelp,7)*(-2)*DYNX(W_,331);
  DYNX(W_,307) = DYNX(W_,305)-DYNX(W_,87);
  DYNX(DYNhelp,283) = DYNX(W_,312)*DYNX(W_,120);
  DYNX(W_,297) = DYNX(DYNhelp,283)*DYNX(W_,307);
  DYNX(W_,339) = DYNX(W_,217)*DYNX(W_,208)*(DYNX(W_,104)-DYNX(W_,300));
  if (NewParameters_) {
  DYNX(DYNhelp,284) = 2.0*DYNX(W_,208);
  }
  if (NewParameters_) {
  DYNX(DYNhelp,285) = divinvGuarded(DYNX(DYNhelp,284),"2.0*pipe_3.flowModel.crossAreas[1]");
  }
  DYNX(W_,341) = DYNX(DYNhelp,285)*DYNX(DYNhelp,8)*(-2)*DYNX(W_,339);
  if (NewParameters_) {
  DYNX(DYNhelp,286) = DYNX(W_,220)*DYNX(DP_,47);
  }
  DYNX(DYNhelp,287) = (DYNJPushModelContext(1,"massFlowRate_dp_staticHead_Unique18(pipe_3.flowModel.dps_fg[1], 995.586, 995.586, 0.001, 0.001, pipe_3.flowModel.pathLengths_internal[1], pipe_3.flowModel.diameters[1], pipe_3.flowModel.g*pipe_3.flowModel.dheights[1], pipe_3.flowModel.crossAreas[1], pipe_3.flowModel.roughnesses[1], pipe_3.flowModel.dp_small, 4000.0)",
     DYNStackData_)massFlowRatex_0dpx_0staticHeadx_0Unique18(DYNX(W_,341), 
    995.586, 995.586, 0.001, 0.001, DYNX(DP_,44), DYNX(W_,247), DYNX(DYNhelp,286),
     DYNX(W_,208), DYNX(DP_,46), DYNX(W_,244), 4000.0, DYNStackData_));
  DYNJPopModelContext(DYNStackData_);
  DYNX(W_,298) = DYNX(W_,217)*DYNX(DYNhelp,287);
  DYNX(W_,322) = DYNX(W_,131)*DYNX(W_,123)*(DYNX(W_,300)-DYNX(W_,313));
  if (NewParameters_) {
  DYNX(DYNhelp,288) = 2.0*DYNX(W_,123);
  }
  if (NewParameters_) {
  DYNX(DYNhelp,289) = divinvGuarded(DYNX(DYNhelp,288),"2.0*pipe_1.flowModel.crossAreas[1]");
  }
  DYNX(W_,324) = DYNX(DYNhelp,289)*DYNX(DYNhelp,6)*(-2)*DYNX(W_,322);
  if (NewParameters_) {
  DYNX(DYNhelp,290) = DYNX(W_,134)*DYNX(DP_,27);
  }
  DYNX(DYNhelp,291) = (DYNJPushModelContext(1,"massFlowRate_dp_staticHead_Unique18(pipe_1.flowModel.dps_fg[1], 995.586, 995.586, 0.001, 0.001, pipe_1.flowModel.pathLengths_internal[1], pipe_1.flowModel.diameters[1], pipe_1.flowModel.g*pipe_1.flowModel.dheights[1], pipe_1.flowModel.crossAreas[1], pipe_1.flowModel.roughnesses[1], pipe_1.flowModel.dp_small, 4000.0)",
     DYNStackData_)massFlowRatex_0dpx_0staticHeadx_0Unique18(DYNX(W_,324), 
    995.586, 995.586, 0.001, 0.001, DYNX(DP_,24), DYNX(W_,161), DYNX(DYNhelp,290),
     DYNX(W_,123), DYNX(DP_,26), DYNX(W_,158), 4000.0, DYNStackData_));
  DYNJPopModelContext(DYNStackData_);
  DYNX(W_,281) = DYNX(W_,131)*DYNX(DYNhelp,291);
  DYNX(W_,293) = 0.0010044335697769957*DYNX(W_,281);
  DYNX(W_,291) = DYNX(W_,283)-DYNX(W_,70);
  if (NewParameters_) {
  DYNX(DYNhelp,292) = 995.586*DYNX(W_,48);
  }
  if (NewParameters_) {
  DYNX(DYNhelp,293) = divinvGuarded(DYNX(DYNhelp,292),"995.586*pump_1.g");
  }
  DYNX(W_,292) = DYNX(DYNhelp,293)*DYNX(W_,291);
  DYNX(W_,347) = DYNX(W_,283)-DYNX(W_,313);
DYNX(DYNhelp,294) = 3600*DYNX(W_,293);
if (NewParameters_) {
DYNX(DYNhelp,295) = DYNX(W_,176)*DYNX(DP_,37);
}
DYNX(DYNhelp,296) = (DYNJPushModelContext(1,"massFlowRate_dp_staticHead_Unique18(pipe_2.flowModel.dps_fg[1], 995.586, 995.586, 0.001, 0.001, pipe_2.flowModel.pathLengths_internal[1], pipe_2.flowModel.diameters[1], pipe_2.flowModel.g*pipe_2.flowModel.dheights[1], pipe_2.flowModel.crossAreas[1], pipe_2.flowModel.roughnesses[1], pipe_2.flowModel.dp_small, 4000.0)",
   DYNStackData_)massFlowRatex_0dpx_0staticHeadx_0Unique18(DYNX(W_,333), 995.586,
   995.586, 0.001, 0.001, DYNX(DP_,34), DYNX(W_,203), DYNX(DYNhelp,295), 
  DYNX(W_,165), DYNX(DP_,36), DYNX(W_,200), 4000.0, DYNStackData_));
DYNJPopModelContext(DYNStackData_);
SetVector(residue__, 1, DYNX(W_,292)-(1231.056*DYNX(W_,293)*DYNX(W_,294)-
  0.065158*sqr(DYNX(DYNhelp,294))+8.1602*sqr(DYNX(W_,294))));
SetVector(residue__, 2, DYNX(W_,297)-DYNX(W_,173)*DYNX(DYNhelp,296));
SetVector(residue__, 3, DYNX(W_,281)-(IF DYNX(W_,280) THEN 1*DYNX(W_,279)*
  DYNX(W_,347) ELSE DYNX(DP_,62)*DYNX(W_,279)*DYNX(W_,347)));
SetVector(residue__, 4, DYNX(W_,281)-DYNX(W_,298)-DYNX(W_,297));

Jacobian(Jacobian__)
MatrixZeros(Jacobian__);
DYNX(DYNhelp,297) = DYNX(W_,131)*(DYNJPushModelContext(1,"massFlowRate_dp_staticHead_Unique18:der(pipe_1.flowModel.dps_fg[1], 995.586, 995.586, 0.001, 0.001, pipe_1.flowModel.pathLengths_internal[1], pipe_1.flowModel.diameters[1], pipe_1.flowModel.g*pipe_1.flowModel.dheights[1], pipe_1.flowModel.crossAreas[1], pipe_1.flowModel.roughnesses[1], pipe_1.flowModel.dp_small, 4000.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)",
   DYNStackData_)massFlowRatex_0dpx_0staticHeadx_0Unique18__der(DYNX(W_,324), 
  995.586, 995.586, 0.001, 0.001, DYNX(DP_,24), DYNX(W_,161), DYNX(DYNhelp,290),
   DYNX(W_,123), DYNX(DP_,26), DYNX(W_,158), 4000.0, 1.0, 0.0, 0.0, 0.0, 0.0, 
  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, DYNStackData_));
DYNJPopModelContext(DYNStackData_);
DYNX(DYNhelp,298) = 1688895.3599999999*DYNX(W_,293)-1231.056*DYNX(W_,294);
DYNX(DYNhelp,299) = DYNX(W_,131)*DYNX(W_,123);
DYNX(DYNhelp,300) = DYNX(DYNhelp,297)*DYNX(DYNhelp,298)*DYNX(DYNhelp,299);
DYNX(DYNhelp,301) = DYNX(W_,173)*(DYNJPushModelContext(1,"massFlowRate_dp_staticHead_Unique18:der(pipe_2.flowModel.dps_fg[1], 995.586, 995.586, 0.001, 0.001, pipe_2.flowModel.pathLengths_internal[1], pipe_2.flowModel.diameters[1], pipe_2.flowModel.g*pipe_2.flowModel.dheights[1], pipe_2.flowModel.crossAreas[1], pipe_2.flowModel.roughnesses[1], pipe_2.flowModel.dp_small, 4000.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)",
   DYNStackData_)massFlowRatex_0dpx_0staticHeadx_0Unique18__der(DYNX(W_,333), 
  995.586, 995.586, 0.001, 0.001, DYNX(DP_,34), DYNX(W_,203), DYNX(DYNhelp,295),
   DYNX(W_,165), DYNX(DP_,36), DYNX(W_,200), 4000.0, 1.0, 0.0, 0.0, 0.0, 0.0, 
  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, DYNStackData_));
DYNJPopModelContext(DYNStackData_);
DYNX(DYNhelp,302) = DYNX(W_,173)*DYNX(W_,165);
DYNX(DYNhelp,303) = DYNX(DYNhelp,301)*DYNX(DYNhelp,302);
DYNX(DYNhelp,304) = DYNX(DYNhelp,297)*DYNX(DYNhelp,299);
DYNX(DYNhelp,305) = DYNX(DYNhelp,289)*DYNX(DYNhelp,6)*(-2.0)*DYNX(DYNhelp,304);
DYNX(DYNhelp,306) = DYNX(DYNhelp,289)*DYNX(DYNhelp,6)*2.0*DYNX(DYNhelp,304);
DYNX(DYNhelp,307) = IF DYNX(W_,280) THEN 1*DYNX(W_,279) ELSE DYNX(DP_,62)*
  DYNX(W_,279);
DYNX(DYNhelp,308) = DYNX(W_,217)*(DYNJPushModelContext(1,"massFlowRate_dp_staticHead_Unique18:der(pipe_3.flowModel.dps_fg[1], 995.586, 995.586, 0.001, 0.001, pipe_3.flowModel.pathLengths_internal[1], pipe_3.flowModel.diameters[1], pipe_3.flowModel.g*pipe_3.flowModel.dheights[1], pipe_3.flowModel.crossAreas[1], pipe_3.flowModel.roughnesses[1], pipe_3.flowModel.dp_small, 4000.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)",
   DYNStackData_)massFlowRatex_0dpx_0staticHeadx_0Unique18__der(DYNX(W_,341), 
  995.586, 995.586, 0.001, 0.001, DYNX(DP_,44), DYNX(W_,247), DYNX(DYNhelp,286),
   DYNX(W_,208), DYNX(DP_,46), DYNX(W_,244), 4000.0, 1.0, 0.0, 0.0, 0.0, 0.0, 
  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, DYNStackData_));
DYNJPopModelContext(DYNStackData_);
DYNX(DYNhelp,309) = DYNX(W_,217)*DYNX(W_,208);
SetMatrixLeading(Jacobian__, 1, 2, 4, DYNX(DYNhelp,289)*DYNX(DYNhelp,6)*(
  -0.0020088671395539913)*DYNX(DYNhelp,300));
SetMatrixLeading(Jacobian__, 1, 3, 4, DYNX(DYNhelp,289)*DYNX(DYNhelp,6)*
  0.0020088671395539913*DYNX(DYNhelp,300));
SetMatrixLeading(Jacobian__, 1, 4, 4, DYNX(DYNhelp,293));
SetMatrixLeading(Jacobian__, 2, 1, 4, DYNX(DYNhelp,283)-DYNX(DYNhelp,282)*
  DYNX(DYNhelp,7)*(-2.0)*DYNX(DYNhelp,303));
SetMatrixLeading(Jacobian__, 2, 2, 4,  -DYNX(DYNhelp,282)*DYNX(DYNhelp,7)*2.0*
  DYNX(DYNhelp,303));
SetMatrixLeading(Jacobian__, 3, 2, 4, DYNX(DYNhelp,305));
SetMatrixLeading(Jacobian__, 3, 3, 4, DYNX(DYNhelp,306)+DYNX(DYNhelp,307));
SetMatrixLeading(Jacobian__, 3, 4, 4,  -DYNX(DYNhelp,307));
SetMatrixLeading(Jacobian__, 4, 1, 4, (-1.0)*DYNX(DYNhelp,283));
SetMatrixLeading(Jacobian__, 4, 2, 4, DYNX(DYNhelp,285)*DYNX(DYNhelp,8)*(-2.0)*
  DYNX(DYNhelp,308)*DYNX(DYNhelp,309)+DYNX(DYNhelp,305));
SetMatrixLeading(Jacobian__, 4, 3, 4, DYNX(DYNhelp,306));

SolveNonLinearSystemOfEquationsNH(Jacobian__, 0, 0, 0, residue__, x__, 3, 
  "Tag: simulation.nonlinear[1]");
DYNX(W_,305) = GetVector(x__, 1);
DYNX(W_,300) = GetVector(x__, 2);
DYNX(W_,313) = GetVector(x__, 3);
DYNX(W_,283) = GetVector(x__, 4);
EndNonLinearSystemOfEquationsNH(residue__, x__, 3);
 /* End of Non-Linear Equation Block */ }



AssertModelica(GreaterEqual(DYNX(W_,283),"pump_1.medium.p", 0.0,"0.0", 3),
  "pump_1.medium.p >= 0.0", StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(
  StringAdd("Pressure (= ",Real2String2(DYNX(W_,283), true, 0))," Pa) of medium \""),
  "SimpleLiquidWater"),"\" is negative\n(Temperature = "),Real2String2(
  DYNX(X_,0), true, 0))," K)"));
DYNX(W_,342) = 0.0010044335697769957*DYNX(W_,281);
DYNX(Y_,0) = 3600*DYNX(W_,342);
DYNX(W_,343) = DYNX(W_,313)-DYNX(W_,70);
DYNX(Y_,1) = 1E-05*DYNX(W_,343);
DYNX(W_,344) = 0.0010044335697769957*DYNX(W_,297);
DYNX(Y_,2) = 3600*DYNX(W_,344);
DYNX(W_,345) = DYNX(W_,305)-DYNX(W_,87);
DYNX(Y_,3) = 1E-05*DYNX(W_,345);
DYNX(Y_,4) = 6.0431+1.1881*sqr(3600*DYNX(W_,293))*DYNX(W_,294)-0.14637*
  powUnguarded(3600*DYNX(W_,293), 3)+83096.64*DYNX(W_,293)*sqr(DYNX(W_,294))+
  53.0304*powUnguarded(DYNX(W_,294), 3);
DYNX(W_,299) =  -DYNX(W_,298);
DYNX(W_,299) =  -DYNX(W_,298);
DYNX(W_,303) =  -DYNX(W_,297);
DYNX(W_,303) =  -DYNX(W_,297);
DYNX(W_,323) =  -DYNX(W_,322);
DYNX(W_,323) =  -DYNX(W_,322);
DYNX(W_,315) =  -DYNX(W_,281);
DYNX(W_,315) =  -DYNX(W_,281);
DYNX(W_,332) =  -DYNX(W_,331);
DYNX(W_,332) =  -DYNX(W_,331);
DYNX(W_,340) =  -DYNX(W_,339);
DYNX(W_,340) =  -DYNX(W_,339);
(DYNJPushModelContext(1,"Modelica.Fluid.Utilities.checkBoundary(\"SimpleLiquidWater\", {\"SimpleLiquidWater\"}, true, true, source_1.X, \"FixedBoundary\")",
   DYNStackData_)Modelica_Fluid_Utilities_checkBoundary("SimpleLiquidWater", 
  DYNJStringTemporaryDense( DymArrays2, DYNStackData_, 1, 1), true, true, 
  DYNJRealTemporaryDense( &DYNX(DP_,12), DYNStackData_, 1, 1), "FixedBoundary", 
  DYNStackData_));
DYNJPopAllMarks(DYNStackData_);
(DYNJPushModelContext(1,"Modelica.Fluid.Utilities.checkBoundary(\"SimpleLiquidWater\", {\"SimpleLiquidWater\"}, true, true, sink_2.X, \"FixedBoundary\")",
   DYNStackData_)Modelica_Fluid_Utilities_checkBoundary("SimpleLiquidWater", 
  DYNJStringTemporaryDense( DymArrays2, DYNStackData_, 1, 1), true, true, 
  DYNJRealTemporaryDense( &DYNX(DP_,14), DYNStackData_, 1, 1), "FixedBoundary", 
  DYNStackData_));
DYNJPopAllMarks(DYNStackData_);
(DYNJPushModelContext(1,"Modelica.Fluid.Utilities.checkBoundary(\"SimpleLiquidWater\", {\"SimpleLiquidWater\"}, true, true, source_4.X, \"FixedBoundary\")",
   DYNStackData_)Modelica_Fluid_Utilities_checkBoundary("SimpleLiquidWater", 
  DYNJStringTemporaryDense( DymArrays2, DYNStackData_, 1, 1), true, true, 
  DYNJRealTemporaryDense( &DYNX(DP_,16), DYNStackData_, 1, 1), "FixedBoundary", 
  DYNStackData_));
DYNJPopAllMarks(DYNStackData_);
AssertModelica(Greater(DYNX(W_,297),"valve_2.port_a.m_flow",  -DYNX(W_,116),
  " -valve_2.m_flow_small", 4),"valve_2.port_a.m_flow >  -valve_2.m_flow_small",
   "Reversing flow occurs even though allowFlowReversal is false");

DynamicsSection
DYNX(W_,282) = 4184*(DYNX(X_,0)-273.15);

/* Introducing 2 common subexpressions whereof 2 are global used in 0
   expressions */
/* Of the common subexpressions 2 are reals, 0 are integers, and 0
   are booleans. */
DYNX(DYNhelp,310) = RealBmax( -DYNX(W_,298), 0.0);
DYNX(DYNhelp,311) = RealBmax( -DYNX(W_,297), 0.0);
DYNX(Aux_,14) = DYNX(DYNhelp,310)+DYNX(DYNhelp,311);
DYNX(Aux_,15) = IF DYNX(Aux_,14) > 1E-10 THEN 1.0 ELSE IF DYNX(Aux_,14) > 0.0
   THEN sqr(10000000000.0*DYNX(Aux_,14))*(3.0-20000000000.0*DYNX(Aux_,14)) ELSE 
  0.0;

/* Introducing 2 common subexpressions whereof 2 are global used in 0
   expressions */
/* Of the common subexpressions 2 are reals, 0 are integers, and 0
   are booleans. */
DYNX(DYNhelp,312) = RealBmax(DYNX(W_,281), 0.0);
DYNX(Aux_,12) = DYNX(DYNhelp,312)+DYNX(DYNhelp,310);
DYNX(Aux_,13) = IF DYNX(Aux_,12) > 1E-10 THEN 1.0 ELSE IF DYNX(Aux_,12) > 0.0
   THEN sqr(10000000000.0*DYNX(Aux_,12))*(3.0-20000000000.0*DYNX(Aux_,12)) ELSE 
  0.0;
DYNX(W_,316) = DYNX(W_,282)-DYNX(DP_,2)*DYNX(DP_,27);

/* Introducing 7 common subexpressions whereof 7 are global used in 4
   expressions */
/* Of the common subexpressions 7 are reals, 0 are integers, and 0
   are booleans. */
DYNX(DYNhelp,313) = 1.0-DYNX(Aux_,13);
DYNX(DYNhelp,314) = 1E-10*DYNX(DYNhelp,313);
DYNX(DYNhelp,315) = DYNX(Aux_,13)*DYNX(DYNhelp,312)+DYNX(DYNhelp,314);
DYNX(DYNhelp,316) = DYNX(Aux_,13)*DYNX(DYNhelp,310)+DYNX(DYNhelp,314);
DYNX(DYNhelp,317) = DYNX(DYNhelp,315)+DYNX(DYNhelp,316);
DYNX(W_,304) = divGuarded(DYNX(DYNhelp,315)*DYNX(W_,316)+DYNX(DYNhelp,316)*
  DYNX(W_,206),"(stream_alpha1*max(idealJunction_2.port_2.m_flow, 0.0)+1E-10*(1.0-stream_alpha1))*pipe_1.port_b.h_outflow+(stream_alpha1*max(idealJunction_2.port_1.m_flow, 0.0)+1E-10*(1.0-stream_alpha1))*pipe_3.port_a.h_outflow",
  DYNX(DYNhelp,317),"stream_alpha1*max(idealJunction_2.port_2.m_flow, 0.0)+1E-10*(1.0-stream_alpha1)+stream_alpha1*max(idealJunction_2.port_1.m_flow, 0.0)+1E-10*(1.0-stream_alpha1)");
DYNX(W_,306) = DYNX(W_,304)-DYNX(DP_,2)*DYNX(DP_,37);
DYNX(W_,325) = DYNX(W_,306)+DYNX(DP_,2)*DYNX(DP_,37);

/* Introducing 7 common subexpressions whereof 7 are global used in 4
   expressions */
/* Of the common subexpressions 7 are reals, 0 are integers, and 0
   are booleans. */
DYNX(DYNhelp,318) = 1.0-DYNX(Aux_,15);
DYNX(DYNhelp,319) = 1E-10*DYNX(DYNhelp,318);
DYNX(DYNhelp,320) = DYNX(Aux_,15)*DYNX(DYNhelp,310)+DYNX(DYNhelp,319);
DYNX(DYNhelp,321) = DYNX(Aux_,15)*DYNX(DYNhelp,311)+DYNX(DYNhelp,319);
DYNX(DYNhelp,322) = DYNX(DYNhelp,320)+DYNX(DYNhelp,321);
DYNX(W_,302) = divGuarded(DYNX(DYNhelp,320)*DYNX(W_,206)+DYNX(DYNhelp,321)*
  DYNX(W_,325),"(stream_alpha3*max(idealJunction_2.port_1.m_flow, 0.0)+1E-10*(1.0-stream_alpha3))*pipe_3.port_a.h_outflow+(stream_alpha3*max(idealJunction_2.port_3.m_flow, 0.0)+1E-10*(1.0-stream_alpha3))*pipe_2.port_a.h_outflow",
  DYNX(DYNhelp,322),"stream_alpha3*max(idealJunction_2.port_1.m_flow, 0.0)+1E-10*(1.0-stream_alpha3)+stream_alpha3*max(idealJunction_2.port_3.m_flow, 0.0)+1E-10*(1.0-stream_alpha3)");
DYNX(W_,314) = DYNX(W_,302)+DYNX(DP_,2)*DYNX(DP_,27);
DYNX(W_,290) = DYNX(W_,281)*(IF DYNX(W_,281) > 0.0 THEN DYNX(Aux_,0) ELSE 
  DYNX(W_,282))-DYNX(W_,281)*(IF  -DYNX(W_,281) > 0.0 THEN DYNX(W_,314) ELSE 
  DYNX(W_,282));
DYNX(W_,289) = DYNX(W_,290)+DYNX(Y_,4);
DYNX(W_,285) = 0.010044335697769956*DYNX(W_,289);
DYNX(F_,0) = 0.0002390057361376673*DYNX(W_,285);

AcceptedSection1

AcceptedSection2
DYNX(Aux_,4) = DYNX(W_,282);
DYNX(Aux_,1) = DYNX(W_,306);
DYNX(Aux_,2) = DYNX(W_,306);
DYNX(Aux_,5) = DYNX(W_,282);

/* Introducing 2 common subexpressions whereof 2 are global used in 0
   expressions */
/* Of the common subexpressions 2 are reals, 0 are integers, and 0
   are booleans. */
DYNX(DYNhelp,323) = RealBmax( -DYNX(W_,281), 0.0);
DYNX(Aux_,16) = DYNX(DYNhelp,323)+DYNX(DYNhelp,312);
DYNX(Aux_,17) = IF DYNX(Aux_,16) > 1E-10 THEN 1.0 ELSE IF DYNX(Aux_,16) > 0.0
   THEN sqr(10000000000.0*DYNX(Aux_,16))*(3.0-20000000000.0*DYNX(Aux_,16)) ELSE 
  0.0;

/* Introducing 7 common subexpressions whereof 7 are global used in 4
   expressions */
/* Of the common subexpressions 7 are reals, 0 are integers, and 0
   are booleans. */
DYNX(DYNhelp,324) = 1.0-DYNX(Aux_,17);
DYNX(DYNhelp,325) = 1E-10*DYNX(DYNhelp,324);
DYNX(DYNhelp,326) = DYNX(Aux_,17)*DYNX(DYNhelp,323)+DYNX(DYNhelp,325);
DYNX(DYNhelp,327) = DYNX(Aux_,17)*DYNX(DYNhelp,312)+DYNX(DYNhelp,325);
DYNX(DYNhelp,328) = DYNX(DYNhelp,326)+DYNX(DYNhelp,327);
DYNX(Aux_,6) = divGuarded(DYNX(DYNhelp,326)*DYNX(W_,314)+DYNX(DYNhelp,327)*
  DYNX(W_,282),"(stream_alpha5*max( -idealJunction_2.port_2.m_flow, 0.0)+1E-10*(1.0-stream_alpha5))*pipe_1.port_a.h_outflow+(stream_alpha5*max( -pump_1.port_b.m_flow, 0.0)+1E-10*(1.0-stream_alpha5))*valveDiscreteRamp.port_b.h_outflow",
  DYNX(DYNhelp,328),"stream_alpha5*max( -idealJunction_2.port_2.m_flow, 0.0)+1E-10*(1.0-stream_alpha5)+stream_alpha5*max( -pump_1.port_b.m_flow, 0.0)+1E-10*(1.0-stream_alpha5)");

/* Introducing 2 common subexpressions whereof 2 are global used in 0
   expressions */
/* Of the common subexpressions 2 are reals, 0 are integers, and 0
   are booleans. */
DYNX(Aux_,18) = DYNX(DYNhelp,323)+DYNX(DYNhelp,312);
DYNX(Aux_,19) = IF DYNX(Aux_,18) > 1E-10 THEN 1.0 ELSE IF DYNX(Aux_,18) > 0.0
   THEN sqr(10000000000.0*DYNX(Aux_,18))*(3.0-20000000000.0*DYNX(Aux_,18)) ELSE 
  0.0;

/* Introducing 7 common subexpressions whereof 7 are global used in 4
   expressions */
/* Of the common subexpressions 7 are reals, 0 are integers, and 0
   are booleans. */
DYNX(DYNhelp,329) = 1.0-DYNX(Aux_,19);
DYNX(DYNhelp,330) = 1E-10*DYNX(DYNhelp,329);
DYNX(DYNhelp,331) = DYNX(Aux_,19)*DYNX(DYNhelp,323)+DYNX(DYNhelp,330);
DYNX(DYNhelp,332) = DYNX(Aux_,19)*DYNX(DYNhelp,312)+DYNX(DYNhelp,330);
DYNX(DYNhelp,333) = DYNX(DYNhelp,331)+DYNX(DYNhelp,332);
DYNX(Aux_,7) = divGuarded(DYNX(DYNhelp,331)*DYNX(W_,282)+DYNX(DYNhelp,332)*
  DYNX(W_,67),"(stream_alpha7*max( -pump_1.port_a.m_flow, 0.0)+1E-10*(1.0-stream_alpha7))*pump_1.port_a.h_outflow+(stream_alpha7*max( -source_1.ports[1].m_flow, 0.0)+1E-10*(1.0-stream_alpha7))*volumeFlow_1.port_b.h_outflow",
  DYNX(DYNhelp,333),"stream_alpha7*max( -pump_1.port_a.m_flow, 0.0)+1E-10*(1.0-stream_alpha7)+stream_alpha7*max( -source_1.ports[1].m_flow, 0.0)+1E-10*(1.0-stream_alpha7)");
DYNX(Aux_,8) = DYNX(W_,306);
DYNX(Aux_,9) = DYNX(W_,306);

/* Introducing 2 common subexpressions whereof 2 are global used in 0
   expressions */
/* Of the common subexpressions 2 are reals, 0 are integers, and 0
   are booleans. */
DYNX(DYNhelp,334) = RealBmax(DYNX(W_,297), 0.0);
DYNX(Aux_,20) = DYNX(DYNhelp,334)+DYNX(DYNhelp,311);
DYNX(Aux_,21) = IF DYNX(Aux_,20) > 1E-10 THEN 1.0 ELSE IF DYNX(Aux_,20) > 0.0
   THEN sqr(10000000000.0*DYNX(Aux_,20))*(3.0-20000000000.0*DYNX(Aux_,20)) ELSE 
  0.0;

/* Introducing 7 common subexpressions whereof 7 are global used in 4
   expressions */
/* Of the common subexpressions 7 are reals, 0 are integers, and 0
   are booleans. */
DYNX(DYNhelp,335) = 1.0-DYNX(Aux_,21);
DYNX(DYNhelp,336) = 1E-10*DYNX(DYNhelp,335);
DYNX(DYNhelp,337) = DYNX(Aux_,21)*DYNX(DYNhelp,334)+DYNX(DYNhelp,336);
DYNX(DYNhelp,338) = DYNX(Aux_,21)*DYNX(DYNhelp,311)+DYNX(DYNhelp,336);
DYNX(DYNhelp,339) = DYNX(DYNhelp,337)+DYNX(DYNhelp,338);
BreakSectionFunctionEnd()
BreakSectionFunctionStart(4);
DYNX(Aux_,10) = divGuarded(DYNX(DYNhelp,337)*DYNX(W_,306)+DYNX(DYNhelp,338)*
  DYNX(W_,84),"(stream_alpha9*max(valve_2.port_a.m_flow, 0.0)+1E-10*(1.0-stream_alpha9))*valve_2.port_b.h_outflow+(stream_alpha9*max( -sink_2.ports[1].m_flow, 0.0)+1E-10*(1.0-stream_alpha9))*sink_2.ports[1].h_outflow",
  DYNX(DYNhelp,339),"stream_alpha9*max(valve_2.port_a.m_flow, 0.0)+1E-10*(1.0-stream_alpha9)+stream_alpha9*max( -sink_2.ports[1].m_flow, 0.0)+1E-10*(1.0-stream_alpha9)");
DYNX(Aux_,11) = DYNX(W_,314);
DYNX(W_,284) = 4184*(DYNX(X_,0)-273.15);
DYNX(W_,288) = 99.55860000000001*DYNX(W_,284);
DYNX(W_,286) = DYNX(X_,0)-273.15;
DYNX(W_,287) = 1E-05*DYNX(W_,283);
DYNX(W_,295) = divGuarded(DYNX(W_,291)*DYNX(W_,293),"pump_1.dp_pump*pump_1.V_flow_single",
  DYNX(Y_,4),"pump_1.Wb_flow");

/* Introducing 2 common subexpressions whereof 2 are global used in 0
   expressions */
/* Of the common subexpressions 2 are reals, 0 are integers, and 0
   are booleans. */
DYNX(Aux_,22) = DYNX(DYNhelp,312)+DYNX(DYNhelp,311);
DYNX(Aux_,23) = IF DYNX(Aux_,22) > 1E-10 THEN 1.0 ELSE IF DYNX(Aux_,22) > 0.0
   THEN sqr(10000000000.0*DYNX(Aux_,22))*(3.0-20000000000.0*DYNX(Aux_,22)) ELSE 
  0.0;

/* Introducing 7 common subexpressions whereof 7 are global used in 4
   expressions */
/* Of the common subexpressions 7 are reals, 0 are integers, and 0
   are booleans. */
DYNX(DYNhelp,340) = 1.0-DYNX(Aux_,23);
DYNX(DYNhelp,341) = 1E-10*DYNX(DYNhelp,340);
DYNX(DYNhelp,342) = DYNX(Aux_,23)*DYNX(DYNhelp,312)+DYNX(DYNhelp,341);
DYNX(DYNhelp,343) = DYNX(Aux_,23)*DYNX(DYNhelp,311)+DYNX(DYNhelp,341);
DYNX(DYNhelp,344) = DYNX(DYNhelp,342)+DYNX(DYNhelp,343);
DYNX(W_,301) = divGuarded(DYNX(DYNhelp,342)*DYNX(W_,316)+DYNX(DYNhelp,343)*
  DYNX(W_,325),"(stream_alpha11*max(idealJunction_2.port_2.m_flow, 0.0)+1E-10*(1.0-stream_alpha11))*pipe_1.port_b.h_outflow+(stream_alpha11*max(idealJunction_2.port_3.m_flow, 0.0)+1E-10*(1.0-stream_alpha11))*pipe_2.port_a.h_outflow",
  DYNX(DYNhelp,344),"stream_alpha11*max(idealJunction_2.port_2.m_flow, 0.0)+1E-10*(1.0-stream_alpha11)+stream_alpha11*max(idealJunction_2.port_3.m_flow, 0.0)+1E-10*(1.0-stream_alpha11)");
DYNX(W_,308) = 0.0010044335697769957*DYNX(W_,297);
DYNX(W_,311) = 273.15+0.0002390057361376673*DYNX(W_,306);
DYNX(W_,309) = IF DYNX(W_,297) > DYNX(W_,116) THEN DYNX(W_,311) ELSE IF 
  DYNX(W_,297) <  -DYNX(W_,116) THEN 273.15+0.0002390057361376673*DYNX(W_,84)
   ELSE IF DYNX(W_,116) > 0 THEN 136.575+divGuarded(0.25*DYNX(W_,297)*(sqr(
  divGuarded(DYNX(W_,297),"valve_2.port_a.m_flow",DYNX(W_,116),"valve_2.m_flow_small"))
  -3)*(273.15+0.0002390057361376673*DYNX(W_,84)-DYNX(W_,311)),"0.25*(valve_2.port_a.m_flow*((valve_2.port_a.m_flow/valve_2.m_flow_small)^2-3)*(273.15+0.0002390057361376673*valve_2.port_a.h_outflow-valve_2.state_a.T))",
  DYNX(W_,116),"valve_2.m_flow_small")+0.5*(DYNX(W_,311)+0.0002390057361376673*
  DYNX(W_,84)) ELSE 136.575+0.5*(DYNX(W_,311)+0.0002390057361376673*DYNX(W_,84));
DYNX(W_,310) = IF  -DYNX(W_,297) > DYNX(W_,116) THEN DYNX(W_,119) ELSE IF  -
  DYNX(W_,297) <  -DYNX(W_,116) THEN 273.15+0.0002390057361376673*DYNX(W_,306)
   ELSE IF DYNX(W_,116) > 0 THEN 136.575+divGuarded((-0.25)*DYNX(W_,297)*(sqr(
  divGuarded(DYNX(W_,297),"valve_2.port_a.m_flow",DYNX(W_,116),"valve_2.m_flow_small"))
  -3)*(273.15+0.0002390057361376673*DYNX(W_,306)-DYNX(W_,119)),"(-0.25)*(valve_2.port_a.m_flow*((valve_2.port_a.m_flow/valve_2.m_flow_small)^2-3)*(273.15+0.0002390057361376673*valve_2.port_b.h_outflow-valve_2.state_b.T))",
  DYNX(W_,116),"valve_2.m_flow_small")+0.5*(DYNX(W_,119)+0.0002390057361376673*
  DYNX(W_,306)) ELSE 136.575+0.5*(DYNX(W_,119)+0.0002390057361376673*
  DYNX(W_,306));
DYNX(W_,317) = 273.15+0.0002390057361376673*DYNX(W_,282);
DYNX(W_,318) = 273.15+0.0002390057361376673*DYNX(W_,302);
if (NewParameters_) {
DYNX(DYNhelp,345) = divinvGuarded(DYNX(W_,123),"pipe_1.flowModel.crossAreas[1]");
}
if (NewParameters_) {
DYNX(DYNhelp,346) = divinvGuarded(DYNX(DP_,23),"pipe_1.nParallel");
}
DYNX(W_,319) = DYNX(DYNhelp,346)*DYNX(DYNhelp,345)*0.0010044335697769957*
  DYNX(W_,281);
DYNX(W_,320) =  -DYNX(DYNhelp,346)*DYNX(DYNhelp,345)*(-0.0010044335697769957)*
  DYNX(W_,281);
DYNX(W_,321) = DYNX(W_,281)*DYNX(DP_,24);
DYNX(W_,326) = 273.15+0.0002390057361376673*DYNX(W_,304);
DYNX(W_,327) = 273.15+0.0002390057361376673*DYNX(W_,306);
if (NewParameters_) {
DYNX(DYNhelp,347) = divinvGuarded(DYNX(W_,165),"pipe_2.flowModel.crossAreas[1]");
}
if (NewParameters_) {
DYNX(DYNhelp,348) = divinvGuarded(DYNX(DP_,33),"pipe_2.nParallel");
}
DYNX(W_,328) = DYNX(DYNhelp,348)*DYNX(DYNhelp,347)*0.0010044335697769957*
  DYNX(W_,297);
DYNX(W_,329) =  -DYNX(DYNhelp,348)*DYNX(DYNhelp,347)*(-0.0010044335697769957)*
  DYNX(W_,297);
DYNX(W_,330) = DYNX(W_,297)*DYNX(DP_,34);
DYNX(W_,334) = DYNX(W_,301)-DYNX(DP_,2)*DYNX(DP_,47);
DYNX(W_,335) = 273.15+0.0002390057361376673*DYNX(W_,301);
if (NewParameters_) {
DYNX(DYNhelp,349) = divinvGuarded(DYNX(W_,208),"pipe_3.flowModel.crossAreas[1]");
}
if (NewParameters_) {
DYNX(DYNhelp,350) = divinvGuarded(DYNX(DP_,43),"pipe_3.nParallel");
}
DYNX(W_,336) = DYNX(DYNhelp,350)*DYNX(DYNhelp,349)*0.0010044335697769957*
  DYNX(W_,298);
DYNX(W_,337) =  -DYNX(DYNhelp,350)*DYNX(DYNhelp,349)*(-0.0010044335697769957)*
  DYNX(W_,298);
DYNX(W_,338) = DYNX(W_,298)*DYNX(DP_,44);
DYNX(W_,348) = 0.0010044335697769957*DYNX(W_,281);
DYNX(W_,351) = 273.15+0.0002390057361376673*DYNX(W_,282);
DYNX(W_,349) = IF DYNX(W_,281) > DYNX(W_,276) THEN DYNX(W_,351) ELSE IF 
  DYNX(W_,281) <  -DYNX(W_,276) THEN 273.15+0.0002390057361376673*DYNX(W_,314)
   ELSE IF DYNX(W_,276) > 0 THEN 136.575+divGuarded(0.25*DYNX(W_,281)*(sqr(
  divGuarded(DYNX(W_,281)," -pump_1.port_b.m_flow",DYNX(W_,276),"valveDiscreteRamp.m_flow_small"))
  -3)*(273.15+0.0002390057361376673*DYNX(W_,314)-DYNX(W_,351)),"0.25*(( -pump_1.port_b.m_flow)*((( -pump_1.port_b.m_flow)/valveDiscreteRamp.m_flow_small)^2-3)*(273.15+0.0002390057361376673*valveDiscreteRamp.port_a.h_outflow-valveDiscreteRamp.state_a.T))",
  DYNX(W_,276),"valveDiscreteRamp.m_flow_small")+0.5*(DYNX(W_,351)+
  0.0002390057361376673*DYNX(W_,314)) ELSE 136.575+0.5*(DYNX(W_,351)+
  0.0002390057361376673*DYNX(W_,314));
DYNX(W_,352) = 273.15+0.0002390057361376673*DYNX(W_,314);
DYNX(W_,350) = IF  -DYNX(W_,281) > DYNX(W_,276) THEN DYNX(W_,352) ELSE IF  -
  DYNX(W_,281) <  -DYNX(W_,276) THEN 273.15+0.0002390057361376673*DYNX(W_,282)
   ELSE IF DYNX(W_,276) > 0 THEN 136.575+divGuarded((-0.25)*DYNX(W_,281)*(sqr(
  divGuarded(DYNX(W_,281)," -pump_1.port_b.m_flow",DYNX(W_,276),"valveDiscreteRamp.m_flow_small"))
  -3)*(273.15+0.0002390057361376673*DYNX(W_,282)-DYNX(W_,352)),"(-0.25)*(( -pump_1.port_b.m_flow)*((( -pump_1.port_b.m_flow)/valveDiscreteRamp.m_flow_small)^2-3)*(273.15+0.0002390057361376673*valveDiscreteRamp.port_b.h_outflow-valveDiscreteRamp.state_b.T))",
  DYNX(W_,276),"valveDiscreteRamp.m_flow_small")+0.5*(DYNX(W_,352)+
  0.0002390057361376673*DYNX(W_,282)) ELSE 136.575+0.5*(DYNX(W_,352)+
  0.0002390057361376673*DYNX(W_,282));

DefaultSection
InitializeData(1)
EndTranslatedEquations

#include <dsblock6.c>

PreNonAliasNew(0)
StartNonAlias(0)
DeclareParameter("system.p_ambient", "Default ambient pressure [Pa|bar]", 0, 101325,\
 0.0,1E+100,100000.0,0,560)
DeclareParameter("system.T_ambient", "Default ambient temperature [K|degC]", 1, \
293.15, 0.0,1E+100,300.0,0,560)
DeclareParameter("system.g", "Constant gravity acceleration [m/s2]", 2, 9.80665,\
 0.0,0.0,0.0,0,560)
DeclareVariable("system.allowFlowReversal", "= false to restrict to design flow direction (port_a -> port_b) [:#(type=Boolean)]",\
 0, true, 0.0,0.0,0.0,0,515)
DeclareVariable("system.energyDynamics", "Default formulation of energy balances [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 1, 1, 1.0,4.0,0.0,0,517)
DeclareVariable("system.massDynamics", "Default formulation of mass balances [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 2, 1, 1.0,4.0,0.0,0,517)
DeclareVariable("system.substanceDynamics", "Default formulation of substance balances [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 3, 1, 1.0,4.0,0.0,0,517)
DeclareVariable("system.traceDynamics", "Default formulation of trace substance balances [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 4, 1, 1.0,4.0,0.0,0,517)
DeclareVariable("system.momentumDynamics", "Default formulation of momentum balances, if options available [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 5, 4, 1.0,4.0,0.0,0,517)
DeclareVariable("system.m_flow_start", "Default start value for mass flow rates [kg/s]",\
 6, 0, 0.0,0.0,0.0,0,513)
DeclareVariable("system.p_start", "Default start value for pressures [Pa|bar]", 7,\
 0.0, 0.0,1E+100,100000.0,0,513)
DeclareVariable("system.T_start", "Default start value for temperatures [K|degC]",\
 8, 288.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("system.use_eps_Re", "= true to determine turbulent region automatically using Reynolds number [:#(type=Boolean)]",\
 9, false, 0.0,0.0,0.0,0,515)
DeclareVariable("system.m_flow_nominal", "Default nominal mass flow rate [kg/s]",\
 10, 0.0, 0.0,0.0,0.0,0,513)
DeclareParameter("system.eps_m_flow", "Regularization of zero flow for |m_flow| < eps_m_flow*m_flow_nominal [1]",\
 3, 0.0001, 0.0,1E+100,0.0,0,560)
DeclareParameter("system.dp_small", "Default small pressure drop for regularization of laminar and zero flow [Pa|bar]",\
 4, 1, 0.0,1E+100,100000.0,0,560)
DeclareParameter("system.m_flow_small", "Default small mass flow rate for regularization of laminar and zero flow [kg/s]",\
 5, 0.01, 0.0,1E+100,0.0,0,560)
DeclareVariable("pump_1.allowFlowReversal", "= true to allow flow reversal, false restricts to design direction (port_a -> port_b) [:#(type=Boolean)]",\
 11, true, 0.0,0.0,0.0,0,515)
DeclareVariable("pump_1.port_a.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 281, 0.0, -1E+60,100000.0,0.0,0,776)
DeclareAlias2("pump_1.port_a.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "source_1.p", 1, 5, 70, 4)
DeclareVariable("pump_1.port_a.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 282, 0.0, -10000000000.0,10000000000.0,1000000.0,0,520)
DeclareAlias2("pump_1.port_b.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "pipe_1.port_b.m_flow", 1, 5, 315, 132)
DeclareAlias2("pump_1.port_b.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "pump_1.medium.p", 1, 5, 283, 4)
DeclareAlias2("pump_1.port_b.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "pump_1.port_a.h_outflow", 1, 5, 282, 4)
DeclareParameter("pump_1.port_a_exposesState", "= true if port_a exposes the state of a fluid volume [:#(type=Boolean)]",\
 6, false, 0.0,0.0,0.0,0,2610)
DeclareVariable("pump_1.port_b_exposesState", "= true if port_b.p exposes the state of a fluid volume [:#(type=Boolean)]",\
 12, true, 0.0,0.0,0.0,0,2563)
DeclareParameter("pump_1.showDesignFlowDirection", "= false to hide the arrow in the model icon [:#(type=Boolean)]",\
 7, true, 0.0,0.0,0.0,0,2610)
DeclareVariable("pump_1.p_a_start", "Guess value for inlet pressure [Pa|bar]", 13,\
 100000.0, 0.0,100000000.0,100000.0,0,513)
DeclareVariable("pump_1.p_b_start", "Guess value for outlet pressure [Pa|bar]", 14,\
 100000.0, 0.0,100000000.0,100000.0,0,513)
DeclareParameter("pump_1.m_flow_start", "Guess value of m_flow = port_a.m_flow [kg/s]",\
 8, 0, -100000.0,100000.0,0.0,0,560)
DeclareVariable("pump_1.V_flow_single_init", "Used for simplified initialization model [m3/s]",\
 15, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("pump_1.delta_head_init", "Used for simplified initialization model [m]",\
 16, 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("pump_1.rho_nominal", "[kg/m3|g/cm3]", 17, 995.586, 0.0,100000.0,\
1.0,0,513)
DeclareVariable("pump_1.checkValve", "= true to prevent reverse flow [:#(type=Boolean)]",\
 18, false, 0.0,0.0,0.0,0,515)
DeclareVariable("pump_1.V", "Volume inside the pump [m3]", 19, 0.1, 0.0,0.0,0.0,\
0,513)
DeclareVariable("pump_1.fluidVolume", "Volume [m3]", 20, 0.1, 0.0,0.0,0.0,0,513)
DeclareVariable("pump_1.energyDynamics", "Formulation of energy balance [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 21, 2, 1.0,4.0,0.0,0,517)
DeclareVariable("pump_1.massDynamics", "Formulation of mass balance [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 22, 2, 1.0,4.0,0.0,0,517)
DeclareVariable("pump_1.substanceDynamics", "Formulation of substance balance [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 23, 2, 1.0,4.0,0.0,0,517)
DeclareVariable("pump_1.traceDynamics", "Formulation of trace substance balance [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 24, 2, 1.0,4.0,0.0,0,517)
DeclareVariable("pump_1.p_start", "Start value of pressure [Pa|bar]", 25, \
100000.0, 0.0,100000000.0,100000.0,0,513)
DeclareVariable("pump_1.use_T_start", "= true, use T_start, otherwise h_start [:#(type=Boolean)]",\
 26, true, 0.0,0.0,0.0,0,515)
DeclareVariable("pump_1.T_start", "Start value of temperature [K|degC]", 27, \
288.15, 1.0,10000.0,300.0,0,513)
DeclareVariable("pump_1.h_start", "Start value of specific enthalpy [J/kg]", 28,\
 0.0, -10000000000.0,10000000000.0,1000000.0,0,513)
DeclareParameter("pump_1.X_start[1]", "Start value of mass fractions m_i/m [kg/kg]",\
 9, 1.0, 0.0,1.0,0.1,0,560)
DeclareVariable("pump_1.medium.p", "Absolute pressure of medium [Pa|bar]", 283, \
0.0, 0.0,100000000.0,100000.0,0,512)
DeclareAlias2("pump_1.medium.h", "Specific enthalpy of medium [J/kg]", \
"pump_1.port_a.h_outflow", 1, 5, 282, 0)
DeclareVariable("pump_1.medium.d", "Density of medium [kg/m3|g/cm3]", 29, \
995.586, 0.0,100000.0,1.0,0,513)
DeclareState("pump_1.medium.T", "Temperature of medium [K|degC]", 0, 300.0, 1.0,\
10000.0,300.0,0,544)
DeclareDerivative("pump_1.medium.der(T)", "der(Temperature of medium) [K/s]", 0,\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("pump_1.medium.X[1]", "Mass fractions (= (component mass)/total mass  m_i/m) [kg/kg]",\
 30, 1.0, 0.0,1.0,0.1,0,513)
DeclareVariable("pump_1.medium.u", "Specific internal energy of medium [J/kg]", 284,\
 0.0, -100000000.0,100000000.0,1000000.0,0,512)
DeclareVariable("pump_1.medium.der(u)", "der(Specific internal energy of medium) [m2/s3]",\
 285, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("pump_1.medium.R_s", "Gas constant (of mixture if applicable) [J/(kg.K)]",\
 31, 0, 0.0,10000000.0,1000.0,0,513)
DeclareVariable("pump_1.medium.MM", "Molar mass (of mixture or single fluid) [kg/mol]",\
 32, 0.018015268, 0.001,0.25,0.032,0,513)
DeclareAlias2("pump_1.medium.state.p", "Absolute pressure of medium [Pa|bar]", \
"pump_1.medium.p", 1, 5, 283, 0)
DeclareAlias2("pump_1.medium.state.T", "Temperature of medium [K|degC]", \
"pump_1.medium.T", 1, 1, 0, 0)
DeclareVariable("pump_1.medium.preferredMediumStates", "= true if StateSelect.prefer shall be used for the independent property variables of the medium [:#(type=Boolean)]",\
 33, true, 0.0,0.0,0.0,0,515)
DeclareVariable("pump_1.medium.standardOrderComponents", "If true, and reducedX = true, the last element of X will be computed from the other ones [:#(type=Boolean)]",\
 34, true, 0.0,0.0,0.0,0,515)
DeclareVariable("pump_1.medium.T_degC", "Temperature of medium in [degC] [degC;]",\
 286, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("pump_1.medium.p_bar", "Absolute pressure of medium in [bar] [bar]",\
 287, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("pump_1.U", "Internal energy of fluid [J]", 288, 0.0, 0.0,0.0,\
0.0,0,512)
DeclareVariable("pump_1.der(U)", "der(Internal energy of fluid) [W]", 289, 0.0, \
0.0,0.0,0.0,0,512)
DeclareVariable("pump_1.m", "Mass of fluid [kg]", 35, 99.55860000000001, 0.0,\
1E+100,0.0,0,513)
DeclareVariable("pump_1.der(m)", "der(Mass of fluid) [kg/s]", 36, 0.0, 0.0,0.0,\
0.0,0,513)
DeclareVariable("pump_1.mb_flow", "Mass flows across boundaries [kg/s]", 37, 0.0,\
 0.0,0.0,0.0,0,513)
DeclareVariable("pump_1.Hb_flow", "Enthalpy flow across boundaries or energy source/sink [W]",\
 290, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("pump_1.Qb_flow", "Heat flow across boundaries or energy source/sink [W]",\
 38, 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("pump_1.Wb_flow", "Work flow across boundaries or source term [W]",\
 "P_pum_1", 1, 3, 4, 0)
DeclareVariable("pump_1.initialize_p", "= true to set up initial equations for pressure [:#(type=Boolean)]",\
 39, false, 0.0,0.0,0.0,0,2563)
DeclareVariable("pump_1.use_HeatTransfer", "= true to use a HeatTransfer model, e.g., for a housing [:#(type=Boolean)]",\
 40, false, 0.0,0.0,0.0,0,515)
DeclareVariable("pump_1.heatTransfer.n", "Number of heat transfer segments [:#(type=Integer)]",\
 41, 1, 0.0,0.0,0.0,0,517)
DeclareAlias2("pump_1.heatTransfer.states[1].p", "Absolute pressure of medium [Pa|bar]",\
 "pump_1.medium.p", 1, 5, 283, 0)
DeclareAlias2("pump_1.heatTransfer.states[1].T", "Temperature of medium [K|degC]",\
 "pump_1.medium.T", 1, 1, 0, 0)
DeclareVariable("pump_1.heatTransfer.surfaceAreas[1]", "Heat transfer areas [m2]",\
 42, 1.0418794157356093, 0.0,0.0,0.0,0,513)
DeclareVariable("pump_1.heatTransfer.Q_flows[1]", "Heat flow rates [W]", 43, 0.0,\
 0.0,0.0,0.0,0,513)
DeclareVariable("pump_1.heatTransfer.use_k", "= true to use k value for thermal isolation [:#(type=Boolean)]",\
 44, false, 0.0,0.0,0.0,0,515)
DeclareVariable("pump_1.heatTransfer.k", "Heat transfer coefficient to ambient [W/(m2.K)]",\
 45, 0, 0.0,0.0,0.0,0,513)
DeclareVariable("pump_1.heatTransfer.T_ambient", "Ambient temperature [K|degC]",\
 46, 288.15, 0.0,1E+100,300.0,0,513)
DeclareAlias2("pump_1.heatTransfer.heatPorts[1].T", "Port temperature [K|degC]",\
 "pump_1.medium.T", 1, 1, 0, 4)
DeclareVariable("pump_1.heatTransfer.heatPorts[1].Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 47, 0.0, 0.0,0.0,0.0,0,777)
DeclareAlias2("pump_1.heatTransfer.Ts[1]", "Temperatures defined by fluid states [K|degC]",\
 "pump_1.medium.T", 1, 1, 0, 0)
DeclareVariable("pump_1.g", "[m/s2]", 48, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("pump_1.rho", "[kg/m3|g/cm3]", 49, 995.586, 0.0,100000.0,1.0,0,513)
DeclareVariable("pump_1.dp_pump", "Pressure increase [Pa|bar]", 291, 0.0, \
0.0,0.0,0.0,0,512)
DeclareVariable("pump_1.head", "Pump head [m]", 292, 0.0, 0.0,1E+100,0.0,0,512)
DeclareAlias2("pump_1.m_flow", "Mass flow rate (total) [kg/s]", "pump_1.port_a.m_flow", 1,\
 5, 281, 0)
DeclareAlias2("pump_1.m_flow_single", "Mass flow rate (single pump) [kg/s]", \
"pump_1.port_a.m_flow", 1, 5, 281, 0)
DeclareVariable("pump_1.V_flow", "Volume flow rate (total) [m3/s]", 293, 0.0, \
0.0,0.0,0.0,0,512)
DeclareAlias2("pump_1.V_flow_single", "Volume flow rate (single pump) [m3/s]", \
"pump_1.V_flow", 1, 5, 293, 0)
DeclareVariable("pump_1.N", "Shaft rotational speed", 294, 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("pump_1.W_single", "Power Consumption (single pump) [W]", \
"P_pum_1", 1, 3, 4, 0)
DeclareAlias2("pump_1.W_total", "Power Consumption (total) [W]", "P_pum_1", 1, 3,\
 4, 0)
DeclareVariable("pump_1.eta", "Global Efficiency [1]", 295, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("pump_1.unit_m_flow", "[kg/s]", 50, 1, -100000.0,100000.0,0.0,0,1537)
DeclareVariable("pump_1.s", "Curvilinear abscissa for the flow curve in parametric form (either mass flow rate or head) [1]",\
 51, 0, 0.0,0.0,0.0,0,513)
DeclareVariable("pump_1.show_NPSHa", "obsolete -- remove modifier and specify Monitoring for NPSH instead [:#(type=Boolean)]",\
 52, false, 0.0,0.0,0.0,0,515)
DeclareAlias2("pump_1.monitoring.state_in.p", "Absolute pressure of medium [Pa|bar]",\
 "source_1.p", 1, 5, 70, 0)
DeclareVariable("pump_1.monitoring.state_in.T", "Temperature of medium [K|degC]",\
 53, 288.15, 1.0,10000.0,300.0,0,513)
DeclareAlias2("pump_1.monitoring.state.p", "Absolute pressure of medium [Pa|bar]",\
 "pump_1.medium.p", 1, 5, 283, 0)
DeclareAlias2("pump_1.monitoring.state.T", "Temperature of medium [K|degC]", \
"pump_1.medium.T", 1, 1, 0, 0)
DeclareVariable("pump_1.unitHead", "[m]", 54, 1, 0.0,1E+100,0.0,0,2561)
DeclareVariable("pump_1.unitMassFlowRate", "[kg/s]", 55, 1, 0.0,0.0,0.0,0,2561)
DeclareVariable("pump_1.use_N_in", "Get the relative rotational speed from the input connector [:#(type=Boolean)]",\
 56, true, 0.0,0.0,0.0,0,515)
DeclareParameter("pump_1.rpm_rel", "Rotational speed (relative)", 10, 0.93969, \
0.0,0.0,0.0,0,560)
DeclareAlias2("pump_1.N_in", "Prescribed rotational speed", "pump_1.N_in_internal", 1,\
 5, 296, 0)
DeclareVariable("pump_1.N_in_internal", "Needed to connect to conditional connector",\
 296, 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("source_1.nPorts", "Number of ports [:#(type=Integer)]", 57, 1, \
0.0,0.0,0.0,0,517)
DeclareAlias2("source_1.medium.p", "Absolute pressure of medium [Pa|bar]", \
"source_1.p", 1, 5, 70, 0)
DeclareAlias2("source_1.medium.h", "Specific enthalpy of medium [J/kg]", \
"source_1.ports[1].h_outflow", 1, 5, 67, 0)
DeclareVariable("source_1.medium.d", "Density of medium [kg/m3|g/cm3]", 58, \
995.586, 0.0,100000.0,1.0,0,513)
DeclareAlias2("source_1.medium.T", "Temperature of medium [K|degC]", \
"source_1.T", 1, 5, 73, 0)
DeclareVariable("source_1.medium.X[1]", "Mass fractions (= (component mass)/total mass  m_i/m) [kg/kg]",\
 59, 1.0, 0.0,1.0,0.1,0,513)
DeclareVariable("source_1.medium.u", "Specific internal energy of medium [J/kg]",\
 60, 0.0, -100000000.0,100000000.0,1000000.0,0,513)
DeclareVariable("source_1.medium.R_s", "Gas constant (of mixture if applicable) [J/(kg.K)]",\
 61, 0, 0.0,10000000.0,1000.0,0,513)
DeclareVariable("source_1.medium.MM", "Molar mass (of mixture or single fluid) [kg/mol]",\
 62, 0.018015268, 0.001,0.25,0.032,0,513)
DeclareAlias2("source_1.medium.state.p", "Absolute pressure of medium [Pa|bar]",\
 "source_1.p", 1, 5, 70, 0)
DeclareAlias2("source_1.medium.state.T", "Temperature of medium [K|degC]", \
"source_1.T", 1, 5, 73, 0)
DeclareVariable("source_1.medium.preferredMediumStates", "= true if StateSelect.prefer shall be used for the independent property variables of the medium [:#(type=Boolean)]",\
 63, false, 0.0,0.0,0.0,0,515)
DeclareVariable("source_1.medium.standardOrderComponents", "If true, and reducedX = true, the last element of X will be computed from the other ones [:#(type=Boolean)]",\
 64, true, 0.0,0.0,0.0,0,515)
DeclareVariable("source_1.medium.T_degC", "Temperature of medium in [degC] [degC;]",\
 65, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("source_1.medium.p_bar", "Absolute pressure of medium in [bar] [bar]",\
 66, 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("source_1.ports[1].m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "pipe_1.port_b.m_flow", 1, 5, 315, 132)
DeclareAlias2("source_1.ports[1].p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "source_1.p", 1, 5, 70, 4)
DeclareVariable("source_1.ports[1].h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 67, 0.0, -10000000000.0,10000000000.0,1000000.0,0,521)
DeclareVariable("source_1.flowDirection", "Allowed flow direction [:#(type=Modelica.Fluid.Types.PortFlowDirection)]",\
 68, 3, 1.0,3.0,0.0,0,2565)
DeclareVariable("source_1.use_p", "Select p or d [:#(type=Boolean)]", 69, true, \
0.0,0.0,0.0,0,515)
DeclareVariable("source_1.p", "Boundary pressure [Pa|bar]", 70, 100000.0, 0.0,\
100000000.0,100000.0,0,513)
DeclareVariable("source_1.d", "Boundary density [kg/m3|g/cm3]", 71, 995.586, 0.0,\
100000.0,1.0,0,513)
DeclareVariable("source_1.use_T", "Select T or h [:#(type=Boolean)]", 72, true, \
0.0,0.0,0.0,0,515)
DeclareVariable("source_1.T", "Boundary temperature [K|degC]", 73, 288.15, 1.0,\
10000.0,300.0,0,513)
DeclareParameter("source_1.h", "Boundary specific enthalpy [J/kg]", 11, 83680.0,\
 -10000000000.0,10000000000.0,1000000.0,0,560)
DeclareParameter("source_1.X[1]", "Boundary mass fractions m_i/m [kg/kg]", 12, \
1.0, 0.0,1.0,0.1,0,560)
DeclareAlias2("source_1.state.p", "Absolute pressure of medium [Pa|bar]", \
"source_1.p", 1, 5, 70, 1024)
DeclareAlias2("source_1.state.T", "Temperature of medium [K|degC]", "source_1.T", 1,\
 5, 73, 1024)
DeclareVariable("sink_2.nPorts", "Number of ports [:#(type=Integer)]", 74, 1, \
0.0,0.0,0.0,0,517)
DeclareAlias2("sink_2.medium.p", "Absolute pressure of medium [Pa|bar]", \
"sink_2.p", 1, 5, 87, 0)
DeclareAlias2("sink_2.medium.h", "Specific enthalpy of medium [J/kg]", \
"sink_2.ports[1].h_outflow", 1, 5, 84, 0)
DeclareVariable("sink_2.medium.d", "Density of medium [kg/m3|g/cm3]", 75, \
995.586, 0.0,100000.0,1.0,0,513)
DeclareAlias2("sink_2.medium.T", "Temperature of medium [K|degC]", "sink_2.T", 1,\
 5, 90, 0)
DeclareVariable("sink_2.medium.X[1]", "Mass fractions (= (component mass)/total mass  m_i/m) [kg/kg]",\
 76, 1.0, 0.0,1.0,0.1,0,513)
DeclareVariable("sink_2.medium.u", "Specific internal energy of medium [J/kg]", 77,\
 0.0, -100000000.0,100000000.0,1000000.0,0,513)
DeclareVariable("sink_2.medium.R_s", "Gas constant (of mixture if applicable) [J/(kg.K)]",\
 78, 0, 0.0,10000000.0,1000.0,0,513)
DeclareVariable("sink_2.medium.MM", "Molar mass (of mixture or single fluid) [kg/mol]",\
 79, 0.018015268, 0.001,0.25,0.032,0,513)
DeclareAlias2("sink_2.medium.state.p", "Absolute pressure of medium [Pa|bar]", \
"sink_2.p", 1, 5, 87, 0)
DeclareAlias2("sink_2.medium.state.T", "Temperature of medium [K|degC]", \
"sink_2.T", 1, 5, 90, 0)
DeclareVariable("sink_2.medium.preferredMediumStates", "= true if StateSelect.prefer shall be used for the independent property variables of the medium [:#(type=Boolean)]",\
 80, false, 0.0,0.0,0.0,0,515)
DeclareVariable("sink_2.medium.standardOrderComponents", "If true, and reducedX = true, the last element of X will be computed from the other ones [:#(type=Boolean)]",\
 81, true, 0.0,0.0,0.0,0,515)
DeclareVariable("sink_2.medium.T_degC", "Temperature of medium in [degC] [degC;]",\
 82, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("sink_2.medium.p_bar", "Absolute pressure of medium in [bar] [bar]",\
 83, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("sink_2.ports[1].m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 297, 0.0, 0.0,100000.0,0.0,0,776)
DeclareAlias2("sink_2.ports[1].p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "sink_2.p", 1, 5, 87, 4)
DeclareVariable("sink_2.ports[1].h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 84, 0.0, -10000000000.0,10000000000.0,1000000.0,0,521)
DeclareVariable("sink_2.flowDirection", "Allowed flow direction [:#(type=Modelica.Fluid.Types.PortFlowDirection)]",\
 85, 3, 1.0,3.0,0.0,0,2565)
DeclareVariable("sink_2.use_p", "Select p or d [:#(type=Boolean)]", 86, true, \
0.0,0.0,0.0,0,515)
DeclareVariable("sink_2.p", "Boundary pressure [Pa|bar]", 87, 100000.0, 0.0,\
100000000.0,100000.0,0,513)
DeclareVariable("sink_2.d", "Boundary density [kg/m3|g/cm3]", 88, 995.586, 0.0,\
100000.0,1.0,0,513)
DeclareVariable("sink_2.use_T", "Select T or h [:#(type=Boolean)]", 89, true, \
0.0,0.0,0.0,0,515)
DeclareVariable("sink_2.T", "Boundary temperature [K|degC]", 90, 288.15, 1.0,\
10000.0,300.0,0,513)
DeclareParameter("sink_2.h", "Boundary specific enthalpy [J/kg]", 13, 83680.0, \
-10000000000.0,10000000000.0,1000000.0,0,560)
DeclareParameter("sink_2.X[1]", "Boundary mass fractions m_i/m [kg/kg]", 14, 1.0,\
 0.0,1.0,0.1,0,560)
DeclareAlias2("sink_2.state.p", "Absolute pressure of medium [Pa|bar]", \
"sink_2.p", 1, 5, 87, 1024)
DeclareAlias2("sink_2.state.T", "Temperature of medium [K|degC]", "sink_2.T", 1,\
 5, 90, 1024)
DeclareVariable("source_4.nPorts", "Number of ports [:#(type=Integer)]", 91, 1, \
0.0,0.0,0.0,0,517)
DeclareAlias2("source_4.medium.p", "Absolute pressure of medium [Pa|bar]", \
"source_4.p", 1, 5, 104, 0)
DeclareAlias2("source_4.medium.h", "Specific enthalpy of medium [J/kg]", \
"source_4.ports[1].h_outflow", 1, 5, 101, 0)
DeclareVariable("source_4.medium.d", "Density of medium [kg/m3|g/cm3]", 92, \
995.586, 0.0,100000.0,1.0,0,513)
DeclareAlias2("source_4.medium.T", "Temperature of medium [K|degC]", \
"source_4.T", 1, 5, 107, 0)
DeclareVariable("source_4.medium.X[1]", "Mass fractions (= (component mass)/total mass  m_i/m) [kg/kg]",\
 93, 1.0, 0.0,1.0,0.1,0,513)
DeclareVariable("source_4.medium.u", "Specific internal energy of medium [J/kg]",\
 94, 0.0, -100000000.0,100000000.0,1000000.0,0,513)
DeclareVariable("source_4.medium.R_s", "Gas constant (of mixture if applicable) [J/(kg.K)]",\
 95, 0, 0.0,10000000.0,1000.0,0,513)
DeclareVariable("source_4.medium.MM", "Molar mass (of mixture or single fluid) [kg/mol]",\
 96, 0.018015268, 0.001,0.25,0.032,0,513)
DeclareAlias2("source_4.medium.state.p", "Absolute pressure of medium [Pa|bar]",\
 "source_4.p", 1, 5, 104, 0)
DeclareAlias2("source_4.medium.state.T", "Temperature of medium [K|degC]", \
"source_4.T", 1, 5, 107, 0)
DeclareVariable("source_4.medium.preferredMediumStates", "= true if StateSelect.prefer shall be used for the independent property variables of the medium [:#(type=Boolean)]",\
 97, false, 0.0,0.0,0.0,0,515)
DeclareVariable("source_4.medium.standardOrderComponents", "If true, and reducedX = true, the last element of X will be computed from the other ones [:#(type=Boolean)]",\
 98, true, 0.0,0.0,0.0,0,515)
DeclareVariable("source_4.medium.T_degC", "Temperature of medium in [degC] [degC;]",\
 99, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("source_4.medium.p_bar", "Absolute pressure of medium in [bar] [bar]",\
 100, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("source_4.ports[1].m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 298, 0.0, -1E+60,100000.0,0.0,0,776)
DeclareAlias2("source_4.ports[1].p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "source_4.p", 1, 5, 104, 4)
DeclareVariable("source_4.ports[1].h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 101, 0.0, -10000000000.0,10000000000.0,1000000.0,0,521)
DeclareVariable("source_4.flowDirection", "Allowed flow direction [:#(type=Modelica.Fluid.Types.PortFlowDirection)]",\
 102, 3, 1.0,3.0,0.0,0,2565)
DeclareVariable("source_4.use_p", "Select p or d [:#(type=Boolean)]", 103, true,\
 0.0,0.0,0.0,0,515)
DeclareVariable("source_4.p", "Boundary pressure [Pa|bar]", 104, 100000.0, 0.0,\
100000000.0,100000.0,0,513)
DeclareVariable("source_4.d", "Boundary density [kg/m3|g/cm3]", 105, 995.586, \
0.0,100000.0,1.0,0,513)
DeclareVariable("source_4.use_T", "Select T or h [:#(type=Boolean)]", 106, true,\
 0.0,0.0,0.0,0,515)
DeclareVariable("source_4.T", "Boundary temperature [K|degC]", 107, 288.15, 1.0,\
10000.0,300.0,0,513)
DeclareParameter("source_4.h", "Boundary specific enthalpy [J/kg]", 15, 83680.0,\
 -10000000000.0,10000000000.0,1000000.0,0,560)
DeclareParameter("source_4.X[1]", "Boundary mass fractions m_i/m [kg/kg]", 16, \
1.0, 0.0,1.0,0.1,0,560)
DeclareAlias2("source_4.state.p", "Absolute pressure of medium [Pa|bar]", \
"source_4.p", 1, 5, 104, 1024)
DeclareAlias2("source_4.state.T", "Temperature of medium [K|degC]", "source_4.T", 1,\
 5, 107, 1024)
DeclareVariable("idealJunction_2.port_1.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 299, 0.0, -1E+60,1E+60,0.0,0,776)
DeclareVariable("idealJunction_2.port_1.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 300, 100000.0, 0.0,100000000.0,100000.0,0,584)
DeclareVariable("idealJunction_2.port_1.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 301, 0.0, -10000000000.0,10000000000.0,1000000.0,0,520)
DeclareAlias2("idealJunction_2.port_2.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "pump_1.port_a.m_flow", 1, 5, 281, 132)
DeclareAlias2("idealJunction_2.port_2.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "idealJunction_2.port_1.p", 1, 5, 300, 4)
DeclareVariable("idealJunction_2.port_2.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 302, 0.0, -10000000000.0,10000000000.0,1000000.0,0,520)
DeclareVariable("idealJunction_2.port_3.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 303, 0.0, -100000.0,1E+60,0.0,0,776)
DeclareAlias2("idealJunction_2.port_3.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "idealJunction_2.port_1.p", 1, 5, 300, 4)
DeclareVariable("idealJunction_2.port_3.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 304, 0.0, -10000000000.0,10000000000.0,1000000.0,0,520)
DeclareVariable("idealJunction_2.portFlowDirection_1", "Flow direction for port_1 [:#(type=Modelica.Fluid.Types.PortFlowDirection)]",\
 108, 3, 1.0,3.0,0.0,0,2565)
DeclareVariable("idealJunction_2.portFlowDirection_2", "Flow direction for port_2 [:#(type=Modelica.Fluid.Types.PortFlowDirection)]",\
 109, 3, 1.0,3.0,0.0,0,2565)
DeclareVariable("idealJunction_2.portFlowDirection_3", "Flow direction for port_3 [:#(type=Modelica.Fluid.Types.PortFlowDirection)]",\
 110, 3, 1.0,3.0,0.0,0,2565)
DeclareVariable("valve_2.allowFlowReversal", "= true to allow flow reversal, false restricts to design direction (port_a -> port_b) [:#(type=Boolean)]",\
 111, false, 0.0,0.0,0.0,0,515)
DeclareAlias2("valve_2.port_a.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "sink_2.ports[1].m_flow", 1, 5, 297, 132)
DeclareVariable("valve_2.port_a.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 305, 100000.0, 0.0,100000000.0,100000.0,0,520)
DeclareAlias2("valve_2.port_a.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "sink_2.ports[1].h_outflow", 1, 5, 84, 4)
DeclareAlias2("valve_2.port_b.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "idealJunction_2.port_3.m_flow", 1, 5, 303, 132)
DeclareAlias2("valve_2.port_b.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "sink_2.p", 1, 5, 87, 4)
DeclareVariable("valve_2.port_b.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 306, 0.0, -10000000000.0,10000000000.0,1000000.0,0,520)
DeclareVariable("valve_2.port_a_exposesState", "= true if port_a exposes the state of a fluid volume [:#(type=Boolean)]",\
 112, false, 0.0,0.0,0.0,0,2563)
DeclareVariable("valve_2.port_b_exposesState", "= true if port_b.p exposes the state of a fluid volume [:#(type=Boolean)]",\
 113, false, 0.0,0.0,0.0,0,2563)
DeclareParameter("valve_2.showDesignFlowDirection", "= false to hide the arrow in the model icon [:#(type=Boolean)]",\
 17, true, 0.0,0.0,0.0,0,2610)
DeclareVariable("valve_2.dp_start", "Guess value of dp = port_a.p - port_b.p [Pa|bar]",\
 114, 100000.0, -1E+60,100000000.0,100000.0,0,513)
DeclareVariable("valve_2.m_flow_start", "Guess value of m_flow = port_a.m_flow [kg/s]",\
 115, 0.0, -100000.0,100000.0,0.0,0,513)
DeclareVariable("valve_2.m_flow_small", "Small mass flow rate for regularization of zero flow [kg/s]",\
 116, 0.0, -100000.0,100000.0,0.0,0,513)
DeclareVariable("valve_2.show_T", "= true, if temperatures at port_a and port_b are computed [:#(type=Boolean)]",\
 117, true, 0.0,0.0,0.0,0,515)
DeclareVariable("valve_2.show_V_flow", "= true, if volume flow rate at inflowing port is computed [:#(type=Boolean)]",\
 118, true, 0.0,0.0,0.0,0,515)
DeclareAlias2("valve_2.m_flow", "Mass flow rate in design flow direction [kg/s]",\
 "sink_2.ports[1].m_flow", 1, 5, 297, 0)
DeclareVariable("valve_2.dp", "Pressure difference between port_a and port_b (= port_a.p - port_b.p) [Pa|bar]",\
 307, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("valve_2.V_flow", "Volume flow rate at inflowing port (positive when flow from port_a to port_b) [m3/s]",\
 308, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("valve_2.port_a_T", "Temperature close to port_a, if show_T = true [K|degC]",\
 309, 288.15, 1.0,10000.0,300.0,0,512)
DeclareVariable("valve_2.port_b_T", "Temperature close to port_b, if show_T = true [K|degC]",\
 310, 288.15, 1.0,10000.0,300.0,0,512)
DeclareAlias2("valve_2.state_a.p", "Absolute pressure of medium [Pa|bar]", \
"valve_2.port_a.p", 1, 5, 305, 1024)
DeclareVariable("valve_2.state_a.T", "Temperature of medium [K|degC]", 311, \
288.15, 1.0,10000.0,300.0,0,2560)
DeclareAlias2("valve_2.state_b.p", "Absolute pressure of medium [Pa|bar]", \
"sink_2.p", 1, 5, 87, 1024)
DeclareVariable("valve_2.state_b.T", "Temperature of medium [K|degC]", 119, \
288.15, 1.0,10000.0,300.0,0,2561)
DeclareParameter("valve_2.dp_nominal", "Nominal pressure drop at full opening [Pa|bar]",\
 18, 100000, 0.0,1E+100,100000.0,0,560)
DeclareParameter("valve_2.m_flow_nominal", "Nominal mass flowrate at full opening [kg/s]",\
 19, 1, -100000.0,100000.0,0.0,0,560)
DeclareVariable("valve_2.k", "Hydraulic conductance at full opening [kg/(s.Pa)]",\
 120, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("valve_2.opening", "=1: completely open, =0: completely closed [1]",\
 312, 0.0, 0.0,1.0,0.0,0,512)
DeclareVariable("pipe_1.allowFlowReversal", "= true to allow flow reversal, false restricts to design direction (port_a -> port_b) [:#(type=Boolean)]",\
 121, true, 0.0,0.0,0.0,0,515)
DeclareAlias2("pipe_1.port_a.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "pump_1.port_a.m_flow", 1, 5, 281, 132)
DeclareVariable("pipe_1.port_a.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 313, 100000.0, 0.0,100000000.0,100000.0,0,520)
DeclareVariable("pipe_1.port_a.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 314, 0.0, -10000000000.0,10000000000.0,1000000.0,0,520)
DeclareVariable("pipe_1.port_b.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 315, 0.0, -100000.0,1E+60,0.0,0,776)
DeclareAlias2("pipe_1.port_b.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "idealJunction_2.port_1.p", 1, 5, 300, 4)
DeclareVariable("pipe_1.port_b.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 316, 0.0, -10000000000.0,10000000000.0,1000000.0,0,520)
DeclareParameter("pipe_1.port_a_exposesState", "= true if port_a exposes the state of a fluid volume [:#(type=Boolean)]",\
 20, false, 0.0,0.0,0.0,0,2610)
DeclareParameter("pipe_1.port_b_exposesState", "= true if port_b.p exposes the state of a fluid volume [:#(type=Boolean)]",\
 21, false, 0.0,0.0,0.0,0,2610)
DeclareParameter("pipe_1.showDesignFlowDirection", "= false to hide the arrow in the model icon [:#(type=Boolean)]",\
 22, true, 0.0,0.0,0.0,0,2610)
DeclareParameter("pipe_1.nParallel", "Number of identical parallel pipes [1]", 23,\
 1, 1.0,1E+100,0.0,0,560)
DeclareParameter("pipe_1.length", "Length [m]", 24, 20, 0.0,0.0,0.0,0,560)
DeclareVariable("pipe_1.isCircular", "= true, if cross sectional area is circular [:#(type=Boolean)]",\
 122, true, 0.0,0.0,0.0,0,515)
DeclareParameter("pipe_1.diameter", "Diameter of circular pipe [m|m]", 25, 0.025,\
 0.0,1E+100,0.0,0,560)
DeclareVariable("pipe_1.crossArea", "Inner cross section area [m2]", 123, 0.0, \
0.0,0.0,0.0,0,513)
DeclareVariable("pipe_1.perimeter", "Inner perimeter [m]", 124, 0.0, 0.0,1E+100,\
0.0,0,513)
DeclareParameter("pipe_1.roughness", "Average height of surface asperities (default: smooth steel pipe) [m|mm]",\
 26, 2.5E-05, 0.0,1E+100,0.0,0,560)
DeclareVariable("pipe_1.V", "Volume size [m3]", 125, 0.0, 0.0,0.0,0.0,0,513)
DeclareParameter("pipe_1.height_ab", "Height(port_b) - Height(port_a) [m]", 27, 0,\
 0.0,0.0,0.0,0,560)
DeclareVariable("pipe_1.p_a_start", "Start value of pressure at port a [Pa|bar]",\
 126, 100000.0, 0.0,100000000.0,100000.0,0,513)
DeclareVariable("pipe_1.p_b_start", "Start value of pressure at port b [Pa|bar]",\
 127, 100000.0, 0.0,100000000.0,100000.0,0,513)
DeclareVariable("pipe_1.m_flow_start", "Start value for mass flow rate [kg/s]", 128,\
 0.0, -100000.0,100000.0,0.0,0,513)
DeclareVariable("pipe_1.flowModel.from_dp", "= true, use m_flow = f(dp), otherwise dp = f(m_flow) [:#(type=Boolean)]",\
 129, true, 0.0,0.0,0.0,0,515)
DeclareVariable("pipe_1.flowModel.n", "Number of discrete flow volumes [:#(type=Integer)]",\
 130, 2, 0.0,0.0,0.0,0,517)
DeclareAlias2("pipe_1.flowModel.states[1].p", "Absolute pressure of medium [Pa|bar]",\
 "pipe_1.port_a.p", 1, 5, 313, 0)
DeclareVariable("pipe_1.flowModel.states[1].T", "Temperature of medium [K|degC]",\
 317, 288.15, 1.0,10000.0,300.0,0,512)
DeclareAlias2("pipe_1.flowModel.states[2].p", "Absolute pressure of medium [Pa|bar]",\
 "idealJunction_2.port_1.p", 1, 5, 300, 0)
DeclareVariable("pipe_1.flowModel.states[2].T", "Temperature of medium [K|degC]",\
 318, 288.15, 1.0,10000.0,300.0,0,512)
DeclareVariable("pipe_1.flowModel.vs[1]", "Mean velocities of fluid flow [m/s]",\
 319, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("pipe_1.flowModel.vs[2]", "Mean velocities of fluid flow [m/s]",\
 320, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("pipe_1.flowModel.nParallel", "Number of identical parallel flow devices [1]",\
 131, 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("pipe_1.flowModel.crossAreas[1]", "Cross flow areas at segment boundaries [m2]",\
 "pipe_1.crossArea", 1, 5, 123, 0)
DeclareAlias2("pipe_1.flowModel.crossAreas[2]", "Cross flow areas at segment boundaries [m2]",\
 "pipe_1.crossArea", 1, 5, 123, 0)
DeclareVariable("pipe_1.flowModel.dimensions[1]", "Characteristic dimensions for fluid flow (diameters for pipe flow) [m]",\
 132, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("pipe_1.flowModel.dimensions[2]", "Characteristic dimensions for fluid flow (diameters for pipe flow) [m]",\
 133, 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("pipe_1.flowModel.roughnesses[1]", "Average height of surface asperities [m|mm]",\
 "pipe_1.roughness", 1, 7, 26, 0)
DeclareAlias2("pipe_1.flowModel.roughnesses[2]", "Average height of surface asperities [m|mm]",\
 "pipe_1.roughness", 1, 7, 26, 0)
DeclareAlias2("pipe_1.flowModel.dheights[1]", "Height(states[2:n]) - Height(states[1:n-1]) [m]",\
 "pipe_1.height_ab", 1, 7, 27, 0)
DeclareVariable("pipe_1.flowModel.g", "Constant gravity acceleration [m/s2]", 134,\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("pipe_1.flowModel.allowFlowReversal", "= true, if flow reversal is enabled, otherwise restrict flow to design direction (states[1] -> states[n+1]) [:#(type=Boolean)]",\
 135, true, 0.0,0.0,0.0,0,515)
DeclareVariable("pipe_1.flowModel.momentumDynamics", "Formulation of momentum balance [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 136, 4, 1.0,4.0,0.0,0,517)
DeclareVariable("pipe_1.flowModel.m_flow_start", "Start value of mass flow rates [kg/s]",\
 137, 0.0, -100000.0,100000.0,0.0,0,513)
DeclareVariable("pipe_1.flowModel.p_a_start", "Start value for p[1] at design inflow [Pa|bar]",\
 138, 100000.0, 0.0,100000000.0,100000.0,0,513)
DeclareVariable("pipe_1.flowModel.p_b_start", "Start value for p[n+1] at design outflow [Pa|bar]",\
 139, 100000.0, 0.0,100000000.0,100000.0,0,513)
DeclareVariable("pipe_1.flowModel.m", "Number of flow segments [:#(type=Integer)]",\
 140, 1, 0.0,0.0,0.0,0,517)
DeclareAlias2("pipe_1.flowModel.pathLengths[1]", "Lengths along flow path [m]", \
"pipe_1.length", 1, 7, 24, 0)
DeclareAlias2("pipe_1.flowModel.m_flows[1]", "Mass flow rates between states [kg/s]",\
 "pump_1.port_a.m_flow", 1, 5, 281, 0)
DeclareVariable("pipe_1.flowModel.Is[1]", "Momenta of flow segments [kg.m/s]", 321,\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("pipe_1.flowModel.Ib_flows[1]", "Flow of momentum across boundaries [N]",\
 141, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("pipe_1.flowModel.Fs_p[1]", "Pressure forces [N]", 322, 0.0, \
0.0,0.0,0.0,0,512)
DeclareVariable("pipe_1.flowModel.Fs_fg[1]", "Friction and gravity forces [N]", 323,\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("pipe_1.flowModel.useUpstreamScheme", "= false to average upstream and downstream properties across flow segments [:#(type=Boolean)]",\
 142, true, 0.0,0.0,0.0,0,515)
DeclareVariable("pipe_1.flowModel.use_Ib_flows", "= true to consider differences in flow of momentum through boundaries [:#(type=Boolean)]",\
 143, false, 0.0,0.0,0.0,0,515)
DeclareVariable("pipe_1.flowModel.rhos[1]", "[kg/m3|g/cm3]", 144, 995.586, 0.0,\
100000.0,1.0,0,513)
DeclareVariable("pipe_1.flowModel.rhos[2]", "[kg/m3|g/cm3]", 145, 995.586, 0.0,\
100000.0,1.0,0,513)
DeclareVariable("pipe_1.flowModel.rhos_act[1]", "Actual density per segment [kg/m3|g/cm3]",\
 146, 995.586, 0.0,100000.0,1.0,0,513)
DeclareVariable("pipe_1.flowModel.mus[1]", "[Pa.s]", 147, 0.001, 0.0,100000000.0,\
0.001,0,513)
DeclareVariable("pipe_1.flowModel.mus[2]", "[Pa.s]", 148, 0.001, 0.0,100000000.0,\
0.001,0,513)
DeclareVariable("pipe_1.flowModel.mus_act[1]", "Actual viscosity per segment [Pa.s]",\
 149, 0.001, 0.0,100000000.0,0.001,0,513)
DeclareVariable("pipe_1.flowModel.dps_fg[1]", "Pressure drop between states [Pa|bar]",\
 324, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("pipe_1.flowModel.Re_turbulent", "Start of turbulent regime, depending on type of flow device [1]",\
 150, 4000, 0.0,0.0,0.0,0,513)
DeclareVariable("pipe_1.flowModel.show_Res", "= true, if Reynolds numbers are included for plotting [:#(type=Boolean)]",\
 151, false, 0.0,0.0,0.0,0,515)
DeclareVariable("pipe_1.flowModel.use_rho_nominal", "= true, if rho_nominal is used, otherwise computed from medium [:#(type=Boolean)]",\
 152, false, 0.0,0.0,0.0,0,2563)
DeclareParameter("pipe_1.flowModel.rho_nominal", "Nominal density (e.g., rho_liquidWater = 995, rho_air = 1.2) [kg/m3|g/cm3]",\
 28, 995.586, 0.0,1E+100,0.0,0,2608)
DeclareVariable("pipe_1.flowModel.use_mu_nominal", "= true, if mu_nominal is used, otherwise computed from medium [:#(type=Boolean)]",\
 153, false, 0.0,0.0,0.0,0,2563)
DeclareParameter("pipe_1.flowModel.mu_nominal", "Nominal dynamic viscosity (e.g., mu_liquidWater = 1e-3, mu_air = 1.8e-5) [Pa.s]",\
 29, 0.001, 0.0,1E+100,0.0,0,2608)
DeclareAlias2("pipe_1.flowModel.pathLengths_internal[1]", "pathLengths used internally; to be defined by extending class [m]",\
 "pipe_1.length", 1, 7, 24, 0)
DeclareVariable("pipe_1.flowModel.Res_turbulent_internal[1]", "Re_turbulent used internally; to be defined by extending class [1]",\
 154, 4000.0, 0.0,0.0,0.0,0,513)
DeclareVariable("pipe_1.flowModel.dp_nominal", "Nominal pressure loss (only for nominal models) [Pa|bar]",\
 155, 1, 0.0,1E+100,100000.0,0,513)
DeclareVariable("pipe_1.flowModel.m_flow_nominal", "Nominal mass flow rate [kg/s]",\
 156, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("pipe_1.flowModel.m_flow_small", "Within regularization if |m_flows| < m_flow_small (may be wider for large discontinuities in static head) [kg/s]",\
 157, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("pipe_1.flowModel.dp_small", "Within regularization if |dp| < dp_small (may be wider for large discontinuities in static head) [Pa|bar]",\
 158, 1, 0.0,1E+100,100000.0,0,2561)
DeclareVariable("pipe_1.flowModel.constantPressureLossCoefficient", \
"= true, if the pressure loss does not depend on fluid states [:#(type=Boolean)]",\
 159, false, 0.0,0.0,0.0,0,2563)
DeclareVariable("pipe_1.flowModel.continuousFlowReversal", "= true, if the pressure loss is continuous around zero flow [:#(type=Boolean)]",\
 160, false, 0.0,0.0,0.0,0,2563)
DeclareVariable("pipe_1.flowModel.diameters[1]", "Mean diameters between segments [m]",\
 161, 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("pipe_1.flowModel.dp_fric_nominal", "Pressure loss for nominal conditions [Pa|bar]",\
 162, 0.0, 0.0,1E+100,100000.0,0,2561)
DeclareVariable("pipe_2.allowFlowReversal", "= true to allow flow reversal, false restricts to design direction (port_a -> port_b) [:#(type=Boolean)]",\
 163, true, 0.0,0.0,0.0,0,515)
DeclareAlias2("pipe_2.port_a.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "sink_2.ports[1].m_flow", 1, 5, 297, 132)
DeclareAlias2("pipe_2.port_a.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "idealJunction_2.port_1.p", 1, 5, 300, 4)
DeclareVariable("pipe_2.port_a.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 325, 0.0, -10000000000.0,10000000000.0,1000000.0,0,520)
DeclareAlias2("pipe_2.port_b.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "idealJunction_2.port_3.m_flow", 1, 5, 303, 132)
DeclareAlias2("pipe_2.port_b.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "valve_2.port_a.p", 1, 5, 305, 4)
DeclareAlias2("pipe_2.port_b.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "valve_2.port_b.h_outflow", 1, 5, 306, 4)
DeclareParameter("pipe_2.port_a_exposesState", "= true if port_a exposes the state of a fluid volume [:#(type=Boolean)]",\
 30, false, 0.0,0.0,0.0,0,2610)
DeclareParameter("pipe_2.port_b_exposesState", "= true if port_b.p exposes the state of a fluid volume [:#(type=Boolean)]",\
 31, false, 0.0,0.0,0.0,0,2610)
DeclareParameter("pipe_2.showDesignFlowDirection", "= false to hide the arrow in the model icon [:#(type=Boolean)]",\
 32, true, 0.0,0.0,0.0,0,2610)
DeclareParameter("pipe_2.nParallel", "Number of identical parallel pipes [1]", 33,\
 1, 1.0,1E+100,0.0,0,560)
DeclareParameter("pipe_2.length", "Length [m]", 34, 20, 0.0,0.0,0.0,0,560)
DeclareVariable("pipe_2.isCircular", "= true, if cross sectional area is circular [:#(type=Boolean)]",\
 164, true, 0.0,0.0,0.0,0,515)
DeclareParameter("pipe_2.diameter", "Diameter of circular pipe [m|m]", 35, 0.025,\
 0.0,1E+100,0.0,0,560)
DeclareVariable("pipe_2.crossArea", "Inner cross section area [m2]", 165, 0.0, \
0.0,0.0,0.0,0,513)
DeclareVariable("pipe_2.perimeter", "Inner perimeter [m]", 166, 0.0, 0.0,1E+100,\
0.0,0,513)
DeclareParameter("pipe_2.roughness", "Average height of surface asperities (default: smooth steel pipe) [m|mm]",\
 36, 2.5E-05, 0.0,1E+100,0.0,0,560)
DeclareVariable("pipe_2.V", "Volume size [m3]", 167, 0.0, 0.0,0.0,0.0,0,513)
DeclareParameter("pipe_2.height_ab", "Height(port_b) - Height(port_a) [m]", 37, 0,\
 0.0,0.0,0.0,0,560)
DeclareVariable("pipe_2.p_a_start", "Start value of pressure at port a [Pa|bar]",\
 168, 100000.0, 0.0,100000000.0,100000.0,0,513)
DeclareVariable("pipe_2.p_b_start", "Start value of pressure at port b [Pa|bar]",\
 169, 100000.0, 0.0,100000000.0,100000.0,0,513)
DeclareVariable("pipe_2.m_flow_start", "Start value for mass flow rate [kg/s]", 170,\
 0.0, -100000.0,100000.0,0.0,0,513)
DeclareVariable("pipe_2.flowModel.from_dp", "= true, use m_flow = f(dp), otherwise dp = f(m_flow) [:#(type=Boolean)]",\
 171, true, 0.0,0.0,0.0,0,515)
DeclareVariable("pipe_2.flowModel.n", "Number of discrete flow volumes [:#(type=Integer)]",\
 172, 2, 0.0,0.0,0.0,0,517)
DeclareAlias2("pipe_2.flowModel.states[1].p", "Absolute pressure of medium [Pa|bar]",\
 "idealJunction_2.port_1.p", 1, 5, 300, 0)
DeclareVariable("pipe_2.flowModel.states[1].T", "Temperature of medium [K|degC]",\
 326, 288.15, 1.0,10000.0,300.0,0,512)
DeclareAlias2("pipe_2.flowModel.states[2].p", "Absolute pressure of medium [Pa|bar]",\
 "valve_2.port_a.p", 1, 5, 305, 0)
DeclareVariable("pipe_2.flowModel.states[2].T", "Temperature of medium [K|degC]",\
 327, 288.15, 1.0,10000.0,300.0,0,512)
DeclareVariable("pipe_2.flowModel.vs[1]", "Mean velocities of fluid flow [m/s]",\
 328, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("pipe_2.flowModel.vs[2]", "Mean velocities of fluid flow [m/s]",\
 329, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("pipe_2.flowModel.nParallel", "Number of identical parallel flow devices [1]",\
 173, 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("pipe_2.flowModel.crossAreas[1]", "Cross flow areas at segment boundaries [m2]",\
 "pipe_2.crossArea", 1, 5, 165, 0)
DeclareAlias2("pipe_2.flowModel.crossAreas[2]", "Cross flow areas at segment boundaries [m2]",\
 "pipe_2.crossArea", 1, 5, 165, 0)
DeclareVariable("pipe_2.flowModel.dimensions[1]", "Characteristic dimensions for fluid flow (diameters for pipe flow) [m]",\
 174, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("pipe_2.flowModel.dimensions[2]", "Characteristic dimensions for fluid flow (diameters for pipe flow) [m]",\
 175, 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("pipe_2.flowModel.roughnesses[1]", "Average height of surface asperities [m|mm]",\
 "pipe_2.roughness", 1, 7, 36, 0)
DeclareAlias2("pipe_2.flowModel.roughnesses[2]", "Average height of surface asperities [m|mm]",\
 "pipe_2.roughness", 1, 7, 36, 0)
DeclareAlias2("pipe_2.flowModel.dheights[1]", "Height(states[2:n]) - Height(states[1:n-1]) [m]",\
 "pipe_2.height_ab", 1, 7, 37, 0)
DeclareVariable("pipe_2.flowModel.g", "Constant gravity acceleration [m/s2]", 176,\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("pipe_2.flowModel.allowFlowReversal", "= true, if flow reversal is enabled, otherwise restrict flow to design direction (states[1] -> states[n+1]) [:#(type=Boolean)]",\
 177, true, 0.0,0.0,0.0,0,515)
DeclareVariable("pipe_2.flowModel.momentumDynamics", "Formulation of momentum balance [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 178, 4, 1.0,4.0,0.0,0,517)
DeclareVariable("pipe_2.flowModel.m_flow_start", "Start value of mass flow rates [kg/s]",\
 179, 0.0, -100000.0,100000.0,0.0,0,513)
DeclareVariable("pipe_2.flowModel.p_a_start", "Start value for p[1] at design inflow [Pa|bar]",\
 180, 100000.0, 0.0,100000000.0,100000.0,0,513)
DeclareVariable("pipe_2.flowModel.p_b_start", "Start value for p[n+1] at design outflow [Pa|bar]",\
 181, 100000.0, 0.0,100000000.0,100000.0,0,513)
DeclareVariable("pipe_2.flowModel.m", "Number of flow segments [:#(type=Integer)]",\
 182, 1, 0.0,0.0,0.0,0,517)
DeclareAlias2("pipe_2.flowModel.pathLengths[1]", "Lengths along flow path [m]", \
"pipe_2.length", 1, 7, 34, 0)
DeclareAlias2("pipe_2.flowModel.m_flows[1]", "Mass flow rates between states [kg/s]",\
 "sink_2.ports[1].m_flow", 1, 5, 297, 0)
DeclareVariable("pipe_2.flowModel.Is[1]", "Momenta of flow segments [kg.m/s]", 330,\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("pipe_2.flowModel.Ib_flows[1]", "Flow of momentum across boundaries [N]",\
 183, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("pipe_2.flowModel.Fs_p[1]", "Pressure forces [N]", 331, 0.0, \
0.0,0.0,0.0,0,512)
DeclareVariable("pipe_2.flowModel.Fs_fg[1]", "Friction and gravity forces [N]", 332,\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("pipe_2.flowModel.useUpstreamScheme", "= false to average upstream and downstream properties across flow segments [:#(type=Boolean)]",\
 184, true, 0.0,0.0,0.0,0,515)
DeclareVariable("pipe_2.flowModel.use_Ib_flows", "= true to consider differences in flow of momentum through boundaries [:#(type=Boolean)]",\
 185, false, 0.0,0.0,0.0,0,515)
DeclareVariable("pipe_2.flowModel.rhos[1]", "[kg/m3|g/cm3]", 186, 995.586, 0.0,\
100000.0,1.0,0,513)
DeclareVariable("pipe_2.flowModel.rhos[2]", "[kg/m3|g/cm3]", 187, 995.586, 0.0,\
100000.0,1.0,0,513)
DeclareVariable("pipe_2.flowModel.rhos_act[1]", "Actual density per segment [kg/m3|g/cm3]",\
 188, 995.586, 0.0,100000.0,1.0,0,513)
DeclareVariable("pipe_2.flowModel.mus[1]", "[Pa.s]", 189, 0.001, 0.0,100000000.0,\
0.001,0,513)
DeclareVariable("pipe_2.flowModel.mus[2]", "[Pa.s]", 190, 0.001, 0.0,100000000.0,\
0.001,0,513)
DeclareVariable("pipe_2.flowModel.mus_act[1]", "Actual viscosity per segment [Pa.s]",\
 191, 0.001, 0.0,100000000.0,0.001,0,513)
DeclareVariable("pipe_2.flowModel.dps_fg[1]", "Pressure drop between states [Pa|bar]",\
 333, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("pipe_2.flowModel.Re_turbulent", "Start of turbulent regime, depending on type of flow device [1]",\
 192, 4000, 0.0,0.0,0.0,0,513)
DeclareVariable("pipe_2.flowModel.show_Res", "= true, if Reynolds numbers are included for plotting [:#(type=Boolean)]",\
 193, false, 0.0,0.0,0.0,0,515)
DeclareVariable("pipe_2.flowModel.use_rho_nominal", "= true, if rho_nominal is used, otherwise computed from medium [:#(type=Boolean)]",\
 194, false, 0.0,0.0,0.0,0,2563)
DeclareParameter("pipe_2.flowModel.rho_nominal", "Nominal density (e.g., rho_liquidWater = 995, rho_air = 1.2) [kg/m3|g/cm3]",\
 38, 995.586, 0.0,1E+100,0.0,0,2608)
DeclareVariable("pipe_2.flowModel.use_mu_nominal", "= true, if mu_nominal is used, otherwise computed from medium [:#(type=Boolean)]",\
 195, false, 0.0,0.0,0.0,0,2563)
DeclareParameter("pipe_2.flowModel.mu_nominal", "Nominal dynamic viscosity (e.g., mu_liquidWater = 1e-3, mu_air = 1.8e-5) [Pa.s]",\
 39, 0.001, 0.0,1E+100,0.0,0,2608)
DeclareAlias2("pipe_2.flowModel.pathLengths_internal[1]", "pathLengths used internally; to be defined by extending class [m]",\
 "pipe_2.length", 1, 7, 34, 0)
DeclareVariable("pipe_2.flowModel.Res_turbulent_internal[1]", "Re_turbulent used internally; to be defined by extending class [1]",\
 196, 4000.0, 0.0,0.0,0.0,0,513)
DeclareVariable("pipe_2.flowModel.dp_nominal", "Nominal pressure loss (only for nominal models) [Pa|bar]",\
 197, 1, 0.0,1E+100,100000.0,0,513)
DeclareVariable("pipe_2.flowModel.m_flow_nominal", "Nominal mass flow rate [kg/s]",\
 198, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("pipe_2.flowModel.m_flow_small", "Within regularization if |m_flows| < m_flow_small (may be wider for large discontinuities in static head) [kg/s]",\
 199, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("pipe_2.flowModel.dp_small", "Within regularization if |dp| < dp_small (may be wider for large discontinuities in static head) [Pa|bar]",\
 200, 1, 0.0,1E+100,100000.0,0,2561)
DeclareVariable("pipe_2.flowModel.constantPressureLossCoefficient", \
"= true, if the pressure loss does not depend on fluid states [:#(type=Boolean)]",\
 201, false, 0.0,0.0,0.0,0,2563)
DeclareVariable("pipe_2.flowModel.continuousFlowReversal", "= true, if the pressure loss is continuous around zero flow [:#(type=Boolean)]",\
 202, false, 0.0,0.0,0.0,0,2563)
DeclareVariable("pipe_2.flowModel.diameters[1]", "Mean diameters between segments [m]",\
 203, 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("pipe_2.flowModel.dp_fric_nominal", "Pressure loss for nominal conditions [Pa|bar]",\
 204, 0.0, 0.0,1E+100,100000.0,0,2561)
DeclareVariable("pipe_3.allowFlowReversal", "= true to allow flow reversal, false restricts to design direction (port_a -> port_b) [:#(type=Boolean)]",\
 205, true, 0.0,0.0,0.0,0,515)
DeclareAlias2("pipe_3.port_a.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "source_4.ports[1].m_flow", 1, 5, 298, 132)
DeclareAlias2("pipe_3.port_a.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "idealJunction_2.port_1.p", 1, 5, 300, 4)
DeclareVariable("pipe_3.port_a.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 206, 0.0, -10000000000.0,10000000000.0,1000000.0,0,521)
DeclareAlias2("pipe_3.port_b.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "idealJunction_2.port_1.m_flow", 1, 5, 299, 132)
DeclareAlias2("pipe_3.port_b.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "source_4.p", 1, 5, 104, 4)
DeclareVariable("pipe_3.port_b.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 334, 0.0, -10000000000.0,10000000000.0,1000000.0,0,520)
DeclareParameter("pipe_3.port_a_exposesState", "= true if port_a exposes the state of a fluid volume [:#(type=Boolean)]",\
 40, false, 0.0,0.0,0.0,0,2610)
DeclareParameter("pipe_3.port_b_exposesState", "= true if port_b.p exposes the state of a fluid volume [:#(type=Boolean)]",\
 41, false, 0.0,0.0,0.0,0,2610)
DeclareParameter("pipe_3.showDesignFlowDirection", "= false to hide the arrow in the model icon [:#(type=Boolean)]",\
 42, true, 0.0,0.0,0.0,0,2610)
DeclareParameter("pipe_3.nParallel", "Number of identical parallel pipes [1]", 43,\
 1, 1.0,1E+100,0.0,0,560)
DeclareParameter("pipe_3.length", "Length [m]", 44, 20, 0.0,0.0,0.0,0,560)
DeclareVariable("pipe_3.isCircular", "= true, if cross sectional area is circular [:#(type=Boolean)]",\
 207, true, 0.0,0.0,0.0,0,515)
DeclareParameter("pipe_3.diameter", "Diameter of circular pipe [m|m]", 45, 0.025,\
 0.0,1E+100,0.0,0,560)
DeclareVariable("pipe_3.crossArea", "Inner cross section area [m2]", 208, 0.0, \
0.0,0.0,0.0,0,513)
DeclareVariable("pipe_3.perimeter", "Inner perimeter [m]", 209, 0.0, 0.0,1E+100,\
0.0,0,513)
DeclareParameter("pipe_3.roughness", "Average height of surface asperities (default: smooth steel pipe) [m|mm]",\
 46, 2.5E-05, 0.0,1E+100,0.0,0,560)
DeclareVariable("pipe_3.V", "Volume size [m3]", 210, 0.0, 0.0,0.0,0.0,0,513)
DeclareParameter("pipe_3.height_ab", "Height(port_b) - Height(port_a) [m]", 47, 0,\
 0.0,0.0,0.0,0,560)
DeclareVariable("pipe_3.p_a_start", "Start value of pressure at port a [Pa|bar]",\
 211, 100000.0, 0.0,100000000.0,100000.0,0,513)
DeclareVariable("pipe_3.p_b_start", "Start value of pressure at port b [Pa|bar]",\
 212, 100000.0, 0.0,100000000.0,100000.0,0,513)
DeclareVariable("pipe_3.m_flow_start", "Start value for mass flow rate [kg/s]", 213,\
 0.0, -100000.0,100000.0,0.0,0,513)
DeclareVariable("pipe_3.flowModel.from_dp", "= true, use m_flow = f(dp), otherwise dp = f(m_flow) [:#(type=Boolean)]",\
 214, true, 0.0,0.0,0.0,0,515)
DeclareVariable("pipe_3.flowModel.n", "Number of discrete flow volumes [:#(type=Integer)]",\
 215, 2, 0.0,0.0,0.0,0,517)
DeclareAlias2("pipe_3.flowModel.states[1].p", "Absolute pressure of medium [Pa|bar]",\
 "idealJunction_2.port_1.p", 1, 5, 300, 0)
DeclareVariable("pipe_3.flowModel.states[1].T", "Temperature of medium [K|degC]",\
 335, 288.15, 1.0,10000.0,300.0,0,512)
DeclareAlias2("pipe_3.flowModel.states[2].p", "Absolute pressure of medium [Pa|bar]",\
 "source_4.p", 1, 5, 104, 0)
DeclareVariable("pipe_3.flowModel.states[2].T", "Temperature of medium [K|degC]",\
 216, 288.15, 1.0,10000.0,300.0,0,513)
DeclareVariable("pipe_3.flowModel.vs[1]", "Mean velocities of fluid flow [m/s]",\
 336, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("pipe_3.flowModel.vs[2]", "Mean velocities of fluid flow [m/s]",\
 337, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("pipe_3.flowModel.nParallel", "Number of identical parallel flow devices [1]",\
 217, 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("pipe_3.flowModel.crossAreas[1]", "Cross flow areas at segment boundaries [m2]",\
 "pipe_3.crossArea", 1, 5, 208, 0)
DeclareAlias2("pipe_3.flowModel.crossAreas[2]", "Cross flow areas at segment boundaries [m2]",\
 "pipe_3.crossArea", 1, 5, 208, 0)
DeclareVariable("pipe_3.flowModel.dimensions[1]", "Characteristic dimensions for fluid flow (diameters for pipe flow) [m]",\
 218, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("pipe_3.flowModel.dimensions[2]", "Characteristic dimensions for fluid flow (diameters for pipe flow) [m]",\
 219, 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("pipe_3.flowModel.roughnesses[1]", "Average height of surface asperities [m|mm]",\
 "pipe_3.roughness", 1, 7, 46, 0)
DeclareAlias2("pipe_3.flowModel.roughnesses[2]", "Average height of surface asperities [m|mm]",\
 "pipe_3.roughness", 1, 7, 46, 0)
DeclareAlias2("pipe_3.flowModel.dheights[1]", "Height(states[2:n]) - Height(states[1:n-1]) [m]",\
 "pipe_3.height_ab", 1, 7, 47, 0)
DeclareVariable("pipe_3.flowModel.g", "Constant gravity acceleration [m/s2]", 220,\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("pipe_3.flowModel.allowFlowReversal", "= true, if flow reversal is enabled, otherwise restrict flow to design direction (states[1] -> states[n+1]) [:#(type=Boolean)]",\
 221, true, 0.0,0.0,0.0,0,515)
DeclareVariable("pipe_3.flowModel.momentumDynamics", "Formulation of momentum balance [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 222, 4, 1.0,4.0,0.0,0,517)
DeclareVariable("pipe_3.flowModel.m_flow_start", "Start value of mass flow rates [kg/s]",\
 223, 0.0, -100000.0,100000.0,0.0,0,513)
DeclareVariable("pipe_3.flowModel.p_a_start", "Start value for p[1] at design inflow [Pa|bar]",\
 224, 100000.0, 0.0,100000000.0,100000.0,0,513)
DeclareVariable("pipe_3.flowModel.p_b_start", "Start value for p[n+1] at design outflow [Pa|bar]",\
 225, 100000.0, 0.0,100000000.0,100000.0,0,513)
DeclareVariable("pipe_3.flowModel.m", "Number of flow segments [:#(type=Integer)]",\
 226, 1, 0.0,0.0,0.0,0,517)
DeclareAlias2("pipe_3.flowModel.pathLengths[1]", "Lengths along flow path [m]", \
"pipe_3.length", 1, 7, 44, 0)
DeclareAlias2("pipe_3.flowModel.m_flows[1]", "Mass flow rates between states [kg/s]",\
 "source_4.ports[1].m_flow", 1, 5, 298, 0)
DeclareVariable("pipe_3.flowModel.Is[1]", "Momenta of flow segments [kg.m/s]", 338,\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("pipe_3.flowModel.Ib_flows[1]", "Flow of momentum across boundaries [N]",\
 227, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("pipe_3.flowModel.Fs_p[1]", "Pressure forces [N]", 339, 0.0, \
0.0,0.0,0.0,0,512)
DeclareVariable("pipe_3.flowModel.Fs_fg[1]", "Friction and gravity forces [N]", 340,\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("pipe_3.flowModel.useUpstreamScheme", "= false to average upstream and downstream properties across flow segments [:#(type=Boolean)]",\
 228, true, 0.0,0.0,0.0,0,515)
DeclareVariable("pipe_3.flowModel.use_Ib_flows", "= true to consider differences in flow of momentum through boundaries [:#(type=Boolean)]",\
 229, false, 0.0,0.0,0.0,0,515)
DeclareVariable("pipe_3.flowModel.rhos[1]", "[kg/m3|g/cm3]", 230, 995.586, 0.0,\
100000.0,1.0,0,513)
DeclareVariable("pipe_3.flowModel.rhos[2]", "[kg/m3|g/cm3]", 231, 995.586, 0.0,\
100000.0,1.0,0,513)
DeclareVariable("pipe_3.flowModel.rhos_act[1]", "Actual density per segment [kg/m3|g/cm3]",\
 232, 995.586, 0.0,100000.0,1.0,0,513)
DeclareVariable("pipe_3.flowModel.mus[1]", "[Pa.s]", 233, 0.001, 0.0,100000000.0,\
0.001,0,513)
DeclareVariable("pipe_3.flowModel.mus[2]", "[Pa.s]", 234, 0.001, 0.0,100000000.0,\
0.001,0,513)
DeclareVariable("pipe_3.flowModel.mus_act[1]", "Actual viscosity per segment [Pa.s]",\
 235, 0.001, 0.0,100000000.0,0.001,0,513)
DeclareVariable("pipe_3.flowModel.dps_fg[1]", "Pressure drop between states [Pa|bar]",\
 341, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("pipe_3.flowModel.Re_turbulent", "Start of turbulent regime, depending on type of flow device [1]",\
 236, 4000, 0.0,0.0,0.0,0,513)
DeclareVariable("pipe_3.flowModel.show_Res", "= true, if Reynolds numbers are included for plotting [:#(type=Boolean)]",\
 237, false, 0.0,0.0,0.0,0,515)
DeclareVariable("pipe_3.flowModel.use_rho_nominal", "= true, if rho_nominal is used, otherwise computed from medium [:#(type=Boolean)]",\
 238, false, 0.0,0.0,0.0,0,2563)
DeclareParameter("pipe_3.flowModel.rho_nominal", "Nominal density (e.g., rho_liquidWater = 995, rho_air = 1.2) [kg/m3|g/cm3]",\
 48, 995.586, 0.0,1E+100,0.0,0,2608)
DeclareVariable("pipe_3.flowModel.use_mu_nominal", "= true, if mu_nominal is used, otherwise computed from medium [:#(type=Boolean)]",\
 239, false, 0.0,0.0,0.0,0,2563)
DeclareParameter("pipe_3.flowModel.mu_nominal", "Nominal dynamic viscosity (e.g., mu_liquidWater = 1e-3, mu_air = 1.8e-5) [Pa.s]",\
 49, 0.001, 0.0,1E+100,0.0,0,2608)
DeclareAlias2("pipe_3.flowModel.pathLengths_internal[1]", "pathLengths used internally; to be defined by extending class [m]",\
 "pipe_3.length", 1, 7, 44, 0)
DeclareVariable("pipe_3.flowModel.Res_turbulent_internal[1]", "Re_turbulent used internally; to be defined by extending class [1]",\
 240, 4000.0, 0.0,0.0,0.0,0,513)
DeclareVariable("pipe_3.flowModel.dp_nominal", "Nominal pressure loss (only for nominal models) [Pa|bar]",\
 241, 1, 0.0,1E+100,100000.0,0,513)
DeclareVariable("pipe_3.flowModel.m_flow_nominal", "Nominal mass flow rate [kg/s]",\
 242, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("pipe_3.flowModel.m_flow_small", "Within regularization if |m_flows| < m_flow_small (may be wider for large discontinuities in static head) [kg/s]",\
 243, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("pipe_3.flowModel.dp_small", "Within regularization if |dp| < dp_small (may be wider for large discontinuities in static head) [Pa|bar]",\
 244, 1, 0.0,1E+100,100000.0,0,2561)
DeclareVariable("pipe_3.flowModel.constantPressureLossCoefficient", \
"= true, if the pressure loss does not depend on fluid states [:#(type=Boolean)]",\
 245, false, 0.0,0.0,0.0,0,2563)
DeclareVariable("pipe_3.flowModel.continuousFlowReversal", "= true, if the pressure loss is continuous around zero flow [:#(type=Boolean)]",\
 246, false, 0.0,0.0,0.0,0,2563)
DeclareVariable("pipe_3.flowModel.diameters[1]", "Mean diameters between segments [m]",\
 247, 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("pipe_3.flowModel.dp_fric_nominal", "Pressure loss for nominal conditions [Pa|bar]",\
 248, 0.0, 0.0,1E+100,100000.0,0,2561)
DeclareVariable("volumeFlow_1.allowFlowReversal", "= true to allow flow reversal, false restricts to design direction (port_a -> port_b) [:#(type=Boolean)]",\
 249, true, 0.0,0.0,0.0,0,515)
DeclareAlias2("volumeFlow_1.port_a.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "pump_1.port_a.m_flow", 1, 5, 281, 132)
DeclareAlias2("volumeFlow_1.port_a.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "source_1.p", 1, 5, 70, 4)
DeclareAlias2("volumeFlow_1.port_a.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "pump_1.port_a.h_outflow", 1, 5, 282, 4)
DeclareAlias2("volumeFlow_1.port_b.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "pipe_1.port_b.m_flow", 1, 5, 315, 132)
DeclareAlias2("volumeFlow_1.port_b.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "source_1.p", 1, 5, 70, 4)
DeclareAlias2("volumeFlow_1.port_b.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "source_1.ports[1].h_outflow", 1, 5, 67, 4)
DeclareParameter("volumeFlow_1.port_a_exposesState", "= true if port_a exposes the state of a fluid volume [:#(type=Boolean)]",\
 50, false, 0.0,0.0,0.0,0,2610)
DeclareParameter("volumeFlow_1.port_b_exposesState", "= true if port_b.p exposes the state of a fluid volume [:#(type=Boolean)]",\
 51, false, 0.0,0.0,0.0,0,2610)
DeclareParameter("volumeFlow_1.showDesignFlowDirection", "= false to hide the arrow in the model icon [:#(type=Boolean)]",\
 52, true, 0.0,0.0,0.0,0,2610)
DeclareVariable("volumeFlow_1.m_flow_nominal", "Nominal value of m_flow = port_a.m_flow [kg/s]",\
 250, 0.0, -100000.0,100000.0,0.0,0,513)
DeclareVariable("volumeFlow_1.m_flow_small", "Regularization for bi-directional flow in the region |m_flow| < m_flow_small (m_flow_small > 0 required) [kg/s]",\
 251, 0.0, 0.0,100000.0,0.0,0,513)
DeclareVariable("volumeFlow_1.V_flow", "Volume flow rate from port_a to port_b [m3/s]",\
 342, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("volumeFlow_1.rho_a_inflow", "Density of inflowing fluid at port_a [kg/m3|g/cm3]",\
 252, 995.586, 0.0,100000.0,1.0,0,2561)
DeclareVariable("volumeFlow_1.rho_b_inflow", "Density of inflowing fluid at port_b or rho_a_inflow, if uni-directional flow [kg/m3|g/cm3]",\
 253, 995.586, 0.0,100000.0,1.0,0,2561)
DeclareVariable("volumeFlow_1.d", "Density of the passing fluid [kg/m3|g/cm3]", 254,\
 995.586, 0.0,100000.0,1.0,0,2561)
DeclareVariable("pressure_1.port_a.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 255, 0, 0.0,100000.0,0.0,0,777)
DeclareAlias2("pressure_1.port_a.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "pipe_1.port_a.p", 1, 5, 313, 4)
DeclareVariable("pressure_1.port_a.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 256, 83680.0, -10000000000.0,10000000000.0,1000000.0,0,521)
DeclareVariable("pressure_1.port_b.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 257, 0, 0.0,100000.0,0.0,0,777)
DeclareAlias2("pressure_1.port_b.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "source_1.p", 1, 5, 70, 4)
DeclareVariable("pressure_1.port_b.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 258, 83680.0, -10000000000.0,10000000000.0,1000000.0,0,521)
DeclareVariable("pressure_1.p_rel", "Relative pressure signal [Pa|bar]", 343, \
0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("volumeFlow_2.allowFlowReversal", "= true to allow flow reversal, false restricts to design direction (port_a -> port_b) [:#(type=Boolean)]",\
 259, true, 0.0,0.0,0.0,0,515)
DeclareAlias2("volumeFlow_2.port_a.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "sink_2.ports[1].m_flow", 1, 5, 297, 132)
DeclareAlias2("volumeFlow_2.port_a.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "valve_2.port_a.p", 1, 5, 305, 4)
DeclareAlias2("volumeFlow_2.port_a.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "valve_2.port_b.h_outflow", 1, 5, 306, 4)
DeclareAlias2("volumeFlow_2.port_b.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "idealJunction_2.port_3.m_flow", 1, 5, 303, 132)
DeclareAlias2("volumeFlow_2.port_b.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "valve_2.port_a.p", 1, 5, 305, 4)
DeclareAlias2("volumeFlow_2.port_b.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "valve_2.port_b.h_outflow", 1, 5, 306, 4)
DeclareParameter("volumeFlow_2.port_a_exposesState", "= true if port_a exposes the state of a fluid volume [:#(type=Boolean)]",\
 53, false, 0.0,0.0,0.0,0,2610)
DeclareParameter("volumeFlow_2.port_b_exposesState", "= true if port_b.p exposes the state of a fluid volume [:#(type=Boolean)]",\
 54, false, 0.0,0.0,0.0,0,2610)
DeclareParameter("volumeFlow_2.showDesignFlowDirection", "= false to hide the arrow in the model icon [:#(type=Boolean)]",\
 55, true, 0.0,0.0,0.0,0,2610)
DeclareVariable("volumeFlow_2.m_flow_nominal", "Nominal value of m_flow = port_a.m_flow [kg/s]",\
 260, 0.0, -100000.0,100000.0,0.0,0,513)
DeclareVariable("volumeFlow_2.m_flow_small", "Regularization for bi-directional flow in the region |m_flow| < m_flow_small (m_flow_small > 0 required) [kg/s]",\
 261, 0.0, 0.0,100000.0,0.0,0,513)
DeclareVariable("volumeFlow_2.V_flow", "Volume flow rate from port_a to port_b [m3/s]",\
 344, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("volumeFlow_2.rho_a_inflow", "Density of inflowing fluid at port_a [kg/m3|g/cm3]",\
 262, 995.586, 0.0,100000.0,1.0,0,2561)
DeclareVariable("volumeFlow_2.rho_b_inflow", "Density of inflowing fluid at port_b or rho_a_inflow, if uni-directional flow [kg/m3|g/cm3]",\
 263, 995.586, 0.0,100000.0,1.0,0,2561)
DeclareVariable("volumeFlow_2.d", "Density of the passing fluid [kg/m3|g/cm3]", 264,\
 995.586, 0.0,100000.0,1.0,0,2561)
DeclareVariable("pressure_2.port_a.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 265, 0, 0.0,100000.0,0.0,0,777)
DeclareAlias2("pressure_2.port_a.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "valve_2.port_a.p", 1, 5, 305, 4)
DeclareVariable("pressure_2.port_a.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 266, 83680.0, -10000000000.0,10000000000.0,1000000.0,0,521)
DeclareVariable("pressure_2.port_b.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 267, 0, 0.0,100000.0,0.0,0,777)
DeclareAlias2("pressure_2.port_b.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "sink_2.p", 1, 5, 87, 4)
DeclareVariable("pressure_2.port_b.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 268, 83680.0, -10000000000.0,10000000000.0,1000000.0,0,521)
DeclareVariable("pressure_2.p_rel", "Relative pressure signal [Pa|bar]", 345, \
0.0, 0.0,0.0,0.0,0,512)
DeclareOutput("V_flow_1", "Connector of Real output signal containing input signal u in another unit [m3/h]",\
 0, 0.0, 0.0,0.0,0.0,0,512)
DeclareOutput("p_rel_1", "Relative pressure signal [bar]", 1, 0.0, 0.0,0.0,0.0,0,512)
DeclareInput("w_p_1", "Prescribed rotational speed [:#(prefix=input)]", 0, 0.0, \
0.0,0.0,0.0,0,512)
DeclareOutput("V_flow_2", "Connector of Real output signal containing input signal u in another unit [m3/h]",\
 2, 0.0, 0.0,0.0,0.0,0,512)
DeclareOutput("p_rel_2", "Relative pressure signal [bar]", 3, 0.0, 0.0,0.0,0.0,0,512)
DeclareInput("w_v_2", "Connector of setpoint input signal [:#(prefix=input)]", 1,\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("to_bar.u", "Connector of Real input signal to be converted [Pa]",\
 "pressure_1.p_rel", 1, 5, 343, 0)
DeclareAlias2("to_bar.y", "Connector of Real output signal containing input signal u in another unit [bar]",\
 "p_rel_1", 1, 3, 1, 0)
DeclareAlias2("to_bar2.u", "Connector of Real input signal to be converted [Pa]",\
 "pressure_2.p_rel", 1, 5, 345, 0)
DeclareAlias2("to_bar2.y", "Connector of Real output signal containing input signal u in another unit [bar]",\
 "p_rel_2", 1, 3, 3, 0)
DeclareAlias2("to_m3hr.u", "Connector of Real input signal to be converted [m3/s]",\
 "volumeFlow_1.V_flow", 1, 5, 342, 0)
DeclareAlias2("to_m3hr.y", "Connector of Real output signal containing input signal u in another unit [m3/h]",\
 "V_flow_1", 1, 3, 0, 0)
DeclareAlias2("to_m3hr2.u", "Connector of Real input signal to be converted [m3/s]",\
 "volumeFlow_2.V_flow", 1, 5, 344, 0)
DeclareAlias2("to_m3hr2.y", "Connector of Real output signal containing input signal u in another unit [m3/h]",\
 "V_flow_2", 1, 3, 2, 0)
DeclareOutput("P_pum_1", "[W]", 4, 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("fixedDelay.u", "Connector of Real input signal", "w_p_1", 1, 2, 0,\
 0)
DeclareVariable("fixedDelay.y", "Connector of Real output signal", 346, 0.0, \
0.0,0.0,0.0,0,512)
DeclareParameter("fixedDelay.delayTime", "Delay time of output with respect to input signal [s]",\
 56, 0.1, 0.0,0.0,0.0,0,560)
DeclareAlias2("fixedDelay3.u", "Connector of Real input signal", "w_v_2", 1, 2, 1,\
 0)
DeclareAlias2("fixedDelay3.y", "Connector of Real output signal [1]", \
"valve_2.opening", 1, 5, 312, 0)
DeclareParameter("fixedDelay3.delayTime", "Delay time of output with respect to input signal [s]",\
 57, 0.1, 0.0,0.0,0.0,0,560)
DeclareParameter("greaterThreshold.threshold", "Comparison with respect to threshold",\
 58, 0.01, 0.0,0.0,0.0,0,560)
DeclareAlias2("greaterThreshold.u", "Connector of Real input signal", \
"fixedDelay.y", 1, 5, 346, 0)
DeclareVariable("greaterThreshold.y", "Connector of Boolean output signal [:#(type=Boolean)]",\
 280, false, 0.0,0.0,0.0,0,642)
DeclareAlias2("switch1.u1", "Connector of first Real input signal", \
"fixedDelay.y", 1, 5, 346, 0)
DeclareAlias2("switch1.u2", "Connector of Boolean input signal [:#(type=Boolean)]",\
 "greaterThreshold.y", 1, 5, 280, 65)
DeclareVariable("switch1.u3", "Connector of second Real input signal", 269, 0, \
0.0,0.0,0.0,0,513)
DeclareAlias2("switch1.y", "Connector of Real output signal", "pump_1.N_in_internal", 1,\
 5, 296, 0)
DeclareVariable("realExpression.y", "Value of Real output", 270, 0.0, 0.0,0.0,\
0.0,0,513)
DeclareVariable("valveDiscreteRamp.allowFlowReversal", "= true to allow flow reversal, false restricts to design direction (port_a -> port_b) [:#(type=Boolean)]",\
 271, true, 0.0,0.0,0.0,0,515)
DeclareAlias2("valveDiscreteRamp.port_a.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "pump_1.port_a.m_flow", 1, 5, 281, 132)
DeclareAlias2("valveDiscreteRamp.port_a.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "pump_1.medium.p", 1, 5, 283, 4)
DeclareAlias2("valveDiscreteRamp.port_a.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "pipe_1.port_a.h_outflow", 1, 5, 314, 4)
DeclareAlias2("valveDiscreteRamp.port_b.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "pipe_1.port_b.m_flow", 1, 5, 315, 132)
DeclareAlias2("valveDiscreteRamp.port_b.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "pipe_1.port_a.p", 1, 5, 313, 4)
DeclareAlias2("valveDiscreteRamp.port_b.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "pump_1.port_a.h_outflow", 1, 5, 282, 4)
DeclareVariable("valveDiscreteRamp.port_a_exposesState", "= true if port_a exposes the state of a fluid volume [:#(type=Boolean)]",\
 272, false, 0.0,0.0,0.0,0,2563)
DeclareVariable("valveDiscreteRamp.port_b_exposesState", "= true if port_b.p exposes the state of a fluid volume [:#(type=Boolean)]",\
 273, false, 0.0,0.0,0.0,0,2563)
DeclareParameter("valveDiscreteRamp.showDesignFlowDirection", "= false to hide the arrow in the model icon [:#(type=Boolean)]",\
 59, true, 0.0,0.0,0.0,0,2610)
DeclareVariable("valveDiscreteRamp.dp_start", "Guess value of dp = port_a.p - port_b.p [Pa|bar]",\
 274, 100000.0, -1E+60,100000000.0,100000.0,0,513)
DeclareVariable("valveDiscreteRamp.m_flow_start", "Guess value of m_flow = port_a.m_flow [kg/s]",\
 275, 0.0, -100000.0,100000.0,0.0,0,513)
DeclareVariable("valveDiscreteRamp.m_flow_small", "Small mass flow rate for regularization of zero flow [kg/s]",\
 276, 0.0, -100000.0,100000.0,0.0,0,513)
DeclareVariable("valveDiscreteRamp.show_T", "= true, if temperatures at port_a and port_b are computed [:#(type=Boolean)]",\
 277, true, 0.0,0.0,0.0,0,515)
DeclareVariable("valveDiscreteRamp.show_V_flow", "= true, if volume flow rate at inflowing port is computed [:#(type=Boolean)]",\
 278, true, 0.0,0.0,0.0,0,515)
DeclareAlias2("valveDiscreteRamp.m_flow", "Mass flow rate in design flow direction [kg/s]",\
 "pump_1.port_a.m_flow", 1, 5, 281, 0)
DeclareVariable("valveDiscreteRamp.dp", "Pressure difference between port_a and port_b (= port_a.p - port_b.p) [Pa|bar]",\
 347, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("valveDiscreteRamp.V_flow", "Volume flow rate at inflowing port (positive when flow from port_a to port_b) [m3/s]",\
 348, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("valveDiscreteRamp.port_a_T", "Temperature close to port_a, if show_T = true [K|degC]",\
 349, 288.15, 1.0,10000.0,300.0,0,512)
DeclareVariable("valveDiscreteRamp.port_b_T", "Temperature close to port_b, if show_T = true [K|degC]",\
 350, 288.15, 1.0,10000.0,300.0,0,512)
DeclareAlias2("valveDiscreteRamp.state_a.p", "Absolute pressure of medium [Pa|bar]",\
 "pump_1.medium.p", 1, 5, 283, 1024)
DeclareVariable("valveDiscreteRamp.state_a.T", "Temperature of medium [K|degC]",\
 351, 288.15, 1.0,10000.0,300.0,0,2560)
DeclareAlias2("valveDiscreteRamp.state_b.p", "Absolute pressure of medium [Pa|bar]",\
 "pipe_1.port_a.p", 1, 5, 313, 1024)
DeclareVariable("valveDiscreteRamp.state_b.T", "Temperature of medium [K|degC]",\
 352, 288.15, 1.0,10000.0,300.0,0,2560)
DeclareParameter("valveDiscreteRamp.dp_nominal", "Nominal pressure drop at full opening=1 [Pa|bar]",\
 60, 1, 0.0,1E+100,100000.0,0,560)
DeclareParameter("valveDiscreteRamp.m_flow_nominal", "Nominal mass flowrate at full opening=1 [kg/s]",\
 61, 100, -100000.0,100000.0,0.0,0,560)
DeclareVariable("valveDiscreteRamp.k", "Hydraulic conductance at full opening=1 [kg/(s.Pa)]",\
 279, 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("valveDiscreteRamp.open", "[:#(type=Boolean)]", "greaterThreshold.y", 1,\
 5, 280, 65)
DeclareParameter("valveDiscreteRamp.opening_min", "Remaining opening if closed, causing small leakage flow [1]",\
 62, 0, 0.0,1E+100,0.0,0,560)
EndNonAlias(0)

#define DymolaHaveUpdateInitVars 1
#include <dsblock5.c>

DYMOLA_STATIC void UpdateInitVars(double*time, double* X_, double* XD_, double* U_, double* DP_, int IP_[], Dymola_bool LP_[], double* F_, double* Y_, double* W_, double QZ_[], double duser_[], int iuser_[], void*cuser_[],struct DYNInstanceData*did_,int initialCall) {
if (initialCall) DYNX(did_->xInitial_var, 1)=DYNX(W_,300);
else if (DYNHReject) DYNX(W_,300)=did_->xInitial_var2[1]; else did_->xInitial_var2[1]=
  DYNX(W_,300);
if (initialCall) DYNX(did_->xInitial_var, 0)=DYNX(W_,347);
else if (DYNHReject) DYNX(W_,347)=did_->xInitial_var2[0]; else did_->xInitial_var2[0]=
  DYNX(W_,347);
if (initialCall) DYNX(did_->xInitial_var, 2)=DYNX(W_,307);
else if (DYNHReject) DYNX(W_,307)=did_->xInitial_var2[2]; else did_->xInitial_var2[2]=
  DYNX(W_,307);
}
StartDataBlock
StartPreBlock
preWD(DYNX(W_,280),"greaterThreshold.y", false, 0);
preContI(DYNX(U_,0),"w_p_1", 0.0, 1);
preContI(DYNX(U_,1),"w_v_2", 0.0, 2);
EndPreBlock
DYNPreInp(DYNX(U_,0),"w_p_1", 1);
DYNPreInp(DYNX(U_,1),"w_v_2", 2);
StartEqBlock
DoRemember_(DYNX(W_,300), 100000.0, 1);
DoRemember_(DYNX(W_,313), 100000.0, 2);
DoRemember_(DYNX(W_,283), DYNX(W_,25), 3);
DoRemember_(DYNX(W_,305), 100000.0, 0);
EndEqBlock
EndDataBlock
BreakSectionStart(3);
/* Introducing 22 common subexpressions whereof 3 are global used in 29
   expressions */
/* Of the common subexpressions 22 are reals, 0 are integers, and 0
   are booleans. */

{ /* Non-linear system of equations to solve. */
/* Tag: simplified homotopy initialization.nonlinear[1] */
const char*const varnames_[]={"valveDiscreteRamp.dp", "idealJunction_2.port_1.p",
   "valve_2.dp"};
const double nominal_[]={100000.0, 100000.0, 100000.0};
static const int sJacobianCG_[1] = {-1};
static const struct QJacobianTag_ sJacobianGC2_[1] = {{-1,0}};
NonLinearSystemOfEquations(Jacobian__, residue__, x__, 3, 0, 0, 1, -2, 
  DYNX(DYNhelp,9), 68, DYNX(did_->helpvari_vec,0), 25);
SetInitVector(x__, 1, DYNX(W_,347), DYNX(W_,274));
SetInitVectorSimple(x__, 2, DYNX(W_,300), 1, 100000.0);
SetInitVector(x__, 3, DYNX(W_,307), DYNX(W_,114));
Residues;
  DYNX(W_,281) = IF DYNX(W_,280) THEN 1*DYNX(W_,279)*DYNX(W_,347) ELSE 
    DYNX(DP_,62)*DYNX(W_,279)*DYNX(W_,347);
  DYNX(W_,293) = 0.0010044335697769957*DYNX(W_,281);
  DYNX(W_,292) = 1231.056*DYNX(W_,293)*DYNX(W_,294)-0.065158*sqr(3600*
    DYNX(W_,293))+8.1602*sqr(DYNX(W_,294));
  DYNX(W_,291) = 995.586*DYNX(W_,292)*DYNX(W_,48);
  DYNX(W_,283) = DYNX(W_,291)+DYNX(W_,70);
  DYNX(W_,313) = DYNX(W_,283)-DYNX(W_,347);
  DYNX(W_,339) = DYNX(W_,217)*DYNX(W_,208)*(DYNX(W_,104)-DYNX(W_,300));
  DYNX(DYNhelp,77) = 2.0*DYNX(W_,208);
  DYNX(DYNhelp,78) = divinvGuarded(DYNX(DYNhelp,77),"2.0*pipe_3.flowModel.crossAreas[1]");
  DYNX(W_,341) = DYNX(DYNhelp,78)*DYNX(DYNhelp,8)*(-2)*DYNX(W_,339);
  DYNX(DYNhelp,79) = divinvGuarded(DYNX(W_,241),"pipe_3.flowModel.dp_nominal");
  DYNX(W_,298) = DYNX(DYNhelp,79)*DYNX(W_,242)*(DYNX(W_,341)-DYNX(DP_,48)*
    DYNX(W_,220)*DYNX(DP_,47));
  DYNX(W_,322) = DYNX(W_,131)*DYNX(W_,123)*(DYNX(W_,300)-DYNX(W_,313));
  DYNX(DYNhelp,80) = 2.0*DYNX(W_,123);
  DYNX(DYNhelp,81) = divinvGuarded(DYNX(DYNhelp,80),"2.0*pipe_1.flowModel.crossAreas[1]");
  DYNX(W_,324) = DYNX(DYNhelp,81)*DYNX(DYNhelp,6)*(-2)*DYNX(W_,322);
  DYNX(W_,305) = DYNX(W_,307)+DYNX(W_,87);
  DYNX(W_,331) = DYNX(W_,173)*DYNX(W_,165)*(DYNX(W_,305)-DYNX(W_,300));
  DYNX(DYNhelp,82) = 2.0*DYNX(W_,165);
  DYNX(DYNhelp,83) = divinvGuarded(DYNX(DYNhelp,82),"2.0*pipe_2.flowModel.crossAreas[1]");
  DYNX(W_,333) = DYNX(DYNhelp,83)*DYNX(DYNhelp,7)*(-2)*DYNX(W_,331);
  DYNX(DYNhelp,84) = DYNX(W_,312)*DYNX(W_,120);
  DYNX(W_,297) = DYNX(DYNhelp,84)*DYNX(W_,307);
DYNX(DYNhelp,85) = DYNX(DP_,28)*DYNX(W_,134);
DYNX(DYNhelp,86) = divinvGuarded(DYNX(W_,155),"pipe_1.flowModel.dp_nominal");
DYNX(DYNhelp,87) = DYNX(DP_,38)*DYNX(W_,176);
DYNX(DYNhelp,88) = divinvGuarded(DYNX(W_,197),"pipe_2.flowModel.dp_nominal");
SetVector(residue__, 1, DYNX(W_,281)-DYNX(DYNhelp,86)*DYNX(W_,156)*(DYNX(W_,324)
  -DYNX(DYNhelp,85)*DYNX(DP_,27)));
SetVector(residue__, 2, DYNX(W_,297)-DYNX(DYNhelp,88)*DYNX(W_,198)*(DYNX(W_,333)
  -DYNX(DYNhelp,87)*DYNX(DP_,37)));
SetVector(residue__, 3, DYNX(W_,281)-DYNX(W_,298)-DYNX(W_,297));

Jacobian(Jacobian__)
MatrixZeros(Jacobian__);
DYNX(DYNhelp,89) = DYNX(W_,131)*DYNX(W_,123)*DYNX(W_,156);
DYNX(DYNhelp,90) = DYNX(DYNhelp,6)*2.0*(1231.056*DYNX(W_,294)-1688895.3599999999
  *DYNX(W_,293))*DYNX(W_,48)*DYNX(DYNhelp,89);
DYNX(DYNhelp,91) = IF DYNX(W_,280) THEN 1*DYNX(W_,279) ELSE DYNX(DP_,62)*
  DYNX(W_,279);
DYNX(DYNhelp,92) = DYNX(DYNhelp,86)*DYNX(DYNhelp,81)*DYNX(DYNhelp,6)*(-2.0)*
  DYNX(DYNhelp,89);
DYNX(DYNhelp,93) = DYNX(W_,173)*DYNX(W_,165);
DYNX(DYNhelp,94) = DYNX(W_,198)*DYNX(DYNhelp,93);
DYNX(DYNhelp,95) = DYNX(W_,217)*DYNX(W_,208);
SetMatrixLeading(Jacobian__, 1, 1, 3, (1.0-DYNX(DYNhelp,86)*DYNX(DYNhelp,81)*
  DYNX(DYNhelp,90))*DYNX(DYNhelp,91)-DYNX(DYNhelp,92));
SetMatrixLeading(Jacobian__, 1, 2, 3,  -DYNX(DYNhelp,92));
SetMatrixLeading(Jacobian__, 2, 2, 3,  -DYNX(DYNhelp,88)*DYNX(DYNhelp,83)*
  DYNX(DYNhelp,7)*2.0*DYNX(DYNhelp,94));
SetMatrixLeading(Jacobian__, 2, 3, 3, DYNX(DYNhelp,84)-DYNX(DYNhelp,88)*
  DYNX(DYNhelp,83)*DYNX(DYNhelp,7)*(-2.0)*DYNX(DYNhelp,94));
SetMatrixLeading(Jacobian__, 3, 1, 3, DYNX(DYNhelp,91));
SetMatrixLeading(Jacobian__, 3, 2, 3, DYNX(DYNhelp,79)*DYNX(DYNhelp,78)*
  DYNX(DYNhelp,8)*(-2.0)*DYNX(W_,242)*DYNX(DYNhelp,95));
SetMatrixLeading(Jacobian__, 3, 3, 3, (-1.0)*DYNX(DYNhelp,84));

SolveNonLinearSystemOfEquationsInit(Jacobian__, 0, 0, 0, residue__, x__,"Tag: simplified homotopy initialization.nonlinear[1]");
DYNX(W_,347) = GetVector(x__, 1);
DYNX(W_,300) = GetVector(x__, 2);
DYNX(W_,307) = GetVector(x__, 3);
EndNonLinearSystemOfEquationsInit(residue__, x__, 1);
 /* End of Non-Linear Equation Block */ }



BreakSectionEnd()

BreakSectionFunctionStart(2);
BreakSectionFunctionCallNew(1);
BreakSectionFunctionCallNew(4);
BreakSectionFunctionEnd()
