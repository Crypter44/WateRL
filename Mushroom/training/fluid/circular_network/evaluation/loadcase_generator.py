import numpy as np


def gen_tests_for_visual_inspection():
    """
    Generate a small set of test cases for visual inspection.

    The test cases are chosen to be visually distinct and easy to interpret.
    There are 5 categories of test cases:
    - Minimum load cases (1.6): All flows are at the minimum value.
    - Low load cases (2.6): One flow is at the maximum value, the rest are at the minimum value.
    - Medium load cases (3.6): Two flows are at the maximum value, the rest are at the minimum value.
    - High load cases (4.6): Three flows are at the maximum value, the rest are at the minimum value.
    - Maximum load cases (5.6): All flows are at the maximum value.
    In every category, the test cases cover all possible combinations of the 4 flows,
    as stated in the description above.
    """
    return [
        # Minimum load cases (1.6):
        (0.4, 0.4, 0.4, 0.4),

        # Low load cases (2.6):
        (0.65, 0.65, 0.65, 0.65),
        (1.4, 0.4, 0.4, 0.4),
        (0.4, 1.4, 0.4, 0.4),
        (0.4, 0.4, 1.4, 0.4),
        (0.4, 0.4, 0.4, 1.4),

        # Medium load cases (3.6):
        (0.9, 0.9, 0.9, 0.9),
        (1.4, 1.4, 0.4, 0.4),
        (0.4, 1.4, 1.4, 0.4),
        (0.4, 0.4, 1.4, 1.4),
        (1.4, 0.4, 0.4, 1.4),
        (0.4, 1.4, 0.4, 1.4),
        (1.4, 0.4, 1.4, 0.4),

        # High load cases (4.6):
        (1.15, 1.15, 1.15, 1.15),
        (1.4, 1.4, 1.4, 0.4),
        (1.4, 1.4, 0.4, 1.4),
        (1.4, 0.4, 1.4, 1.4),
        (0.4, 1.4, 1.4, 1.4),

        # Maximum load cases (5.6):
        (1.4, 1.4, 1.4, 1.4),
    ]


def gen_tests_sorted_by_maximum_demand(
        minimum_demand: float = 0.4,
        maximum_demand: float = 1.4,
        num_tests_per_step: int = 4,
        num_steps: int = 10,
        valve_with_maximum_demand: int | None = None,
        save_path: str = None
):
    """
    Generate a set of test cases sorted by the maximum demand in the test case.

    The test cases are generated by increasing the current maximum demand
    from the minimum demand to the specified maximum demand.
    For each step, num_tests_per_step test cases are generated.
    In each test case, one valve is set to the current maximum demand,
    while the other valves are set to a random value between the minimum demand and the current maximum demand.

    :param minimum_demand: The starting demand for each valve.
    :param maximum_demand: The maximum demand, which will be reached in the last test case.
    :param num_tests_per_step: The number of test cases to generate for each step.
    :param num_steps: The number of steps to take from the minimum demand to the maximum demand.
    Higher values will result in more test cases and a finer granularity.
    Lower values will result in fewer test cases and a coarser granularity.
    :param valve_with_maximum_demand: The valve that will be set to the maximum demand in each test case.
    If None, the valve will be cycled.
    :param save_path: The path to save the generated test cases to. If None, the test cases will not be saved.
    """
    tests = []
    step_size = (maximum_demand - minimum_demand) / num_steps

    tests.append([minimum_demand] * 4)
    for s in range(num_steps - 1):
        minimum = minimum_demand
        maximum = minimum_demand + (s + 1) * step_size

        for i in range(num_tests_per_step):
            if valve_with_maximum_demand is None:
                v = i % 4
            else:
                v = valve_with_maximum_demand

            test = np.round(np.random.uniform(minimum, max(minimum, maximum - step_size), 4), 4).tolist()
            test[v] = maximum
            tests.append(test)
    tests.append([maximum_demand] * 4)

    if save_path is not None:
        np.save(save_path, np.array(tests))
        np.savetxt(save_path, np.array(tests))

    return tests


def gen_tests_sorted_by_total_demand(
        minimum_total_demand: float = 1.6,
        maximum_total_demand: float = 5.6,
        num_tests_per_step: int = 4,
        num_steps: int = 10,
        save_path: str = None,
        minimum_individual_demand: float = 0.4,
        maximum_individual_demand: float = 1.4
):
    """
    Generate a set of test cases sorted by the total demand in the test case.

    The test cases are generated by increasing the total demand
    from the minimum demand to the specified maximum demand.
    For each step, num_tests_per_step test cases are generated.
    In each test case, the total demand is set to the current total demand,
    while the individual demands are set to random values between the minimum demand and the current total demand.

    :param minimum_total_demand: The starting demand for each valve.
    :param maximum_total_demand: The maximum demand, which will be reached in the last test case.
    :param num_tests_per_step: The number of test cases to generate for each step.
    :param num_steps: The number of steps to take from the minimum demand to the maximum demand.
    Higher values will result in more test cases and a finer granularity.
    Lower values will result in fewer test cases and a coarser granularity.
    :param save_path: The path to save the generated test cases to. If None, the test cases will not be saved.
    """
    tests = []
    step_size = (maximum_total_demand - minimum_total_demand) / num_steps

    tests.append([minimum_total_demand / 4] * 4)
    for s in range(num_steps - 1):
        total_demand = minimum_total_demand + (s + 1) * step_size

        for i in range(num_tests_per_step):
            random_numbers = np.random.dirichlet(np.ones(4))
            scaled_numbers = random_numbers * (total_demand - 4 * minimum_individual_demand)
            final_numbers = scaled_numbers + minimum_individual_demand
            c = 0
            while np.any(final_numbers > maximum_individual_demand):
                if c > 10:
                    break
                excess = np.sum(final_numbers[final_numbers > maximum_individual_demand] - maximum_individual_demand)
                final_numbers[final_numbers > maximum_individual_demand] = maximum_individual_demand
                final_numbers[final_numbers < maximum_individual_demand] += excess / np.sum(
                    final_numbers < maximum_individual_demand)
                c += 1
            tests.append(np.round(final_numbers, 4).tolist())
    tests.append([maximum_total_demand / 4] * 4)

    if save_path is not None:
        np.save(save_path, np.array(tests))
        np.savetxt(save_path, np.array(tests))

    return tests

